#unsorted
awk '!a[$0]++' # print unique lines (!a[$0]++ can be replaced with a[$0]++==0 or ++a[$0]==1)
awk 'a[$0]++' # print lines that have been seen before (a[$0]++ can be replaced with a[$0]++>0 or ++a[$0]>1)
awk '!a[$2]++' # print unique lines by the second field
awk '++a[$0]==4' # print lines that appear four or more times
awk '{if(/^(tag1|tag2) /){print|"sort -sk1,1"}else{print}}' # print lines that start with tag1 or tag2 after other lines sorted by the tag
curl 'api.stackexchange.com/2.2/users/22565/answers?site=unix&pagesize=100&page=1&filter=!-.mgWMP7sO7J'|gzip -d|jq -r '.items[]|"<h2><a href="+.link+">"+.title+"</a></h2>"+.body'
find . -name \*.flac|parallel ffmpeg -i {} -aq 2 {.}.mp3\;rm {};find . -name \*.cue|parallel mp3splt -c {} {.}.mp3
curl -sG --data-urlencode q=query http://www.google.com/uds/GwebSearch?v=1.0&rsz=large&hl=en'|jq -r '.responseData.results[0].unescapedUrl'
curl 'http://ajax.googleapis.com/ajax/services/search/images?v=1.0&q=query&imgsz=xxlarge|huge&rsz=large'|jq -r '.responseData.results[].unescapedUrl'
youtube-dl $playlistid
youtube-dl https://www.youtube.com/user/username
curl -s 'http://gdata.youtube.com/feeds/api/users/username/uploads?alt=json'|jq -r '.feed.entry[].link[].href'|parallel youtube-dl
curl -s "http://gdata.youtube.com/feeds/api/videos/$videoid/related?alt=json&start-index=1"|jq -r '.feed.entry[].link[0].href'|parallel youtube-dl
curl 'http://api.stackexchange.com/2.3/search/advanced?site=stackoverflow&tagged=emacs&pagesize=100&page=1'|gzip -d|jq .
curl -s "http://ws.audioscrobbler.com/2.0/?api_key=$key&format=json&method=artist.getsimilar&artist=$artist"|jq -r '.similarartists[].artist.name'
curl -s "http://ws.audioscrobbler.com/2.0/?api_key=$key&format=json&method=artist.getTopTracks&artist=$artist"|jq -r '.toptracks.track[].name'
seq 0 25 499|parallel -j10 -k curl -s http://www.commandlinefu.com/commands/browse/sort-by-votes/plaintext/{}\|sed 1,2d
curl -s http://www.commandlinefu.com/commands/browse/sort-by-date/json/{0..999..25}|jq -r '.[]|select(.votes|tonumber>2)|.command+" # "+.summary'
curl -s 'http://api.tumblr.com/v2/blog/example.tumblr.com/posts?type=photo&offset=1&api_key='|jq -r '.response.posts[].photos[].original_size.url'
curl -L 'http://someblog.blogspot.com/atom.xml?max-results=499'|grep -Eio 'href=&quot;[^&]*\.(jpg|jpeg|png)'|cut -d\; -f2
gzip -dk file.gz # decompress and keep the original file (gunzip is equivalent to `gzip -d` and removes the original file)
tar --exclude .DS_Store -cjf directory.tbz directory # create a bzip2 archive (-j uses bzip2)
tar -tvf file.tar # list contents in a verbose format
zip directory.zip -x .DS_Store -r directory
rar a dir.rar dir
unrar e dir.rar
brew install p7zip;7z e *.7z *.zip *.rar
lame --preset help # show help about presets (-V2 or -V0 is recommended over -b320)
for p in insane extreme standard medium;do flac -cd input.flac|lame --preset $p - $p.mp3;done
flac *.wav # convert WAV to FLAC
sox stereo.wav -c 1 mono.wav
sox stereo.wav left.wav remix 1;sox stereo.wav right.wav remix 2
sox input.wav reversed.wav reverse
sox input.wav 4xloop.wav repeat 3
sox input.wav octaveup.wav pitch 1200
flac -cd file.flac|sox - -n spectrogram # create a spectrogram image
for f in *.mp3;do a=${f%% - *};t=${f#* - };t=${t%.mp3};mid3v2 --artist "$a" --title "$t" "$f";done
mp3gain -r -c -s i *.mp3 # add mp3gain tags (-r applies track gain, -c ignores warnings about clipping, and `-s i` uses ID3v2 instead of ID3v1)
awk -F\\t -v OFS=\\t '{x=$3;$3=$4;$4=x}1'
awk 'BEGIN{x=1}{x*=$0}END{print x^(1/NR)}' # geometric mean
while IFS= read -r -n1 c;do printf '&#x%x;' "'$c";done
gsed 's/\b./\u&/g' # titlecase (\u converts the next character to uppercase)
sort -sk1,1 # sort lines by the first field and keep the original order within groups of lines with the same first field
grep -Eo \\S+|sort|paste -sd' ' - # sort words
grep -o .|sort|paste -sd\\0 - # sort characters
echo "<img src=\"data:$(file --mime-type -b file.png);base64,$(base64 file.png)\">"
gsed 0~10G|awk -v RS= '{print"<div>"$0"</div>"}' # add div tags around groups of 10 lines
curl -s http://www.unicode.org/Public/UNIDATA/UnicodeData.txt|awk -F\; '$1=="'$(printf %04x \'$'\u1234')'"{print$2}' # find the name of the character U+1234
printf \\U$(curl -s http://www.unicode.org/Public/UNIDATA/UnicodeData.txt|awk -F\; '$2=="YEN SIGN"{print$1}') # print the character YEN SIGN
curl -s http://www.unicode.org/Public/UNIDATA/UnicodeData.txt|while read l;do [[ ${l#*;} != '<control>'* ]]&&printf \\U$(printf %08s ${l%%;*});printf ';%s\n' "$l";done
while read l;do open "http://rutracker.org/forum/tracker.php?nm=$(printf %s "$l"|xxd -p|tr -d \\n|sed 's/../%&/g')";done
brew install htmlcompressor;htmlcompressor --compress-css test.html -o test.html # minify HTML
/Applications/calibre.app/Contents/MacOS/ebook-convert input.epub output.txt
login -pfq $USER # start a login shell (-p preserves the environment, -f skip authentication, and -q doesn't show a login message)
ulimit -a;ulimit -Ha # show soft and hard limits
uname -srm # print the system name, release, and machine name
sleep 1&pid1=$!;sleep 2&wait $pid1;echo first job exited;wait;echo all jobs exited
cd "${0%/*}" # change the working directory to the directory of a script
ls -dt /var/log/*.log|head -n5|xargs tail -n0 -f
find .|awk -F/ 'length($NF)>50'
find . -type f -name \*.\*|awk -F. '++a[tolower($NF)]<=4' # list up to four files per filename extension
eval printf %s "$x" # the inverse of `printf %q "$x"`
awk 'NR==FNR{a[$0];next}!($0 in a)' readurls.txt urlstoread.txt|head -n10|tee -a readurls.txt|xargs open
find . -name \*.jpg|xargs identify -format '%w %h %f\n'|awk '$1*$2<5e5{print$3}'|xargs rm
printf %s\\n "${@-$(cat)}" # get input as arguments or from STDIN
brew install html-xml-utils;hxselect 'ol li:first-child' file.html
(ulimit -t 1000;cmd) # terminate cmd after it has used 1000 seconds of CPU time
for dir in ~/imagedirs/*;do echo "<h1>$dir</h1>";printf %s\\n $dir/*|head -n50|awk '{printf,"%s","<img src="$0" height=250>"}';done>/tmp/a.html;open /tmp/a.html
gfind -type f ! -empty -printf '%-20s%p\n'|sort|guniq -w20 -D|cut -c21-|gxargs -rd\\n gmd5sum|sort|guniq -w32 -D|cut -c35-
gdate -d "$(curl -ILs example.com|tr -d \\r|sed -n 's/^Last-Modified: //p')" +%s
for d in ~/*/*/;do echo "$(find "$d"|wc -l) $d";done|sort -n
while [[ resp=$(curl http://api.example.com) = *'request limit'* ]];do sleep 600;done
find . -type f -exec md5 -r {} +|awk 'NR==FNR{a[$0];next}$1 in a{print$2}' seenmd5.txt -|xargs rm
gfind -printf '%s %p\n'|sort -rn|awk -F/ '!a[$NF]++' # find the largest file for each basename (%s is size and %p path)
curl http://www.gnu.org/software/findutils/manual/info/find-info.tar.gz|tar -xC /usr/local/share/info
if [ $# = 0 ];then set -f;IFS=$'\n' set -- $(cat);set +f;fi # set lines from STDIN as arguments if there are no arguments
curl 'api.stackexchange.com/2.2/search/advanced?site=stackoverflow&tagged=emacs&pagesize=100&page=1'|gzip -d|jq .
curl -s "ws.audioscrobbler.com/2.0/?api_key=$apikey&format=json&method=artist.getsimilar&artist=$artist"|jq -r '.similarartists[].artist.name'
curl -s "ws.audioscrobbler.com/2.0/?api_key=$apikey&format=json&method=artist.getTopTracks&artist=$artist"|jq -r '.toptracks.track[].name'
curl -s "ws.audioscrobbler.com/2.0/?api_key=$apikey&format=json&method=artist.getTopAlbums&artist=$artist"|jq -r '.topalbums.album[].name'|head -n3
curl -s "ws.audioscrobbler.com/2.0/?api_key=$apikey&format=json&method=artist.getInfo&artist=$artist"|jq -r '(.artist.stats.listeners|tostring)+" "+.artist.name'
curl www.commandlinefu.com/commands/matching/ffmpeg/$(printf ffmpeg|base64)/plaintext
curl -s "api.tumblr.com/v2/blog/example.tumblr.com/posts?type=photo&api_key=$apikey&offset=1"|jq -r '.response.posts[].photos[].original_size.url'
curl -u username https://mail.google.com/mail/feed/atom # show a Gmail inbox
curl -sG --data-urlencode q=query 'http://www.google.com/complete/search?output=toolbar'|xml sel -t -v //suggestion/@data # show the top ten completions
curl -sG --data-urlencode q=query "https://api.spotify.com/v1/search?type=track"|jq -r '.tracks.items[0].uri//empty'|xargs open -g
tar --exclude '.*' -czf directory.tgz directory
tar -xf archive.tgz -C /tmp # change directory to /tmp before extracting files
tar -xf archive.tar archive/file
for f in 1.tar 2.tar;do tar -xf $f;done # `tar -xf 1.tar 2.tar` would attempt to extract a member named 2.tar from 1.tar
tar -cf archive.tar -I filelist.txt
tar -cjf dir.tbz dir # -j uses bzip2
zcat # equivalent to `gzip -cd`
gunzip # equivalent to `gzip -d`
unzip archive.zip -d /tmp
zipinfo # equivalent to `unzip -Z` (`unzip -l` lists files in a simpler format)
unzip -p file.docx word/document.xml # -p extracts to stdout (pipe)
cat multipart.zip.*>temp.zip;zip -FF temp.zip --out fixed.zip;unzip fixed.zip
rar a directory.rar directory # create an archive or add a file to an existing archive
unrar e archive.rar # extract
brew install p7zip;7a a directory.7z -e .DS_Store directory
7z l file.zip # list contents
aspell check file.txt # open an interactive spell checker
echo the teh|aspell list # teh
printf 'personal_ws-1.1 en\nteh\n'>a;echo the teh teeh|aspell list --personal=./a # teeh
echo say a|at '11:59pm 31.12'
at +2hours<<<'terminal-notifier -message ""'
at -f ~/bin/script.sh 23:59
atq # same as `at -l` (list queue)
atrm 14 # same as `at -d 14`
atrm $(atq|cut -f1) # remove all jobs
lame -q2 -b320 # the default for CBR is -q5 which is faster but lower quality than -q2
metaflac --list file.flac # show metadata
sox input.wav output.wav pad 1 2 # add one second of silence to the start and two seconds of silence to the end
soxi input.wav # sound exchange information
sox input.wav -t wav - pitch 1200|play - # transpose one octave
fluidsynth -i /usr/local/share/fluidsynth/generaluser.v.1.44.sf2 file.mid # play a midi file
for n in E2 A2 D3 G3 B3 E4;do play -n synth 4 pluck $n repeat 2;done
sudo easy_install pip;sudo pip install mutagen;mid3v2 -h # id3v2 and id3tag don't support Unicode and id3tool doesn't support ID3v2
mid3v2 --artist Artist --title Title --album Album --track 1 file.mp3
mid3v2 -l file.mp3 # list tags
mid3v2 -l file.mp3|sed -n s/^TPE1=//p # artist
mid3v2 -D file.mp3 # delete all tags
for f in *.mp3;do l=$(mid3v2 -l "$f");mv "$f" "$(printf %02d $(sed -n 's,^TRCK=0*\([^/]*\).*,\1,p'<<<"$l")) $(sed -n 's,^TIT2=,,p'<<<"$l"|tr '/:?<>\\*|"^' _).mp3";done
mid3v2 --delete-frames $(mid3v2 -l *|LC_ALL=C sed -n 's,^\([^=]*\)=.*,\1,p'|sort -u|grep -Exv 'TPE1|TIT|TALB|TRCK|TYER|TDRC'|tr \\n ,) *
brew install eyed3;eyeD3_script --remove-image file.mp3;eyeD3_script --add-image=cover.jpg:FRONT_COVER file.mp3
brew install mp4v2;mp4info file.m4a
brew install mp4v2;mp4art --overwrite --add cover.jpg file.m4a
awk 'NR==1||/pattern/' file.csv
awk '$2!~/^[0-9]+$/'
awk -F'[/?]' '{print$(NF-1)}'
awk '$0<=x;{x=$0}' # test if a list of numbers is strictly increasing
awk -F\\t -v OFS=\\t '{t=$3;$3=$4;$4=t}1' # swap TSV columns
awk '{$2="";$3=""}1'
awk -F\\t '{print$3"\t"$2}' # `cut -f3,2` prints field 2 first
awk 'BEGIN{x=1}{x*=$0}END{print x^(1/NR)}' # geometric mean
awk NF-- # remove the last field (gawk and mawk but not nawk)
awk '!a[$0]++' # unique lines (!a[$0]++ can be replaced with a[$0]++==0 or ++a[$0]==1)
awk 'a[$0]++' # lines that have been seen before (a[$0]++ can be replaced with a[$0]++>0 or ++a[$0]>1)
awk -F\\t '!a[$2]++' # unique lines by the second column
awk '++a[$0]==4' # lines that appear 4 or more times
awk -F\; 'NR==FNR{a[$1]=$2;next}{print a[$0],$0}' file1 file2
awk 'BEGIN{print exp(1),log(1e9)/log(10)}' # 2.71828 9
awk 'FNR==NR{a[$1,$2];next}$1 SUBSEP $2 in a' 1.txt 2.txt # a[$1,$2] is the same as `a[$1 SUBSEP $2]` and a[$1"\034"$2]
gawk '$2>systime()-86400*30'
awk /pattern/,0 # same as `awk /pattern/,EOF`
awk 'NR==FNR{a[$4];next}$2 in a' file file # lines where the second column is the fourth column of some other line
awk -v RS= -v FS=\\n -v OFS=\\t -v ORS=\\n '{$1=$1}1' # replace two or more linefeeds with a linefeed and single linefeeds with a tab
awk '{getline l;print l;print$0}' # swap every pair of two lines
awk '{if(/^ /)print;else a[NR]=$0}END{for(i in a)print a[i]}' # like `ruby -e 'puts readlines.partition{|l|l=~/^ /}'`
awk '{if(/^(tag1|tag2) /){print|"sort -sk1,1"}else{print}}' # print lines that start with tag1 or tag2 after other lines grouped by the tag
awk '{l=length();l>max&&max=l}END{print max}' # like `gwc -L`
awk '{printf "%25s",$1;$1="";print}' # like `while read first rest;do printf '%25s %s' "$first" "$rest";done`
awk 'NR==FNR{a[$0]++;next}$0 in a{printf " "}1' file1 file2 # insert a space to the start of lines in file2 that also appear in file1
awk 'NR==FNR{a[substr($0,1,20)];next}substr($0,1,20) in a' file1 file2
awk '/pattern/{print NR;exit}' # line number of the first line that matches a pattern
awk '/pattern/{print NR}' # line numbers of all lines that match a pattern
awk '/pattern/{n=NR}END{print n}' # line number of the last line that matches a pattern
awk '{s+=$0}END{print s}' # sum
awk 'BEGIN{p=1}{p*=$0}END{print p}' # product
awk '/pattern/{print prev}{prev=$0}'
awk '{print toupper($0)}'
awk '{$NF=""}1' # remove the last field and keep the delimiter
gawk NF-- # remove the last field and don't keep the delimiter (doesn't work in BWK awk)
awk '{$1="";$2="";print substr($0,3)}' # remove the first two fields
awk '{print substr($0,length($1 $2)+3)}' # remove the first two fields
awk '{x=$0;$3="";if(!a[$0]++)print x}' # unique lines ignoring the third column
awk 'BEGIN{srand();print int(6*rand())+1}'
awk 'BEGIN{srand()}rand()<0.5' # print about half of lines
for i in - - -;do awk 'BEGIN{print rand(),rand()}';done # prints same same sequence of values three times
for i in - - -;do awk 'BEGIN{srand();print rand()}';done # usually prints the same value three times because srand is based on second-precision time
awk 'BEGIN{srand()}{a[NR]=$0}END{for(i=1;i<=4;i++){print a[int(rand()*NR)+1]}}' # like `shuf -rn4`
awk '{print length,$0}'|sort -nk1,1|cut -d' ' -f2- # sort by length
awk '{print$NF,$0}'|sort -k1,1|cut -d' ' -f2- # sort by last field
awk -F '' -v OFS=\\n '{$1=$1}1' # like `grep -o .`
awk '{a[$1]+=$2}END{for(i in a)print i,a[i]}' # sum the second columns of lines where the first column is the same
awk '{sub(/[^ ]+ /,"")}1' # remove the first column
awk /./ # like `grep .`
awk 'NR<5||/./' # remove empty lines but not on the first 4 lines
awk '{if($4<0)$4=-$4}1' # replace the fourth field with an absolute value
awk '/^SECTION[0-9]+$/{close("section_"n".txt");n++;next}{print>"section_"n".txt"}' file.txt
awk '(NR%2&&/pat1/)||(!(NR%2)&&/pat2/)'
{ rm file;awk '!a[$0]++'>file; }<file
awk 'NR==FNR{a[$0];next}$0 in a' 1.txt 2.txt # lines in both files (lines repeated in 2.txt are printed multiple times)
awk 'NR==FNR{a[$0];next}!b[$0]++&&$0 in a' 1.txt 2.txt # unique lines in both files
awk 'NR==FNR{a[$0];next}!b[$0]++&&!($0 in a)' 1.txt 2.txt # unique lines only in 2.txt
awk 'NR==FNR{a[$1]=$2;next}{print a[$0],$0}' file1 file2
awk -F'\t' 'NR==FNR{a[$1]=$2;next}{$9=a[$1]}1' 1.txt 2.txt # replace field 9 with field 2 in 1.txt where fields 1 are the same
awk -F'\t' 'NR==FNR{a[$1]=$2;next}{$i in a&&$9=a[$1]}1' 1.txt 2.txt # don't make $9 empty if 1.txt doesn't contain same $1
ls -l|awk '{k=0;for(i=0;i<=8;i++)k+=((substr($1,i+2,1)~/[rwx]/)*2^(8-i));if(k)printf "%0o\n",k}' # octal permissions
awk -F\\t '{print$0>>$5.tsv}'
awk 'NR==FNR{a[NR]=$0;next}{x=a[FNR];if($0!=x)printf "%s;%s;%s\n",FNR,x,$0"}' file1 file2 # print differing lines with line numbers
awk -F'\t' '{printf "%35s  %s\n",$1,$2}'
awk '/<table>/,/<\/table>/'
awk '/<table>/,/<\/table>/{print;exit}'
awk '/pattern/{getline;print}' # print lines after matching lines
awk '/pattern/{print x}{x=$0}' # print lines before matching lines
v="$v" awk -F/ 'tolower($NF)==tolower(ENVIRON["v"])'
awk '/^$/||!a[$0]++'
echo 1381872817|gawk '{print strftime("%c",$0)}'
awk 'FNR==1{print FILENAME"\n"}1' *.txt
awk '{a[$0]+=1}END{for(i in a)print a[i],i}'
awk 'function f(n){return(n<2?n:f(n-1)+f(n-2))}BEGIN{while(i<24){print f(i++)}}'
awk 'FNR==NR{a[$0]}$0 in a{$0="x "$0}1' file1 file2
awk '{if(length(x$0)>70){print x;x=$0}else{if(!x){x=$0}else{x=x" "$0}}}END{if(x!=$0)print x}'
awk '{sum+=$0;sumsq+=$0**2}END{print sqrt(sumsq/NR-(sum/NR)**2)}' # population standard deviation
awk '{delta=$0-avg;avg+=delta/NR;mean2+=delta*($1-avg)}END{print sqrt(mean2/NR)}' # population standard deviation
gawk '{a[$0]=NR}END{PROCINFO["sorted_in"]="@val_num_asc";for(i in a)print i}' # like `tail -r|awk '!a[$0]++'|tail -r`
cat /usr/local/share/awk/quicksort.awk
awk '{a[$0]}END{print NR,length(a)}' # number of lines and number of unique lines
gawk '{a[$0]++}END{PROCINFO["sorted_in"]="@val_num_asc";for(i in a)print a[i],i}' # like `sort|uniq -c|sort`
awk -v RS= # two or more newlines
seq 2|awk '-v RS=' '/^2/' # doesn't match 2 (^ always matches the beginning of a string and $ always matches the end of a string)
gawk -v RS='\n?\n?^## ' 1 # gawk and mawk treat a two character or longer RS as a regex but BWK awk doesn't
gawk -v RS='\r\n?|\n' 1 # CRLF or CR to LF (without |\n LF line endings would be doubled)
awk -v RS=\\0 '{gsub(/\r\n?/,"\n");printf $0}' # CRLF or CR to LF (RS="\0" disables using RS and `printf $0` doesn't include an extra newline)
awk '$1=="o"{a[$2]++}$1=="x"{a[$2]--}END{for(i in a)print i,a[i]}'
awk 'NR==FNR{uniq1[$0];next}{uniq2[$0]}END{print length(uniq1),length(uniq2)}' file1 file2
awk 'NR==FNR{u1[$0];next}!u2[$0]++&&$0 in u1{both++}END{print NR-FNR,FNR"\n"length(u1),length(u2)"\n"length(u1)-both,length(u2)-both,both}' file1 file2
awk '{if(/^ /)a[NR]=$0;else print}END{for(i in a)print a[i]}'
awk '{while(++i<=(78-length)/2)l=l"#";if(length%2==1)printf "#";print l" "$0" "l}'
awk 'FILENAME==ARGV[1]{a[$0];next}FILENAME==ARGV[2]{b[$0];next}$1 in a&&$2 in b' file1 file2 file3
awk 'NR==FNR{print$0}' <(printf '') <(echo x) # x (NR==FNR is true for the second file if the first file is empty but FILENAME==ARGV[1] is not)
awk '{while(match($0,/[0-9]+\.[0-9]+/)){printf "%s%.2f",substr($0,1,RSTART-1),substr($0,RSTART,RLENGTH);$0=substr($0,RSTART+RLENGTH)};print}'
awk 'BEGIN{print"a">>ENVIRON["HOME"]"file"}' # print"a">>"~/file" doesn't work
pbpaste|awk -f -
seq 4|awk '{s+=$0}END{print s/NR}' # 2.5
awk 'BEGIN{print int(23/4),23%4}' # 5 3
echo aa|awk '{gsub(/a+/,"b");print}' # b
awk 'BEGIN{printf "%.3f",1/3}' # 0.333
awk 'BEGIN{match("aabb",/b+/);print RSTART,RLENGTH}' # 3 2
awk 'BEGIN{match("aabb",/c+/);print RSTART,RLENGTH}' # 0 -1
echo aa|awk '{print toupper($0)}' # AA
echo 1 1.00|awk '$1+0==$2+0{print "true"}' # true
awk 'BEGIN{print substr("vwxyz",2,3)}' # wxy
awk 'BEGIN{n=split("x,y,z",a,",");print n,a[3]}' # 3 z
awk 'BEGIN{print index("xyz","yz")}' # 2
awk 'BEGIN{print OFMT}' # %.6g
awk 'BEGIN{OFMT="%.7f";print exp(1)}' # 2.7182818
awk 'BEGIN{print "-12.3e2xyz"+0}' # -1230
echo ';0.0'|awk -F\; '$1+0==$2{print "true"}' # true
awk 'BEGIN{print atan2(0,-1)}' # 3.14159
awk 'BEGIN{print exp(1),log(exp(4)),log(1e9)/log(10)}' # 2.71828 4 9
awk 'BEGIN{print int(1.5),int(-1.5)}' # 1 -1
echo 0xff|awk '{printf "%i",$0}' # 255 in nawk and mawk but 0 in gawk
echo 0xff|awk '{printf "%i",strtonum($0)} # 255 in gawk, nawk, and mawk
echo 0xff|gawk --non-decimal-data '{printf "%i",$0}' # 255
echo A|awk 'tolower($0)~/a/' # A
echo A|gawk -vIGNORECASE=1 /a/ # A
echo 'a,"b c",d'|gawk -v'FPAT=([^,]+)|("[^"]+")' '{print$2}' # "b c"
awk 'BEGIN{printf("%0*d",5,99)}' # 00099
echo /aa/bb/cc|awk -F/ -v OFS=/ '{$3="dd"}1' # /aa/dd/cc
echo ' a  b'|awk -F' ' '{print$2}' # b (setting FS to space is equivalent to not setting FS at all)
echo ' a  b'|awk -F'[ ]' '{print$2}' # a
awk 'BEGIN{print 2^53,2^53+1}' # 9007199254740992 9007199254740992 (2^53 is the largest integer that can be stored without losing precision)
gawk -vFIELDWIDTHS='2 4 2' '{print$2}'<<<abcdefgh # cdef
awk -v 'v=a\ba' 'BEGIN{print v}' # a
awk 'BEGIN{print ARGV[1]}' 'a\ba' # a\ba
v='a\ba' awk 'BEGIN{print ENVIRON["v"]}' # a\ba
awk 'BEGIN{x="a";x+="a";print x}' # 0
awk 'BEGIN{x="a";x=x"a";print x}' # aa
chmod -R u=rwX,go=rX . # X keeps files that were executable before as executable
chmod -R a-w,u+w,a+rX .
chown 0:0 file # same as `chown root:wheel file`
info coreutils sort
shuf -n3 # select three random lines
shuf -i1-100 # print the integers between 1 and 100 in random order
shuf -i1-100 -n1 # print one random integer between 1 and 100
shuf file -o file # shuffle a file in place
timeout 5m script.sh # run script.sh and send it a TERM signal if it doesn't exit within 5 minutes
while :;do timeout -s KILL 10m script.sh;done&>/dev/null&disown $!
realpath # like `readlink -f` (added in 2012)
vdir # equivalent to `ls -lb` (`ls -b` backslash-escapes ASCII control characters)
factor 24 # 24: 2 2 2 3
numfmt --to=si 1000 # 1.0K
numfmt --from=iec 1K # 1024
cut --output-delimiter=' '
find . -name \*.txt -printf %s\\n|awk '{s+=$0}END{print s}'|numfmt --to si # %s is size in bytes
printf 'aa;bb;cc;'|tac -s\; # cc;bb;aa;
stdbuf -o0 # disable output buffering (an alternative to unbuffer)
stdbuf -oL # make output line buffered
cp -R . dir2 # like `cp -R "$PWD"/ dir2`
gcp -b file1 file2 # if file2 exists, rename it to file2~
gcp -R --copy-contents # try to copy the contents of FIFOs and special files (usually hangs indefinitely if the directory contains FIFOs or special files)
find .|xargs gcp -t /target/ {} +
killall -INFO cp # make a cp process show how what the currently copied file is and how many percent of it has been copied
curl -A Mozilla/5.0
curl -e http://example.com # referer
curl -m 30 # max time
curl --retry 1 # retry failed downloads once (the default is to not retry)
curl --cacert certificate.pem
curl -LIs example.com -o /dev/null -w '%{url_effective}\n' # URL after redirections
curl -ILs example.com|sed -n 's,^Content-Length: ,,p'
curl 'example.com/*.jpg' -o 'file_#1.jpg'
headers=$(curl -L example.com -o example.html -D /dev/stdout|tr -d \\r) # -D dumps headers to a file
cut -d' ' -f4<<<' 1  2' # 2
cut -sd\" -f2 # print the part after the first double quote on lines that contain a double quote
rev|cut -c5-15|rev
echo 1,2,3|gcut -d, --complement -f2 # 1,3
date -u '+%F %TZ' # same as `TZ=UTC0 date '+%Y-%m-%d %H:%M:%SZ'`
date '+%-d. %-m.' # day of month and numeric month without leading zeros
date +%V # ISO week number
TZ=EST date +%z # -0500
TZ=UTC+7+72 date # 3 days ago in PDT
date -jf %FT%T 2013-12-31T23:59:59 +%s # a BSD alternative to `gdate -d 2013-12-31T23:59:59 +%s`
date -v+7d -jf %F 2013-12-31 +%F # a BSD alternative to `gdate -d '2013-12-31+7 days' +%F`
date -v +1d -v +mon # a BSD alternative to `gdate -d 'next monday'`
date -v -14d +%s # a BSD alternative to `gdate -d '2 weeks ago' +%s`
(($(date -v +30d -jf %F 2014-01-01 +%s)<$(date +%s))) # a BSD alternative to `(($(date +%s)<$(gdate -d '2014-01-01 +30days' +%s)))`
date -jf %F $(date +%Y)-12-31 +%j # a BSD alternative to `echo $(($(gdate +%j -d$(date +%Y)-12-31)-$(date +%j)))`
date -r 1360886400 # a BSD alternative to `gdate -d @1360886400`
gdate -r file # show the modification time of a file
TZ=UTC+7 gdate -d 'TZ="UTC-3" 2014-03-16 06:30'
[ $(gdate -d tomorrow +%m) = $(gdate +%m) ] # test if today is end of month
dd if=/dev/urandom of=1MiB bs=1048576 count=1 # GNU dd also supports bs=1M but OS X's dd doesn't
dd bs=5 count=1 # a POSIX alternative to `head -c5`
dd bs=3 skip=1 # remove the first 3 characters
dd conv=ucase if=/dev/stdin of=/dev/stdout # convert lowercase ASCII characters to uppercase
echo abcdef|dd conv=swab # badcfe (swap every pair of two bytes)
dd if=/dev/null of=file seek=1 bs=12345 # truncate a file to 12345 bytes
dd if=/dev/zero of=file bs=1024 seek=1 count=1 conv=notrunc # zero out the second 1 kiB block
diff -y --suppress-common-lines # show differing lines side by side (-y is --side-by-side)
diff -u 10 # output 10 lines of unified context
diff --unchanged-line-format= --old-line-format= --new-line-format=%L file1 file2 # GNU diffutils
dos2unix * # convert CRLF to LF, convert UTF-16 to UTF-8, and remove BOMs
dos2unix -n input.txt output.txt
sudo dtrace -n 'proc:::exec-success{trace(execname)}' # new processes
sudo dtrace -n 'proc:::exec-success{trace(curpsinfo->pr_psargs)}' # new processes with arguments
sudo dtrace -n 'syscall::unlink:entry{printf("%d %s %s",pid,execname,copyinstr(arg0))}' # deleted files
sudo dtrace -n 'syscall::open*:entry{printf("%d %s %s",pid,execname,copyinstr(arg0))}' # opened files
sudo dtrace -qn 'syscall::open*:entry/arg1&3/{printf("%d %s %s\n",pid,execname,copyinstr(arg0))}' # opened files in simpler format
sudo dtrace -n 'syscall::open*:entry/execname=="mdworker"/{printf("%s",copyinstr(arg0))}' # files opened by processes named mdworker
sudo dtrace -w -n 'BEGIN{panic()}' # cause a kernel panic (-w allows destructive actions)
sudo dtrace -n 'syscall::recvfrom:return{@[pid,execname]=sum(arg0)}' # number of bytes downloaded by each process
sudo dtrace -n 'syscall::sendto:return{@[pid,execname]=sum(arg0)}' # number of bytes uploaded by each process
sudo kill.d # signals sent to processes
sudo dtrace -n 'proc:::signal-send/pid/{printf("%s %d %d",execname,args[2],args[1]->pr_pid)}' # signals sent to processes
apropos dtrace|cat # list dtrace commands
man -a $(apropos dtrace|sed 's/\([^ ]*\)(\([^)]*\).*/\2 \1/') # read the man pages of dtrace commands
man -a \*.d # read the man pages of .d commands
sudo opensnoop # opened files
sudo execsnoop # new processes
sudo iosnoop # I/O events
sudo rwsnoop # read and write events
sudo iotop # processes with highest I/O use
sudo errinfo # syscall failures
sudo bitesize.d # I/O event size distribution
du . # all directories in the directory tree
du -a . # all files in the directory tree (including directories)
du -d1 . # the current directory and its subdirectories
du -ak|sort -rn|head
emacsclient -n 1.txt 2.txt # open files (-n is --no-wait)
emacsclient -s servername
emacsclient -e '(save-some-buffers t)'
emacsclient -e '(client-save-kill-emacs)'
wget http://randomsample.de/profile-dotemacs.el;emacs -Q -l profile-dotemacs.el -f profile-dotemacs
emacs -batch -f batch-byte-compile file.el # create file.elc
gzip -dc /usr/share/emacs/*/lisp/simple.el.gz
info info
info shuf # like `info coreutils 'shuf invocation'`
info --apropos xyz # search for xyz in the indexes of all info pages
info -w emacs # /usr/share/info/emacs (--where)
info -O gawk # go to the section for options
emacs /var/log/system.log --eval '(auto-revert-tail-mode 1)' --eval '(setq buffer-read-only t)' --eval '(goto-char (point-max))'
open -a emacs;emacsclient -n -e '(ido-find-file-in-dir "~/")'
git clone git://git.savannah.gnu.org/emacs.git
bzr branch bzr://bzr.savannah.gnu.org/emacs/trunk
exiftool file.jpg # list metadata
exiftool -args file.jpg # list metadata in a format that can be used as arguments for exiftool
exiftool -all= *.jpg # delete all metadata
exiftool -de *.jpg # delete EXIF metadata
exiftool -p '$Author' file.pdf # print the author
exiftool -Title=title -Author=author -Subject=subject -overwrite_original input.pdf
for f in *.pdf;do title=$(exiftool -p '$Title' "$f");exiftool -Title="$title ($f)" -overwrite_original "$f";done
exiftool -s3 -d %FT%T -DateTimeOriginal file.jpg # show the time when a photo was taken (-d specifies a date format)
exiftool -o . '-Filename<DateTimeOriginal' -d dir2/%F/%F-%H%M%S.jpg -r dir1 # rename files based on date and time (`-o .` copies files instead of moving them)
exiftool -AllDates-=6 . # shift all dates by 6 hours
exiftool -if '$EncodingProcess=~/Progressive/' -p '$FileName' *.jpg
exiftool -if '$ImageHeight*$ImageWidth<=5e5' -p '$Directory/$FileName' -r .
exiftool -if '$Aperture' -p '$FileName' # images with aperture metadata (images likely taken with a camera)
fdupes -r . # find duplicate files
fdupes -r . -dN # delete all files except the first file from each group of duplicates
fdupes -rf seen new|grep ^new|xargs gmv -t seen # -f omits the first file from each group of duplicates
ffmpeg -i video.mp4 -vn -c copy audio.m4a
ffmpeg -v quiet # no output
ffmpeg -v error # only errors
ffmpeg -c copy # -c:v copy -c:a copy
ffmpeg -ar 44100
ffmpeg -ac 1 # mono
ffmpeg -map_metadata -1 # remove metadata
ffmpeg -i file.flac -aq 1 file.mp3 # `-aq 1` corresponds to -V1 in lame (use `-b:a 320k` for 320 kb/s)
brew install ffmpeg --with-fdk-aac;ffmpeg -i input.flac -c libfdk_aac -vbr 4 output.m4a # libfdk_aac is better quality than libfaac
ffmpeg -i input.flac -c:a libfaac -q 150 output.m4a # -q 10 is lowest and -q 500 is highest
ffmpeg -ss 00:01:30 -t 0:0:20 -i input.mkv -c copy output.mkv # -ss = start seek
ffmpeg -i input.mp4 -c copy audio.m4a # extract audio
ffmpeg -i input.mkv -c copy output.mp4 # change container
ffmpeg -i input.mov -c:v libx264 -preset slow -crf 20 -pix_fmt yuv420p -c:a libfdk_aac -vbr 4 output.mkv
ffmpeg -c:v libx264 -preset slow # slower but better quality than the default preset (medium)
ffmpeg -c:v libx264 -crf # constant rate factor (0 is lossless, 51 is the lowest quality, the default is 23, and typical values are from 18 to 28)
ffmpeg -c:v libx264 -pix_fmt yuv420p # some video players don't support yuv444p (the default format)
ffmpeg -i input.mkv -vframes 1 -ss 0:5:23 frame.png
ffmpeg -i input.mkv -ss 0:37:55 -t 0:0:5 %06d.png # save every frame between 37:55 and 38:00
ffmpeg -t 10 -f s16le -i /dev/zero 10s-silence.wav
brew install ffmpeg --with-ffplay;ffplay file.mkv
ffmpeg -i input.mkv -r 0.05 %06d.png # save an image every 20 seconds
ffmpeg -i 1.mp3 -i 2.mp3 -i 3.mp3 -filter_complex concat=n=3:v=0:a=1 -aq 1 concatenated.mp3
ffmpeg -loop 1 -i image.png -i audio.m4a -c:a copy -c:v libx264 -crf 20 -pix_fmt yuv420p -shortest output.mp4
ffmpeg -i input.mkv -i input.m4a -c copy -map 0:0 -map 1:0 output.mkv
ffmpeg -i input.mkv -c copy -filter:v scale=-1:540 output.mkv # resize (-1 keeps aspect ratio)
ffprobe -i input.mp4 # like `ffmpeg -i input.mp4` but doesn't show an error about a missing output file
ffprobe -i input.mp4|&sed -n 's/^ *Duration: \([^,]*\).*/\1/p'
ffprobe -i input.mp4 -show_streams
ffprobe -v 0 -i input.mp4 -show_streams -of csv|head -n1|cut -d, -f10,11 # width and height
ffprobe -v 0 -i "$l" -show_streams|awk -F= '$1=="duration"{print$2}'
ffmpeg -i input.mkv -an -vn -map 0:s:0 subtitles.ass # extract subtitles
ffmpeg -i input.mkv -dump_attachment:t '' # extract attachments like fonts
ffmpeg -f lavfi -i color=c=black:s=1280x720 # use a black background
ffmpeg -i input.mp4|&awk -F'[ :,]' '$3=="Duration"{print 3600*$1+60*$2+$3}'
ffmpeg -i input.mp4 -vn -f wav -|oggenc -o audio.ogg -
ffmpeg -h encoder=libmp3lame
ffmpeg -h encoder=libx264
ffmpeg -f concat -i <(for f in $PWD/*.avi;do echo "file '$f'";done) -c copy output.avi
ffmpeg -i input.wav -filter:a atempo=1.5 output.wav # time stretch
ffmpeg -i input.wav -map_channel 0.0.0 left.wav -map_channel 0.0.1 right.wav
ffmpeg -i left.wav -i right.wav -filter_complex amerge output.wav
ffmpeg -i input.wav -af volume=0.7 output.wav
ffmpeg -i mono.wav -ac 2 stereo.wav
file --mime -b # print the mime type string (like `image/png; charset=binary`)
file --mime-type -b # print the mime type (like image/png)
file --mime-encoding -b # print the mime encoding (like charset=binary)
find . -name '[^ -~]'
find . -mtime 5 # files modified 5 days ago (where 4.1 is rounded up to 5 and 5.1 is rounded up to 6)
find . -mtime -5 # files modified 5 or fewer days ago
find . -mtime -10 -mtime +5
find . -size 2 # 513 to 1024 bytes (also in GNU find)
find . -size 2k # 2048 bytes
find . -size -2k # 0 to 2047 bytes
find . -size 123c # 123 bytes
find . -type f -size -100k -delete
find . \( -size 128080c -o -size 127478c \) -delete
find file.txt -mtime -7d|read;echo $?
find . ! -name . -prune # a POSIX alternative to `find . -mindepth 1 -maxdepth 1` (-prune doesn't descend to matched directories)
find ~/Music -type f ! -iname \*.mp3 ! -iname \*.m4a ! -path ~/Music/iTunes/\* ! -path ~/Music/Ableton/\* -delete
find . -type f -exec chmod -x {} + # directories that are not executable can't be listed
sudo find / -type f -size +100M -exec du -m {} +|sort -rn
find "$PWD" -type f -exec stat -f '%m %N' {} +|sort -rn|cut -f2- # sort by modification date
rm -r */*;find . -mindepth 1 -type d -delete
find . -mindepth 1 -exec test -e /path2/{} \;-print
find . -type f -exec test ! -s {} /path2/{} \;-delete # delete if the file in /path2/ has identical contents file
find . -type f -exec cmp -s {} /path2/{} \;-delete # delete if the file in /path2/ has identical contents file
find ~ ! -user $USER
find . -type d -empty -delete # delete empty directories
find . -type f -empty # same as `find . -type f -size 0`
[[ $(find ${TMPDIR}my.tempfile -mtime +30m) ]] # test if ${TMPDIR}my.tempfile was modified within 30 minutes
find . ! -name . -prune # like find . -d 1
find /Applications -type d -name \*.app -prune # -prune doesn't descend to matching directories
find . -type f -ctime -6h -exec gmv -t ../target {} + # -t specifies a target directory in GNU mv
find . -type l -exec test ! -e {} \;# find broken symlinks
find . -L -type l # -L follows symlinks once, so -type l returns true if the file is a broken symlink or a link to another symlink
find /usr/local/bin -depth 1 ! -type l
touch -t 201201010000 /tmp/start;touch -t 201201040000 /tmp/end;find / -newer /tmp/start -a ! -newer /tmp/end
find ~ ! -perm -u+r # files that are not readable by the user
gfind . -regextype posix-extended -iregex '.*\.(png|jpe?g)$'
gfind -printf '%T@ %p\n' # modification time as seconds since epoch and pathname
find . -type f -perm +100 # executable files
gfind . -type f -executable # executable files
gfind -type l -xtype d # symlinks to directories
gfind /usr/lib -type l -xtype f -exec du -Lh {} + # `du -L` follows symlinks
find . -type d -empty ! -name .git.\* -exec touch {}/.gitignore \;
sudo find / -user root -perm -4000 # setuid files owned by root
find . -newermt yesterday
find . -newermt 20131201 ! -newermt '20140101 -1 sec'
gfind -printf '%m %M %u %g %TFT%TR %CFT%CR %AFT%AR %s %Y %p\n' # octal mode, symbolic mode, user, group, mtime, ctime, atime, size, type, path
sudo find / -fstype autofs
find . -ls|sort -nrk7
find . -type f ! -links 1 # files with hard links
find . ! -perm 644 ! -perm 755 -exec ls -ld {} +
find . -type f -size 0c # a POSIX alternative to `find . -type f -empty`
find ~/torrents -type d -maxdepth 1 -empty -delete
find . -name foo\* -print -quit|grep -q .;echo $?
find / -samefile /‏file # hard links to /file
find -L / -samefile /‏file # symlinks or hard links to /file
find . -type d -exec chmod 755 {} + -or -type f -exec chmod 644 {} +
gnuplot -e 'plot "-"' # plot values from STDIN and display the output in an X window
gnuplot -e 'set term png;set output "/tmp/a.png";plot "-"';qlmanage -p /tmp/a.png # plot values from STDIN and display the output in a Quick Look window
gnuplot -e 'set xdata time;set timefmt "%Y-%m-%d";set format x "%m-%d";set style fill solid;plot "-" using 1:2:(1) with boxes'
grep -v -e aa -e bb # like `grep -Ev 'aa|bb'`
grep -E --color '^|pattern' # print all lines and highlight lines that match a pattern
grep -d skip # don't show "Is a directory" messages
grep -Eo '\S+'
grep -P '(?s)<section>.*?</section>' # s makes . match \n
grep -rl --null pattern .|xargs -0 rm
grep \\r -Ir . # find files with CRLF line endings (-I ignores binary files)
ggrep -oP '\p{Han}' # only kanji
ggrep -zoP '(?s)start.*end' # (?s) makes . match \n and -z uses null as input delimiter
LC_ALL=C grep -aho 'rutracker.org/forum/viewtopic.php?t=[0-9]*' *.torrent # -a searches in binary files
hexdump -ve '"%x"' # like `xxd -p|tr -d \\n`
hexdump -ve '1/4 "%u\n"' -n2 /dev/urandom # take one 4-byte element, format it as an unsigned integer, read 8 bytes from /dev/urandom
hexdump -n4 -ve '"%x"'</dev/urandom # random [0-9a-f]{8} string
iconv -f utf-8 -t utf-16 # UTF-16BE with BOM
iconv -f utf-8 -t utf-16be # UTF-16BE without BOM
iconv -f utf-8 -t utf-16le # UTF-16LE without BOM
iconv -f utf-8 -t ASCII//IGNORE # discard characters that cannot be represented in the target character set
iconv -f utf-8 -t ASCII//TRANSLIT # for example replace o-umlaut with "o or o depending on the implementation
iconv -f utf-8 -t ascii --unicode-subst='\\u%04x' # escape non-ASCII characters
man iconv_open # show a list of encoding names in OS X
[[ $(iconv -f UTF-8 -t ISO-8859-1//IGNORE file) = $(iconv -f UTF-8 -t ISO-8859-1 file) ]]
convert input.png -resize 50% output.png # the default filter is triangle (linear) which often makes images look blurry without additional sharpening
convert input.png -resize 50% -sharpen 0x0.4+0.8 output.png # ignore pixels outside an automatic radius, 0.4 radius, 80%
convert input.png -filter lanczos2 -resize 50% output.png # 2-lobe lanczos (does not necessarily need sharpening)
for f in triangle lanczos lanczos2 catrom;do convert input.png -filter $f -resize 50% $f.png;done # catrom is almost identical to lanczos2 and lanczos is sharper than lanczos2
for f in *.png;do convert "$f" -filter lanczos2 -resize 50% -format jpg -quality 92 "${f%png}jpg";done
convert input.png -filter point -resize 800% output.png # nearest neighbor
montage {1..9}.png -tile 3x3 -geometry 300x+0+0 3x3-grid.png
convert *.png -append vertically-stacked.png # like `montage *.png -tile 1x -geometry +0+0 vertically-stacked.png`
convert *.png +append horizontally-stacked.png # like `montage *.png -tile x1 -geometry +0+0 horizontally-stacked.png`
identify image.png
identify -format '%w %h %f\n' *.png # width, height, and filename
mogrify -thumbnail 50% -path /tmp *.png # like `for f in *.png;do convert $f -resize 50% /tmp/$f;done`
convert -monochrome
convert -transparent white # replace white areas with transparency
convert -resize '300x200>' # constrain proportions and only make images smaller
convert -resize 300x200^ # constrain proportions and make images smaller or larger so that they are at least 300x200
convert -resize 300x200^ -extent 300x200 -gravity center # make images smaller or larger and crop them so that they are exactly 300x200
convert input.gif -crop 200x200 +repage output.gif # crop to 200x200 (+repage resizes the image to remove the cropped out areas for GIFs)
convert input.png -crop 200x200 +repage output.png # crop to 200x200 (+repage removes metadata for the old canvas size for PNGs)
convert -crop 50x0+0+0 +repage # remove 50 pixels from the left side
convert -gravity southeast -crop 50x50+0+0 +repage # remove 50 pixels from the right and bottom sides
convert -crop +50+50 -crop -50-50 +repage # remove 50 pixels from all sides (like `-shave 50x50`)
convert -gravity east -crop 50%x100%+0+0 +repage # right half
convert input.png -crop 50%x100% +repage output.png # save the left half as output-0.png and the right half as output-1.png
convert 1.png -extent $(identify -format %wx%h 2.png) +repage 3.png
convert input.png -pointsize 20 -gravity south -annotate +0+15 'add text to bottom' output.png
for f in *.png;do convert "$f" -gravity south -extent 600x300 -pointsize 16 -gravity north -annotate +0+10 "${f%.png}" /tmp/"$f";done # add filenames above images
convert -resize 50% -extent 200% -gravity center # make the image 50% smaller but keep the canvas size
convert *.png -delay 3 -fuzz 1.5% -layers optimize output.gif # create an optimized animated GIF
convert -delay 3 # 0.03s delay between frames (`-delay 0` uses the default delay of 0.1s, and many environments display GIFs with a 0.01s or 0.02s delay with a higher delay)
convert -layers optimize # used to be equivalent to `-layers optimize-frame -layers optimize-transparency` but now includes some other optimizations
convert -layers optimize-transparency # replace pixels that are identical in the previous frame with transparency
convert -fuzz 1.5% # make `-layers optimize` treat pixels that differ by less than 1.5% as the same color, which can reduce file size by about half
convert *.png +dither file.gif # +dither disables dithering, which can make images look blotchy but reduces dithering noise and reduces file size
convert unoptimized.gif -layers optimize optimized.gif
convert -coalesce animation.gif frame%04d.png
convert page*.jpg output.pdf
convert input.pdf -colors 2 -density 150x150 output.pdf # convert an image-based PDF to black and white at 150 DPI
convert -size 10x10 'xc:rgba(0,0,0,0)' 10x10-transparent.png
convert -size 400x50 -gravity center -pointsize 32 -font /Library/Fonts/Verdana.ttf label:'some text' output.png
convert -background 'hsb(50%,50%,50%)' -border 10 -bordercolor 'hsb(50%,50%,50%)' -fill 'hsb(0%,50%,50%)' -pointsize 24 label:'some text' output.png
convert -size 1000x1000 tile:texture.png texture-tiled.png
convert 'input.png[1x1+1000+500]' txt: # print the color of the pixel at 1000x500
convert input.png -mattecolor gold -frame 10x10+5+5 framed.png
identify -verbose file.jpg|awk '$1=="Quality:"{print$2}'
for f in *.jpg;do mv $f $(identify -verbose $f|sed -n 's/^ *exif:DateTimeOriginal: //p'|tr ': ' -).jpg;done
convert input.png -gravity center -background white -extent 120%x100% output.png # increase the canvas size by 20% horizontally
brew install libjpeg;for f in *.jpg;do jpegtran -rotate 90 $f>$f.temp;mv $f.temp $f;done # rotate losslessly
exiv2 -d a # delete all EXIF metadata
exiv2 -k -F rename *.jpg # use date and time as filenames
jpeginfo -c *.jpg # check if jpeg files have errors
jot -s' ' - 1 10 3 # 1 4 7 10
jot -r 2 1 6 # like `shuf -i1-6 -n2 -r`
jot -w %02X -s: -r 5 1 256 # random MAC address
jot -s, -w aa%c 4 a # aaa,aab,aac,aad
jot -c 128 0 # ASCII charset
jot -c 26 A # like `LC_ALL=C printf %s\\n {A..Z}`
jot -s '' -c 95 32 # printable ASCII characters
rs 4 # 4 rows
rs 0 4 # 4 columns
jq . # like `python -mjson.tool|pygmentize -l javascript`
jq -r '.primaries[0].entries[]|select(.type=="meaning")[0].terms[0].text'
jq -r '.items[]|select(.owner.user_id!=12345)|"<h2><a href="+.link+">"+(.title|@html)+"</a></h2>"+.body'
jq -r '.response.posts[]|select(.source_url==null).note_count|add'
jq '.artists[0].name as $a|.tracklist[]|(.artists[0].name//$a)+" - "+.title'
jq '.items[]|select(.tags-["ignored-tag-1","ignored-tag-2"]==.tags)'
jq '.items|sort_by(.reputation/.answer_count)|reverse[]|[.user_id,.answer_count,.reputation]'
jq .a//.b # .b if .a is null or false
jq .a//empty # don't return null if .a doesn't exist
jq 'select(.a==null)' # `select(not .a)` only works if .a is boolean
jq 'select(.a|length==0)' # test if .a is an empty array or an empty string
seq 10|jq -s add # 55 (-s creates an array for input lines)
seq 6|jq -s 'reduce .[] as $x(1;.*$x)' # 720
jq -r -n --arg v 'H & M' '$v|@uri' # H%20%26%20M (-n is null input)
less -p ^EXAMPLES # same as `less +/^EXAMPLES`
zless file.gz # like `LESSOPEN='|gzip -cdfq -- %s' less file.gz`
ls -sfh source target # replace target with a symlink to source and don't follow target if it is a symlink to a directory
ln -s *.txt /dir/
open `ls -dt */*.jpg|head -n1` # -d prints paths including parent folders
ls -l /tmp/ # `ls -l /tmp` doesn't follow the symlink but `ls -l /tmp/` and `ls /tmp` do
gls -h --si # use multiples of 1000
touch $'\u00e4';LC_ALL=C busybox ls $'\u00e4'|cat # ?? (busybox ls replaces non-printable characters with question marks even if the output is not a terminal)
man lsof|less +/EXAMPLES
lsof -c bash # files opened by processes whose command name starts with bash
lsof -p $$ # files opened by the current process
lsof -ap$$ -dtxt -Fn|sed -n 2s/^.//p # path of the current process
lsof -i :123 # port 123
lsof -i -P|grep LISTEN # network listeners
lsof|cut -d' ' -f1|sort|uniq -c|sort -rn
man 2 intro # list of errors in errno.h and definitions of terms like process ID and session leader
apropos ruby # list man pages whose name or description contains ruby as any substring
whatis ruby # list man pages whose name or description contains ruby as a whole word
man re_format # POSIX BRE and ERE
whatis crontab;man 5 crontab # 5 is file formats and conventions
man 2 stat # 2 is system calls
man -a stat # show stat(1) first and then stat(2) after pressing q
man -w grep # /usr/share/man/man1/grep.1
MANWIDTH=80 man grep
man sed printf cut # press q to show the next page
man -K string # search for a string in all man pages and ask what pages to open
MANPAGER='col -bx' man $(ps -eco comm=|grep -Ev '^-| |grep'|sort -u)>/tmp/man.txt
grep -l 'Mac OS X' /usr/share/man/man[18]/*|sed 's|.*/\(.*\)..|\1|'|parallel apropos {}\|grep ^{}'\([18]\)'|sort -u
ls /usr/share/man/man7/ # miscellaneous documentation like ascii, environ, hier, and re_format
cat /etc/man.conf
man pcrepattern perlre pcresyntax
sudo /usr/libexec/makewhatis # update the whatis files used by whatis and apropos
MANPAGER=cat man man
man sticky # sticky bit
html2text # like `pandoc -f html -t markdown`
multimarkdown file.md -o file.html
mktemp -dt prefix # make a directory instead of a file and use $TMPDIR instead of /tmp
d=$(mktemp -dt prefix);trap "rm -r $t" exit
isutf # test if a file contains invalid UTF-8 byte sequences
netstat -rn|grep default # router IP address
netstat -ap tcp # list active internet connections
sudo ipfw pipe 1 config bw 15kbyte/s;sudo ipfw add 1 pipe 1 src-port 80 # limit bandwidth (undo with sudo ipfw delete 1)
dig example.com +nostats +nocomments +nocmd # DNS record
ifconfig # show information about all interfaces
ifconfig en1 # show information about en1
ifconfig en1|awk '$1=="ether"{print$2}' # print MAC address
sudo ifconfig en1 ether 00:e2:e3:e4:e5:e6 # spoof MAC address
ping -c8 google.com|tail -n1|cut -d/ -f5 # average of 8 pings
ping -i5 -c3 # interval 5 seconds, count 3
dig +short myip.opendns.com @resolver1.opendns.com # public IP
dig -x 74.125.45.100 # -x is reverse lookup
n=5;for i in $(seq $n);do dig @8.8.8.8 apple.com;done|awk '/Query time/{s+=$4}END{print s'/$n} # average duration of DNS queries
dig +trace # trace the delegation path
bc<<<'scale=3;1/3' # .333
bc<<<'ibase=16;FF' # 255
bc<<<'obase=16;255' # FF
bc<<<'obase=8;ibase=16;FF' # 377
bc -l<<<'sqrt(5)' # -l is --mathlib
bc -l<<<'e(l(16)*0.25)' # the exponent for ^ can't be fractional so 16^0.25 doesn't work
[[ $(bc<<<'12.5>7.5') = 1 ]]&&echo true # true
echo 12.5|awk '$0>7.5{print "true"}' # true
dc<<<'4 k 10 3 / p' # 3.3333 (4 k sets the precision, p prints the value of the top of the stack)
od -t x1 # type hexadecimal 1 byte
od -An -tuC # no input address radix, type unsigned char
od -An -N1 -tu1 /dev/random # random number between 1 and 256 (no input address radix, one byte, type unsigned one byte)
diff -u <(od -w1 -vAn -tx1 file1) <(od -w1 -vAn -tx1 file2) # show differing bytes in binary files
printf %s foo|openssl sha1|xxd -p -r|base64 - # Base64-encoded SHA1 hash of foo
printf %s pa55word|openssl enc -aes-256-cbc -pass stdin -in file.txt -out file.txt.enc
openssl enc -d -aes-256-cbc -in file.txt.enc -out file.txt # -a uses Base64
tar -c directory|openssl enc -aes-256-cbc -e>directory.tar.enc
openssl enc -aes-256-cbc -in new.tar.gz.enc -d|tar -xz
openssl rsa -in ~/.ssh/id_rsa -text # show the text of an RSA private key
openssl rand -hex 2 # [0-9a-f]{4}
openssl rand -base64 3 # [0-9A-Za-z+/]{4}
openssl rand -base64 2 # [0-9A-Za-z+/]{3}=
brew install haskell-platform;cabal update;cabal install pandoc
pandoc -f html -t markdown --no-wrap --atx-headers file.html -o file.md # an alternative to html2text
pandoc -f markdown_strict file.md -o file.html # markdown_strict acts like Markdown.pl
man pandoc_markdown
pandoc http://daringfireball.net/projects/markdown/index.text -o test.docx
pandoc file.md -s --toc -t html5 -o file.html # -s (standalone) adds headers and footers
pandoc -D html5 # print the default template
pandoc -f markdown_strict file.md --template template.html -c style.css -t html5 -o file.html
man parallel_tutorial
cat urls.txt|parallel -j10 wget
parallel -X -j1 # like `gxargs -I{}` or `tr \\n \\0|xargs -0 -I{}` but take multiple arguments at a time
find . -name \*.gz|parallel gzip -dc {}\>{.} # {.} is {} with \.[^.]*$ removed
f() { echo $1; };export -f f;seq 5|parallel f
parallel --retries 0 # don't retry failed jobs (the default is to retry once)
parallel convert {} {.}.png ::: *.svg # ::: is the argument separator
seq 6|paste - -|parallel -C $'\t' printf {2} # 246 (-C changes the column separator)
seq 6|parallel -N2 printf {2} # 246 (-N2 takes two arguments at a time)
parallel -k echo ::: a b ::: c d|tr \\n \; # a c;a d;b c;b d;
parallel -k --xapply echo ::: a b ::: c d|tr \\n \; # a c;b d; (--xapply gets one argument from each input source)
ls|parallel -N100 mkdir -p {#}\;mv {} {#} # -N100 takes 100 arguments at a time and {#} is sequence number
ls|parallel -N100 x=\$\(printf %03d {#}\)\;mkdir -p \$x\;mv {} \$x
cat urls.txt|parallel curl {} -o {#}-{/} # {/} is basename
find . -iname \*.zip -o -iname \*.rar|parallel -j-1 cd {//}\;unar {} # `cd {//}\;` is an alternative to -execdir
pdftk input.pdf dump_data_utf8
echo $'InfoKey: Title\nInfoValue: new title'|pdftk input.pdf update_info_utf8 - output output.pdf # change the title
pdftk input.pdf burst # save each page in a separate file
pdftk input.pdf cat 1-12 14-end output output.pdf # remove page 13
pdftk input.pdf output output.pdf uncompress # uncompress page streams for editing the text in a text editor
pdftk encrypted.pdf input_pw pa55w0rd output unencrypted.pdf
pdftk input.pdf owner_pw password output encrypted.pdf
pdftk 1.pdf 2.pdf cat output output.pdf
pdftk A=input.pdf cat Aodd output odd.pdf
pdftf even.pdf odd.pdf shuffle output output.pdf
brew install poppler;pdftotext input.pdf
brew install poppler;pdftohtml file.pdf
pdfimages -j file.pdf imagename # extract images from a PDF (pdfimages is part of poppler)
brew install poppler;pdffonts file.pdf # list embedded fonts
brew install poppler;pdfseparate input.pdf # like `pdftk input.pdf burst`
pdfnup --nup 2x1 --frame true --landscape --outfile twoup.pdf input.pdf
pdfinfo input.pdf
gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE -dQUIET -dBATCH -sOutputFile=compressed.pdf input.pdf
pdf2ps input.pdf input.ps;ps2pdf input.ps compressed.pdf
perl -i -pe 's/search/replace/g' *.txt
perl -ne 'print if(rand()<.05)' # print about 5% of lines
perl -MURI::Escape -ne 'print uri_escape($_.chomp)' # URL encode
perl -pe 's/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg' # URL encode
perl -MHTML::Entities -pe 'decode_entities($_)' # decode XML entities
perl -pie 'chomp if eof' file # remove a linefeed from the end of a file
PERLIO=:utf8 perl -pe '$_=uc' # convert non-ASCII characters to uppercase
perl -ne 'print if $.==3..5' # print lines 3 to 5
man perlrun # options
search=aa replace=bb perl -pe 's/\Q$ENV{search}/$ENV{replace}/' # \Q quotes the pattern
php -r 'echo strip_tags(file_get_contents("/dev/stdin"));'
port=4000;ip=$(ipconfig getifaddr en1);sleep 1;open http://$ip:$port;php -S $ip:$port
ps -p $(ps -p $$ -o ppid=) # parent process of the current process
ps -o lstart # the last time a process was started
ps -eo comm= # command names in the procps implementation and absolute paths of commands in OS X
ps -eco comm= # command names in OS X
sudo killall -SEGV process # force a process to crash
kill -0 1234 # check if pid 1234 exists
kill -- -1234 # kill by PGID
top -o cpu -s5 # order by CPU use and sleep 5 seconds between updates
top -l1 -n0 # logging mode, exit after one sample, zero processes (print only the lines at the top)
echo $'#!/bin/sh\npkill -xi "$@"'>~/bin/k;chmod +x ~/bin/k
pkill -P $(pgrep -x parentname) # -P is parent pid
sudo easy_install Pygments;pygmentize -f html -O full,style=emacs -o example.html example.rb # -f is formatter and -O is options
pygmentize -g -f rtf # guess input format and format as RTF
pygmentize -H formatter html # show help for the HTML formatter
python -c 'import sys;print ",".join(sys.argv[2:])' -- 1 2 # 1,2
python -ic 'from math import *' # -i enters interactive mode
recode latin1..utf8 *.txt
recode ..dump # show the Unicode code point and Unicode name of each character
recode ..html # encode HTML entities
recode html.. # decode HTML entities
recode ../cr-lf # LF to CRLF
recode /cr-lf.. # CRLF to LF
recode ../base64 # base 64 encode
recode /base64.. # base 64 decode
rename -n 's/\.md$/.txt/' * # remove -n to actually rename files
rename 's/.*ep(..).*/Example EP$1 720p HDTV x264.srt/' *.srt
rename '$_=$N.".jpg"' * # $N is an index starting from 1 (-N 005 would make $N start from 5 and be padded with three zeroes)
rename 's/([0-9]+)/sprintf("%02d",$1)/e' * # e evaluates the replacement string
rename 's/\b(.)/\u$1/g' * # titlecase based on word boundaries (\u converts the next character to uppercase)
rename 's/([\A\s])(.)/$1\u$2/g' * # titlecase based on whitespace
for f in *;do mv $f ${f,,};done # ,, converts all characters to lowercase in bash 4.0 and later
for f in *.jpg;do mv "$f" $((++i)).jpg;done # starts from 1 if i is unset
i=1;for f in *.pdf;do mv "$f" prefix-$(printf %03d $i).pdf;let i++;done # $(printf %03d $((i++))) doesn't work
i=1;for f in *;do mv "$f" $(printf %03d $i).${f#*.};let i++;done
IFS=$'\n';i=1;for f in $(ls -rt);do mv "$f" "$((i++)) $f";done
for f in *.mp3;do mv "$f" "$(printf %02d ${f%% *}) ${f#* }";done # 1 Track.mp3 to 01 Track.mp3
for f in *;do base=${f%.*};ext=${f#*.};mv $f ${base%-*}-$(printf %03d ${base#*-}).$ext;done # file-5.jpg to file-005.jpg
for f in !(*.*);do mv $f $f.txt;done
for f in !(*.zip);do mv $f $f.zip;done
for f in *;do echo mv "$f" "${f//[^a-zA-Z0-9.]}";done
i=0;for f in *;do d=dir_$(printf %03d $((i/100+1)));mkdir -p $d;mv "$f" $d;let i++;done
ls *.aac|parallel mv {} {.}.m4a
mv original.xml{*,} # rename for example original.xml.backup to original.xml
for f in *.srt;do f2=${f%.srt};x=(*${f2#*ep}*.mkv);mv "$f" "${x[0]%mkv}srt";done
ls *|sed -e 'p;s/search/replace/'|xargs -n2 mv
rsync -az --delete --exclude=.DS_Store ~/Sites/site/ user@host.com:public_html
rsync -r --size-only --compare-dest=dir3/ dir1/ dir2/ # copy files that don't have corresponding files in dir3
rsync -r dir1/ dir2;rm -r dir1 # an alternative to mv that merges subdirectories (--remove-source-files removes regular files but not directories)
rsync -R dir1/file dir2 # copy to dir2/dir1/file instead of dir2/file (like --parents in GNU cp)
rsync -r --exclude=\*.jpg dir /tmp
ruby -e'puts readlines.sort'
ruby -e'puts readlines.sort_by(&:length)'
ruby -e'puts readlines.uniq{|l|l.split[3]}'
ruby -pe'$_.sub! "\r\n","\n"'
ruby -e'puts gets(nil).gsub(/\r\n?/,"\n")'
ruby -ne 'print if ~/pattern/'
ruby -e'puts readlines.partition{|l|l=~/pattern/}' # print lines that match a pattern before other lines
ruby -i -e'print gets(nil).sub(/start.*end/m,"replace")' file # multiline in-place regex replace
ruby -rcgi -e'print CGI.escape ARGV[0]' 'H & M' # URL encode
ruby -pe'$_.gsub!(/[^A-Za-z0-9]/){"%%%02X"%$&.ord}' # URL encode
ruby -pe'$_.tr!"\u{3040}-\u{309f}","\u{30a0}-\u{30ff}"' # hiragana to katakana
ruby -rcgi -ne'puts CGI.unescapeHTML $_'
ruby -rcsv -e'puts CSV.parse($<).map{|l|l.join("\t")}' # CSV to TSV
ruby -rcsv -e'puts CSV.parse($<).uniq{|l|l[1]}.map(&:to_csv)'
ruby -F$'\t' -nae'p $F[2]' # -a (autosplit) assigns $F to $_.split
ruby -ne 'puts $1+" "+$2 if /^(.*?),.*?\(([0-9]*?)\)/'
ruby -e'puts $:' # load path
ruby -pe'$_.gsub!(/[\u{ff01}-\u{ff5e}]/){[$&.ord-"fee0".hex].pack("U")}' # full-width to half-width
ruby -e'puts Dir["*"].sort_by{|d|Dir["#{d}/**"].map{|f|File.mtime(f)}.max||Time.now}'
sudo gem install titlecase;ruby -rtitlecase -pe'$_.titlecase!'
ruby -e'puts STDIN.each_char.map{|c|"%x"%c.ord}' # print the Unicode code point of each character
ruby -pe'$_.gsub!(/\\u(....)/){[$1.hex].pack("U")}' # unescape \u escape sequences in JSON
curl -L raw.github.com/w3c/html/master/entities.json|ruby -rjson -e'JSON.parse(STDIN.read).each{|k,v|puts k[1..-2]+" "+v["characters"]}' # list of HTML named entities
ruby -rjson -ryaml -e'puts YAML.dump(JSON.parse(STDIN.read))'<file.json>file.yaml
ruby -ne 'puts $_.scan /[\u{4e00}-\u{9fff}]/'
for f in *;do ruby -i -e'puts $<.readlines.reverse' $f;done
sudo gem update --system # update rubygems and installed gems
gem list --local # list installed gems
irb --simple-prompt -r irb/completion # use >> as the primary prompt and enable tab completion for method names
ruby -rnatural_sort -e'puts NaturalSort.naturalsort(readlines)'
ruby -pe'$_.gsub!(/\d+\.\d+/){|x|"%.2f"%x}'
seq 2|ruby -e'p readlines.map(&:chomp)' # ["1", "2"]
sed 's/&/\&amp;/g;s/</\&lt;/g;s/>/\&gt;/g' # like `xml esc`
sed 's/\\/\\\\/g;s/"/\\"/g'
sed 's/<[^>]*>//g'
sed $'s,^,<tr><td>,;s,$,</td></tr>,;s,\t,</td><td>,g'
sed $'s,^<tr[^>]*><t[dh][^>]*>,,;s,</t[dh]></tr>$,,;s,</t[dh]><t[dh][^>]*>,\t,g'
sed 's|.*|<a href=&>&</a>|'
sed 's/../& /' # add a space after every two characters
LC_ALL=C sed 's/[^ -~]//g' # keep only printable ASCII characters
LC_ALL=C sed 's/[!-~]//g' # delete all printable ASCII characters except space
sed '$!s/$/<br>/' # add <br> to the end of all lines except the last line
sed -n 50,100p # like `awk NR==50,NR==100`
sed -n s/aa/bb/gp # show what lines would be changed by `sed s/aa/bb/g`
sed -n 's/.*href="\([^"]*\).*/\1/p'
gsed 's/\b./\u&/g' # titlecase
gsed 's/^./\l&/' # convert the first character of each line to lowercase
sed -n '/pattern/{n;p;}' # like `awk '/pattern/&&getline'`
sed '/pattern/{N;s/aa/bb/;}' # like `awk '/pattern/{print;getline;sub(/aa/,"bb")}1'`
sed '$s/....$//' # remove 4 characters from the end of the last line
sed p # duplicate each line
sed q # like `head -n1`
sed 3q # like `head -n3`
sed 1,4d # like `tail -n+5`
sed /pattern/q # like `awk '1;/pattern/{exit}'`
sed -n 's/aa/bb/gp' # show what lines would be changed by `sed 's/aa/bb/g'`
sed -i -e '$a\' *.txt # add a linefeed to the end of files that don't end with a linefeed
sed '1,/^$/d' # delete lines up to the first empty line
sed 'n;d' # like `awk NR%2` (n prints the pattern space and replaces the pattern space with the next line)
sed '/pattern/!d' # delete lines that don't match a pattern
sed =|paste - - # add line numbers
sed $'s/./&\\\n/g' # like `grep -o .`
printf '11\n33\n'|sed $'/11/a\\\n22\\\n' # or `sed /11/a22` with GNU sed
sed '1,/pattern/d' # delete up to the first line that matches a pattern
sed '/pattern/,$d' # delete lines after the first line that matches a pattern
sed '5,${/^$/d;}' # like `awk 'NR>4&&/./'`
sed y/XYZ/xyz/ # like `tr XYZ xyz`
sed '/pattern/{x;p;x;}' # insert an empty line above lines that match a pattern (x swaps the contents of the hold and pattern spaces)
sed '/pattern/G' # insert an empty line below lines that match a pattern (G appends a newline and the contents of the hold space to the pattern space)
sed '/pattern/{x;p;x;G;}' # insert an empty line above and below lines that match a pattern
gsed /pattern/,+3d # delete each line that matches a pattern and three lines after it
sed -n '/pattern/{n;n;n;d;};p' # delete each line that matches a pattern and three lines after it
sed -n '/pattern/{p;n;n;n;d;};p' # delete three lines after each line that matches a pattern
gsed 's/aa/bb/I' # case-insensitive
echo 12345678|sed 's/../&:/g;s/:$//' # 12:34:56:78
sed /pattern/wfile.txt # write lines that match a pattern to file.txt
sed -n l # like `cat -te`
sed 'N;s/^\(.*\).*\n\1.*$/\1/' # longest common prefix
sed '1{h;d;};G;s,\(.*\).*\n\1.*,\1,;h;$!d' # longest common prefix
sed '/pattern/N;s/\n//' # remove a newline after lines that match a pattern
sed -n '/^.\{255\}/!p' # remove lines that are 256 characters or longer
sed G # double-space a file (G appends a newline and the contents of the hold space to the pattern space, and the hold space is empty)
sed -e :1 -e 's/,[^,]*//3;t1' # like `cut -d, -f-3` (t branches to a label if there have been successful substitutions)
sed -n -e '/aa/{' -e 's/bb/cc/g' -e p -e '}' # a POSIX alternative to `sed -n '/aa/{s/bb/cc/g;p;}'`
sed -n '1h;1!H;${g;s/aa.*bb/cc/p;}' # multi-line search and replace (1h;1!H adds all lines to the hold space; 1,$H would add an empty line to the start)
sed 's/\(.\)\1\1*/\1\1/g' # replace two or more repeated characters with two characters
sed -i '' -e 1w/dev/stdout -e 1d file # delete and print the first line
sed -e :a -e 's/^\([^xz]*\)x/\1y/' -e ta # replace x with y up to the first z
gsed ':x;$!{N;s/\n  / /;bx;}' # replace `\n  ` with ` ` (use -e or newlines with other sed implementations)
sed 'p;s/aa/bb/'
sed '/./,$!d' # remove leading empty lines
sed 'N;$!P;$!D;$d' # delete last two lines ($!P;$!D prints and deletes the first line of the pattern space on all lines except the last line)
sed -e :1 -e 's/\(x.*\)y/\1/;t1' # remove all y after the first x
sed -n '90,100p;101q' # like `sed -n 90,100p` but don't read the whole file
sed -n '100q;d' # like `sed -n 100p` but don't read the whole file
seq -w -s, 9 11 # 09,10,11, (-w makes numbers the same width and -s changes the separator)
seq -f %04g 1 # 0001
seq -s, 999999 1000000 # 999999,1e+06, in OS X's seq and 999999,1000000, in GNU seq
seq -s, -f %.0f 999999 1000000 # 999999,1000000, in both OS X's seq and GNU seq (OS X's seq doesn't support %d or %i)
LC_CTYPE=C sort # sort by Unicode code points
sort -u file.txt -o file.txt # sort|uniq in place
sort -t$'\t' -k3,3 # sort TSV by the third column
sort -k2<<<'a b c' # the key is ` b c`
sort -k2,2<<<'a b c' # the key is ` b`
sort -bk2,2<<<'a b c' # the key is `b`
sort -t' ' -k3,3<<<'  a b' # the key is `a`
ls -d */*.jpg|sort -n -t/ -k1,1 -k2,2 # sort paths like dir11/11.jpg and dir2/2.jpg
sort -c file # check if a file is sorted
sort -m file1 file2 # merge (a faster alternative to `sort file1 file2` for files that are already sorted)
printf %s\\n 0 -0 +0 00 ''|sort -nu # 0
man ssh sshd ssh_config sshd_config
ssh-keygen -t rsa -N '' # -N is new passphrase and `-f ~/.ssh/id_rsa` is the default
ssh user@host 'cat>>.ssh/authorized_keys'<~/.ssh/id_rsa.pub
ssh user@host 'mkdir -p .ssh;cat>>.ssh/authorized_keys;chmod 700 .ssh;chmod 600 .ssh/authorized_keys'<~/.ssh/id_rsa.pub
ssh-copy-id user@host
ssh-copy-id -i .ssh/id_rsa.pub user@host
ssh-keygen -t rsa -N '' -f test;openssl asn1parse -in test # the private key is an ASN.1 data structure serialized with DER
ssh-keygen -f ~/.ssh/id_rsa -p # change passphrase
sshpass -p password ssh -o StrictHostKeyChecking=no user@host
ssh -i identity.pem user@host
scp file user@host:/some/dir
SHELL=zsh sudo -s
printf pa55word|sudo -S # get password from STDIN
sudo -u $USER -i # -i simulates initial login (it preserves $TERM and sets variables like $HOME)
su -l $USER # simulate login (requires entering a password)
sudo sudo -V # settings sudo was compiled with
tail -f *.log # `tail -f` can be used with multiple files
tail -q *.txt # don't print filename headers
tail -n+0 *.txt # cat files with filename headers
tput setaf 3 # foreground color 3 (yellow)
tput setab 4 # background color 4 (blue)
a=(black red green yellow blue purple cyan white);for c in ${!a[@]};do tput setaf $c;printf ${a[c]};done;tput sgr0
tput cols # an alternative to `echo $COLUMNS` that can be used in non-interactive shells
trap 'cols=$(tput cols) lines=$(tput lines)' WINCH
tput smso|sed -n l # \033[7m$
tput smcup;echo aa;sleep 2;tput rmcup # save and restore the terminal screen
TERM=xterm tput colors # 8
TERM=xterm-256color tput colors # 256
printf '\e[1mbold\e[m\n'
printf '\e[4munderline\e[m\n'
printf '\e[31mred\e[m\n'
for f in {30..37};do for b in {40..47};do printf "\e[${b}m\e[${f}m$f on $b\e[0m";done;echo;done
TERM=xterm tput cup 0 0|cat -v # ^[[1;1H (set cursor position)
printf '\e[2t';sleep 2;printf '\e[1t' # minimize and unminimize a window
printf '\e[5t' # raise a window above other terminal windows without changing keyboard focus
printf '\e[3;0;0t' # move a window to the top left corner
printf '\e[8;50;100t' # resize a window to 100x50 characters
printf '\e[9;1t' # maximize a window to fill a screen
printf '\e[9;2t' # maximize a window vertically
printf '\e]0;new window title\7'
TERM=rxvt tput kdch1|sed -n l # show what escape sequence rxvt sends for the forward delete key
clear;printf '\e[3J' # clear scrollback (you can use just `printf '\ec'` in some terminals)
sed 's/\eB\[[0-9;]*[mK]//g' # remove colors
echo text|sed $'s/./&\xcc\xb6/g' # strikethrough
TERM=xterm tput sgr0|sed -n l # \033(B\033[m$
tput vb # visual bell
echo $(tput smul)underline$(tput rmul) $(tput smso)standout$(tput rmso)
printf '\e[4munderline\e[24m \e[7mstandout\e[27m\n'
tput el1|cat -v # ^[[1K
infocmp -1|grep 1K # el1=\E[1K,
fold -s -w 70 # wrap lines only after spaces and set the width to 70 instead of 80
comm -13 <(sort 1.txt) <(sort 2.txt) # lines only in 2.txt (-1 doesn't print lines only in 1.txt and -3 doesn't print lines in both files)
paste column*.txt>tsv.txt
paste <(cut -f-3 tsv.txt) column4.txt <(cut -f5- tsv.txt)
paste -sd' ' - # replace all linefeeds except the last one with a space
paste -sd ';\n' # replace every other linefeed with a semicolon
paste -d '\0' # no delimiter (`-d ''` works in coreutils but not in OS X and POSIX specifies `-d '\0'` but not `-d ''`)
sed =|paste -sd ' \n' - - # add line numbers
sed =|lam - -s' ' - # add line numbers
lam - -s$'\t' - # like `paste - -`
lam -f 30 <(cut -f3 file.tsv) -s ' ' <(cut -f4 file.tsv) # like `awk -F\\t '{printf "%-30s %s\n",$3,$4}' file.tsv`
echo aaxbbx|lam -tx -sy - # yaaybb (-t changes the input terminator and -s changes the output separator)
join -a1 -a2 # print unpairable lines from both files
join -e EMPTY # replace missing input fields with EMPTY
grep -v '^#' /etc/passwd|column -s: -t # create a table (-t) using : as input separator
fmt -w 999999 # unfold
sed 's/^> //'|fmt -w 70|sed 's/^/> /'
fmt -d '' # don't double-space sentences
unexpand # replace eight spaces with tabs
nl # add line numbers
split -l 100 # save the first 100 lines as xx00, the next 100 lines as xx01, and so on
split -b 64k file.txt part_
split -p '^## ' file # like `csplit file '^## ' '{*}'`
csplit input.txt '/^---$/' # save the part before the first --- as xx00 and the part starting from the first --- as xx01
csplit input.txt '/^---$/' '{*}' # create a new file starting from each line that matches ^---$
csplit -f prefix_ -n 3 # -f is format and -n is maximum number
printf %s\\n 'S M' 'L XL' 'M L'|tsort|paste -sd, - # S,M,L,XL
tidy -i -wrap 0 -m file.html # indent, disable wrapping, and modify in place
tidy -xml -i -wrap 0 file.xml # like `xml fo file.xml`
tidy --show-errors 0 -q # remove error messages and the learn more message
touch -r file.txt timestamp;touch file;touch -r timestamp file;rm timestamp
tr -dc '\0-\177' # remove non-ASCII characters
LC_ALL=C tr -dc ' -~' # keep only printable ASCII characters
tr -s ' ' # collapse (squeeze) spaces
tr -s ' ' \\n # like `grep -Eo '[^ ]+'`
LC_ALL=C tr $'\xa0' ' ' # replace non-breaking spaces with normal spaces
LC_ALL=C tr -cs '[0-9A-Za-z]' _
tr -cs '[:alpha:]' '[\n*]' # a POSIX alternative to `grep -Eo '[[:alpha:]]+'`
tr '[:upper:]' '[:lower:]' # covert to lowercase (only applies to ASCII characters in coreutils tr)
tr $'[\u30a0-\u30ff]' $'[\u3040-\u309f]' # convert katakana to hiragana (doesn't work with coreutils tr)
tr $'\u3000\uff01-\uff5e' ' -~' # convert full-width to half-width (doesn't work with coreutils tr)
sort -f|uniq -ic|sort -f
mkvmerge -i input.mkv # --identify
mkvmerge -o output.mkv input.mkv -S # remove all subtitle tracks
mkvmerge -o output.mkv input.mkv -s 3,4 # remove subtitle tracks 3 and 4
mkvmerge -o output.mkv input.mkv subs.srt # add subtitle track
mkvextract tracks input.mkv 3:subs.srt # save track 3 as subs.srt
for f in *.mkv;do set $(mkvmerge -i "$f"|awk -F'[ :/)]' '/^Track ID [0-9]+: subtitles/{print$3,tolower($7);exit}');[[ $1 ]]&&mkvextract tracks "$f" "$1:${f%mkv}$2";done
MP4Box -ttxt subs.srt # srt to ttxt
VLC -I dummy file.flac vlc://quit # `-I dummy` uses a non-interactive CLI interface and vlc://quit quits after playing the file
VLC -I dummy 1.mxf --sout '#transcode{vcodec=mp2v,vb=3072,acodec=mp4a,ab=256}:standard{mux=ts,dst=1.ts,access=file}' vlc://quit
mplayer -vo dummy -ao dummy -identify input.mp4 # show information
HandBrakeCLI -i input.ts -o output.mp4 -e x264 -q 20 -B 160 # CRF 20 and audio bitrate 160
HandBrakeCLI --preset-list
watch wc file.txt
watch -t -n1 date +%T # -t doesn't display the title row and -n1 updates the display once per second
watch -d ls # highlight changed lines for 2 seconds (-d=--cumulative would keep all highlights indefinitely)
wget -l inf # change the recursion level for -r from 5 to infinite
wget -r -l3 # include resources on second level pages but not on third level pages
wget -r -l3 -p # also include resources on third level pages
wget -r -np # download files from a directory listing
wget --ignore-case -A .jpg,.jpeg # accepted extensions
wget -e robots=off # ignore robots.txt and don't download robots.txt files
wget --header 'Accept-Language: en'
wget -P /tmp # directory prefix (target directory)
wget -D media.tumblr.com # also includes subdomains like 25.media.tumblr.com
wget --limit-rate 200k
wget -t 1 # try downloading files once instead of 20 times
wget -T 30 # --dns-timeout, --connect-timeout, and --read-timeout combined (the only timeout set by default is a 900 second read timeout)
wget -Q 50m # stop downloading after a 50 MiB quota (there is no option like --max-filesize in curl)
wget -O output.txt -o log.txt
wget -O - # output to STDOUT
wget -i urls.txt -O concatenated-sources.txt
wget --save-cookies --keep-session-cookies # --save-cookies does not include session cookies by default
wget -A '*substring*,prefix*,suffix'
seq 10|parallel -P8 wget -nd -H -p --ignore-case -A .jpg,.jpeg,.png,.gif -e robots=off -t 1 --timeout 60 http://example.com/page/{}
wget -r -p -e robots=off --random-wait http://example.com
wget -r -l1 -H -t1 -nd -N -A mp3 -e robots=off -i mp3blogs.txt
wget -c http://example.com/file.tar # continue an unfinished download of ./file.tar (works with downloads started with curl)
wget --force-html -i file.html # parse file.html for URLs
wget --spider --force-html -i file.html # check if URLs in file.html are broken
wget -U mozilla # --user-agent
curl http://xmlstar.sourceforge.net/doc/xmlstarlet.txt
xml sel --help
xml sel -t -c //foo file.xml # print matched elements as XML (-t is template and -c is copy)
xml sel -t -v //foo # print the values of matched elements (-t is template and -v is value)
xml val file.xml # validate
xml ed -d //foo # delete foo elements
xml ed -d //@foo # delete foo attributes
xml ed -r //name1 -v name2 # rename name1 elements to name2
xml ed -d '//comment()' # remove comments
xxd -s 8192 -l 256 # skip 8192 bytes, length 256
youtube-dl https://www.youtube.com/watch?v=1234567
youtube-dl http://www.twitch.tv/username/b/1234567 -o ~/Downloads/'%(uploader)s %(title)s %(id)s.%(ext)s'
youtube-dl --list-extractors # list supported websites and other extractors
f() { echo "${@-$(cat)}"; };f a # a
f() { echo "${@-$(cat)}"; };echo a|f # a
read x y<<<'1 2 3';echo $y # 2 3
printf %.1s abc # a
printf %.2s abc # ab
printf %b '12\c34' # 12
printf %q $' "' # \ \"
printf %q $(printf \\a) # $'\a'
read firstline < <(printf 'a\nb\n');echo $firstline # a
unset TMPDIR;echo ${TMPDIR-/tmp/} # /tmp/
x=1234;echo ${x%??} # 12
echo "$(printf 'a\n\n')b" # ab
set aaa;echo ${#1} # 3
printf %08s 1f150 # 0001f150
printf '%04x %04x' 0x89abc 0x89a # 89abc 089a
printf %.0f 1.234e3 # 1234
x=axb;IFS=x;set $x;echo $1 # a
x=axb;IFS=x read v1 v2<<<"$x";echo $v1 # a
printf %.4s abcdef # abcd
LC_NUMERIC=en_US printf %\'d 1234567 # 1,234,567
LC_NUMERIC=C printf %\'d 1234567 # 1234567
echo ' 1  2 '|while read l;do echo "'$l'";done # '1  2'
echo ' 1  2 '|while IFS= read l;do echo "'$l'";done # ' 1  2 '
echo 0x780x790x7a|xxd -r # xyz
echo 78797a|xxd -r -p # xyz
printf \\\\x%s $(printf text|xxd -p -c1 -u) # \x74\x65\x78\x74
cd -P /etc;pwd # /private/etc
cd /etc;pwd -P # /private/etc
(set -P;cd /etc;pwd) # /private/etc
echo aa/bb/cc|grep -o '/bb.*' # /bb/cc
echo 12345|grep -Eo '.{3}$' # 345
printf '\1\t\x80\r\n'|sed -n l # \001\t\200\r$
printf '\1\t\x80\r\n'|cat -te # ^A^IM-^@^M$
seq 3|paste -sd, - # 1,2,3
echo $'bb\naa cc'|tr -s ' ' \\n|sort|paste -sd ' ' - # aa bb cc
seq 4|paste -sd ,\; - # 1,2;3,4
echo 123456|rev|cut -c3-|rev # 1234
echo 12345|awk '{printf "%02d:%02d:%02d",$1/3600,$1%3600/60,$1%60}' # 03:25:45
s=12345;printf %02d:%02d:%02d\\n $((s/3600)) $((s%3600/60)) $((s%60)) # 03:25:45
printf 1\n2|wc -l # 1
printf 1\n2|awk 1|wc -l # 2
printf 1\n2|awk 'END{print NR}' # 2
echo -n 12|tee /dev/tty|rev # 1221
printf a|base64 # YQ==
printf YQ==|base64 -D # a
printf a>a;printf bb>b;dd if=a of=b conv=notrunc;cat b # ab
x=aa:bb:cc:dd;echo ${x#*:*:} $(echo $x|cut -d: -f3-) # cc:dd cc:dd
printf 'aa\0bb\0cc\0dd\0'|while read -d '' x&&read -d '' y;do printf "$x,$y;";done # aa,bb;cc,dd;
true&&{ printf true;false; }||printf false # truefalse
true&&(printf true;false)||printf false # truefalse
if true;then printf true;false;else printf false;fi # true
echo aa{,,} # aa aa aa
echo $((0^1)) $((1^1)) # 1 0
echo 1 2|awk '$2*=10' # 1 20
printf %o \'a # 141
bc<<<'obase=16;C+F' # 1B
LC_CTYPE=C locale charmap # US-ASCII
LC_MONETARY=en_US.UTF-8 locale currency_symbol # $
f() { set $1;echo $2; };f 'aa bb cc' # bb
printf '\0\x80'|cat -v # ^@M-^@
echo "$(printf 'a\n\n\n\n')b" # ab (command substitutions remove all trailing linefeeds)
grep -q '[[:print:]]'<<<' ';echo $? # 0 (space is printable)
echo $(printf 'a\ba\n'|xxd -p) $(printf 'a\ba\n'|col -b|xxd -p) # 6108610a 610a (`col -b` removes backspaces)
printf '%.2f %.2f\n' 1.005 1.015 # 1.00 1.01
printf %s\\n A B a b|LC_ALL=en_US.UTF-8 sort|tr -d \\n # ABab in OS X and aAbB in Ubuntu (UTF-8 locales use ASCII collation order for ASCII characters in OS X)
echo aa,aaa|perl -pe 's/a+\K/"_".++$n/ge' # aa_1,aaa_2 (\K resets start of match and /e evaluates the replacement)
ksh -c 'x=1;function f { typeset x=2; };f;printf $x;f() { typeset x=2; };f;printf $x' # 12 (typeset makes variables local in functions defined using the function keyword)
ksh -c 'function f { printf $0; };f';ksh -c 'f() { printf $0; };f' # fksh ($0 is the function name in functions declared using the function keyword)
locale # list locale variables
locale -c LC_ALL # list categories
locale -k LC_ALL # list keywords
alias # list aliases
hash # show the hashed locations of commands and how many times commands have been run
hash wget # update the hashed location (also used as a portable way to test if a command exists on the path)
echo \*>file;IFS=$'\n';for l in $(<file);do echo "$l";done # lists files in the current directory (use `set -f` to disable filename expansion or use read)
printf '\n\na\n\na\n\n'>file;IFS=$'\n';for l in $(cat file);do echo "$l";done # empty lines are removed
[ -t 0 ] # test if stdin is opened on a terminal
[ -t 1 ] # test if stdout is opened on a terminal
printf 'Password: ';stty -echo;read password;stty echo # `stty -echo` disables showing typed characters
printf %4s # print 4 spaces
while IFS=: read -r user pass uid gid gecos home shell;do echo $uid;done</etc/passwd
readonly # list readonly variables
args=${@?No arguments supplied, exiting...}
set +H # disable history expansion
set +m # disable job control
set --;for x in "$@";do echo "$x";done # prints nothing ("$@" is removed when there are no positional parameters)
set --;for x in "$*";do echo "$x";done # prints an empty line ("$*" expands to an empty string when there are no positional parameters)
sh -c 'echo "$@"' aa bb cc # bb cc
sh -c 'echo "$0 $@"' aa bb cc # aa bb cc
set -a;x=1;sh -c 'echo $x' # 1 (-a marks all variables for export)
set -o ignoreeof # don't exit when pressing C-d
dd if=/dev/urandom count=4 2>/dev/null|openssl dgst -sha1
printf %$((COLUMNS/2))s
uuidgen # generate a UUID
echo 127.0.0.1 twitter.com|sudo tee -a /etc/hosts
IFS= read -rd '' x< <(tee /tmp/file) # redirect to a file and a variable
curl http://zsh.sourceforge.net/Doc/zsh_info.tar.gz|tar -xC /usr/local/share/info --strip 1 # download the zsh info page
look prefix # like `grep ^prefix /usr/share/dict/words`
look . # like `cat /usr/share/dict/words`
echo "$(printf %$((COLUMNS-5))s|tr ' ' -)$(date +%H:%M)"
[ $UID != 0 ]&&{ echo this script must be run as the superuser>&2;exit 1; }
mount # list mounted filesystems
mount -uw / # update the status of / to read-write (-u is update and -w is read-write)
npm install cssbeautify;cssbeautify file.css
man man2html|man2html -bare # -bare removes html and body tags
brew install smartmontools;smartctl -a disk0 # check SMART status
getconf ARG_MAX # show the maximum length for command line arguments
cal 12 2011
sudo apachectl configtest # check for errors in apache configuration files
cat /var/log/apache2/error_log
last reboot # see the dates of last reboots
ls -l /var/log/*.out # see when the periodic scripts were last run
leave +1 # print `Time to leave!` after one minute
leave 2359 # print `Time to leave!` at 11:59 PM
for((i=0x20;i<=0x7e;i++));do printf "\\$(printf %03o $i)\0";done|sort -z|tr -d \\0 # collation order of printable ASCII characters
[ $EUID = 0 ] # test if a script is run as root
x=*;y=~root;echo "$x" "$y" # * /var/root (pathname expansion is not performed in variable assignments but tilde expansion is)
break 2 # exit from the second enclosing loop
IFS=: p=($PATH)
declare -A tags=([f1]=file1 [f2]=file2)';printf 'f1 line 1\nf2 line 2\n|while read -r f l;do echo "$l">>${tags[$f]}.txt;done
mkdir a;ln -s a b;mv b/ c # moves a
EDITOR=nano sudo visudo # edit sudoers
chr() { [ $1 -gt 255 ]&&exit 1;printf \\$(($1/64*100+$1%64/8*10+$1%8)); }
for arg;do printf -v 'a[i++]' %q "$arg";done # `printf -v 'a[i++]'` is supported in bash 4.1 and later
start=$(date +%s) watch -t -n1 'elapsed=$(($(date +%s)-$start));sec=$((elapsed%3600));printf "%02d:%02d:%02d\n" $((elapsed/3600)) $((sec/60)) $((sec%60))'
start=$(date +%s);while sleep 1;do printf '\e[2K\r';date -ur $(($(date +%s)-$start)) +%T|tr -d \\n;done
mkfifo f;exec 3>f;echo a>&3;echo b>&3;exec 3>&- # exec 3>f assigns fd 3 to f and exec 3>&- closes the fd
echo $- # print the current option flags of the shell
[[ -L $f&&! -e $f ]] # test if $f is a broken symlink (-L tests if a file is a symlink and -e tests if the target of a symlink exists)
time cat # show elapsed time after pressing C-c
sudo shutdown -r now # restart
sudo shutdown -h 23:30 # shut down at 23:30
sudo shutdown -r +2 # restart in two minutes
sudo reboot # restart
awk 'NR==FNR{a[$0]++;next}{print a[$0],$0}' <(history|grep -Eo '\w+') <(compgen -c|sort -u)|sort -n
echo '<ul><li>aa</li></ul>'|lynx -force_html -stdin -dump -nolist # html to text
for d in */*;do echo "$(find "$d"|wc -l) $d";done|sort -n
for f in **/*.mp3;do >"$f";done # replace files with empty files
cat file2 >>file1;rm file2
for f in ~/dir/*.jpg;do printf %s "<a href=file://$f><img src=file://$f height=469></a>";done>/tmp/a.html;open /tmp/a.html
for d in *;do echo $(ls $d|wc -l) $d;done|sort -n
while :;do mod=$(curl -sI example.com|grep ^Last-Modified);[[ $last && $last != $mod ]]&&terminal-notifier -message '';last=$mod;done
while read l;do sum=${l%% *};[[ $prev = $sum ]]&&echo rm "$(cut -d' ' -f3-<<<"$l")";prev=$sum;done< <(find . -type f -exec cksum {} \+|sort -r)
stty tostop # stop a background job if it tries to print to the tty
stty icanon # non-blocking mode
(crontab -l;echo '* * * * * say a')|crontab -
expr "$var" : '\(.*\).' # remove the last character
=() { echo $(($*)); }
for d in */;do gfind "$d" -type f -printf '%s %P\n'|sort -n|sed \$d|cut -d' ' -f2-|xargs rm;done # keep only the largest file in each directory
sudo automount -c # flush cached information
history|cut -c8-|sort|uniq -c|sort|tail -n100
echo $TERM_PROGRAM # for example Apple_Terminal or iTerm.app
printf %s\\n /usr/share/man/man[18]/*|sed 's,.*/,,;s,..$,,'
while read prefix;do a=(@(dir1|dir2)/$prefix*);mv ${a[0]} dir3;done
brew install mecab mecab-ipadic;mecab -F '%t %f[6]\n' -U '' input.txt # print the type and lemma of each recognized token in Japanese text
while :;do wc=$(wc -l file);[ $wc != $prev ]&&printf \\a;prev=$wc;sleep 5;done
find ~/!(Library) -name .\* ! -name .DS_Store -maxdepth 3 # find files that start with a period
d=$(gdate -d "$(cat)" +%s)||d=0
javac Test.java&&java Test.class # compile and run a Java file
cat domains.txt|while read l;do echo "$l $(whois $l|sed -n 's/.*Expiration Date://p')";done
cmp -l file1 file2|wc -l # number of bytes that binary files differ by
file /dev/* # most files in /dev are character special or block special
IFS=' -:' read y m d h min s<<<'2014-03-26 16:55:45'
f=${TMPDIR}lastrun;d=$(date +%s);[ -e $f ]&&echo $((d-$(cat $f)));echo $d>$f
while read l;do [[ ${l%% *} = @(tag1|tag2) ]]&&echo "${l#* }">>${l%% *}.txt||echo "$l";done<notes.txt
export BLOCKSIZE=1k # make df and du use 1 kiB blocks
libreoffice -invisible 'macro:///Standard.Module1.ConvertWordToPDF(file.doc)' # DOC to PDF
find . -type d|while IFS= read -r l;do a=($l/*);printf %s\\n "${#a[@]} $l";done|sort -rn|head -n50
printf '\n%s\n' "$(pbpaste)">>~/notes/copied
ls -d $PWD/*.jpg|sed 's/.*/&<br><img src=&><br>/'
echo $SECONDS # number of seconds since the shell was invoked
tail -f file|awk '{print strftime("%T"),$0}'
curl -s rosettacode.org/wiki/Category:JavaScript|awk '/mw-pages/,/printfooter/'|sed -n 's,.*\(/wiki/[^"]*\).*,http://rosettacode.org\1#JavaScript,p'
find . -user root -exec sudo chown $USER:wheel {} +
man man2html|man2html
grep -Eo '\S+'|sort|paste -sd' ' - # sort words
info findutils|less # read an info page using less
tput rmam # disable wrapping lines (undo with `tput smam`)
for d in dir1/*;do d2=dir2/${d#*/};mkdir -p $d2;mv $d/ $d2;done;rm -r dir1
man dup2 # duplicating file descriptors
columns # align the input lines in horizontal columns (part of autogen)
play -n synth sine 60 # play a 60 Hz sine wave
gfind -type f -printf %TF\\n|sort -n|uniq -c # number of files modified per each day (%TF is mtime in the %F format)
s3cmd sync --dry-run --exclude .DS_Store ~/Sites/site/ s3://bucket-name # sync files to S3 (create ~/.s3cfg with `s3cmd --configure` first)
d=/tmp/sshfs;sshfs user@host:/dir $d;rsync -a ~/Sites/site/ $v;unmount $v;rm -rf $f # rsync files to a host that doesn't provide SSH access (add a public key to .ssh/authorized_keys on the host)
watch() { while :;do clear;"$@";sleep 5;done; }
abspath() { f=$1;[ -d "$f" ]&&f="$f/";abs=$(cd "${f%/*}";printf %s "$PWD");printf %s\\n "$abs/${f##*/}"; }
LC_CTYPE=${LC_ALL:-${LC_CTYPE:-$LANG}}
curl http://wordnetcode.princeton.edu/wn3.1.dict.tar.gz|tar -x;grep -hv '^ ' dict/index.{adj,adv,noun,verb}|cut -d' ' -f1|grep '^[a-z]*$'>wordlist
traceroute -w5 -q3 -m30 # wait 5 seconds (default), send 3 queries to each hop (default), 30 maximum hops (default)
printf "\e[7m%-$(tput cols)s\e[0m\n" 'Full width reverse video line'
awk 'NR==FNR{a[$0];next}!($0 in a)' <(awk '++a[$0]==11' file) file # print lines that don't appear 11 or more times
gfind . -printf %s\\n|awk '{++a[int($0/1000)*1000]}END{for(i in a)print i,a[i]}'|sort -n|gnuplot -e 'set style fill solid;plot"-"w boxes' # distribution of file sizes
for f in *.gz;do gzip -dc $f|bzip2>${f%gz}bz2;done
cp file{,-$(date +%F)}
ffmpeg -i input.mp4 -c:v libx265 -pix_fmt yuv420p -x265-params crf=28 -preset:v slow -c:a libfdk_aac -vbr 4 output.mp4 # encode X265
awk '$0>1000{$0=1000}1' # replace numbers over 1000 with 1000
rev|tac # reverse characters and lines
cmd&disown # keep a command running after the terminal is closed
nohup cmd>/dev/null # keep a command running after the terminal is closed (the output is saved to ./nohup.out if STDOUT is not redirected)
exec 3>/tmp/a # open /tmp/a for writing on fd 3
exec 3</tmp/a # open /tmp/a for reading on fd 3
exec 0>&- # close STDIN
exec 1>&- # close STDOUT
exec 4>&3- # copy fd 3 to fd 4 and close fd 3
renice +10 $(pgrep processname) # decrease priority (-20 is highest priority and +20 is lowest priority)
otfinfo --info *.otf *.ttf # show information about fonts (part of lcdf-typetools)
trap '' INT # ignore SIGINT
trap : INT # set a signal handler that does nothing for SIGINT
trap '' 1 2 3 15 # ignore HUP, INT, QUIT, and TERM
trap # print current traps
trap 1 # remove traps for HUP (same as `trap - HUP`)
f() { touch /tmp/a; };trap f DEBUG # run a function before every command
tty # print the terminal name
id # show the user name and user id and group names and group IDs of the current user
groups # show the groups of the current user (equivalent to `id -Gn`)
times # print the user and system times used by the shell and its children
while IFS= read -d '' -n1 -r c;do printf '%s %x\n' "$c" "'$c";done # print the Unicode code point of each character
iostat # show kiB per transfer, number of transfers, and MiB/s for each disk followed by CPU use and load averages
sudo vifs # edit /etc/fstab in $EDITOR or vi
logger message # add a message to system.log
units miles km # show multiplication factors
eval "$(fc -ln -5)" # rerun the last 5 commands (-l lists commands and -n omits line numbers)
facedetect -q file.jpg;echo $? # guess if an image contains a face
br -algorithm FaceRecognition -enrollAll -enroll ~/photos/ output.csv # find face coordinates in photos
while getopts :a:b: opt;do case $opt in a)arga=$OPTARG;;b)argb=$OPTARG;;:)echo "missing argument for option -$OPTARG";exit 1;;\?)echo "unknown option -$OPTARG";exit 1;;esac;done;shift $((OPTIND-1))
awk -v RS= -F\\n '{for(i=NF-4;i<=NF;i++)print$i}' # print the last five lines of each section delimited by two or more linefeeds
sort -sk1,1|awk '$1!=prev{print"\n#"$1}{print substr($0,length($1)+2);prev=$1}' # group lines with the same first field under headings
awk '{if(length<80)print;else a[NR]=$0}END{for(i in a)print a[i]}'
awk 'NR==FNR{++a[$2];next}a[$2]==1' file{,} # print lines whose second field only appears once in the file
awk '/pattern/&&++i==3{getline;print;exit}' # print the line after the third matching line for a pattern
awk '/^$/{if(++n<=2)print;next}{n=0}1' # replace three or more consecutive empty lines with two empty lines
sort -n|awk '{a[NR]=$0}END{if(NR%2==1)print a[int(NR/2)+1];else print (a[NR/2-1]+a[NR/2])/2}' # median
awk '!a[$0]||a[$0]<NR-101;{a[$0]=NR}' # remove lines that appeared before within the previous 100 lines
awk -v size=5 '{mod=NR%size;if(NR<=size){count++}else{sum-=a[mod]};sum+=$1;a[mod]=$1;print sum/count}' # moving average
awk '$1 in a&&!($2 in a[$1]);{a[$1][$2]}' # print lines where the first field has appeared before but not with the same second field
awk '{if($0>max)max=$0;if($0<min)min=$0;a[NR]=$0}END{for(i in a)printf "%f\n",(a[i]-min)/(max-min)}' # scale a list of numbers between 0.0 and 1.0
awk '{for(i=NR-1;i>=NR-5;i--){if($2==a[i]){print;next}}a[NR]=$2}' # print lines whose second field was the second field of one of the five previous lines
awk '{print$2>>ENVIRON["HOME"]"/dir/"$1".txt"}'
curl http://www.unicode.org/Public/UCD/latest/ucd/Blocks.txt # look up the names and character ranges of Unicode blocks
file *.jpg|grep PNG # find files with a .jpg extension that are actually PNG files
tee /dev/stdout # print lines in the middle of a pipeline
ghead -n-1000 file|sponge file # remove the last 1000 lines
echo a>/dev/ttys002 # display text in another terminal
ffmpeg -ss 0:12:34 -t 5 -i input.mp4 -f image2 /tmp/%04d.png;convert -delay 3 -fuzz 1.5% -layers optimize /tmp/*.png output.gif
time while ps -p 1234 >/dev/null;do sleep 1;done
pr -t -w $(tput cols) -4 # print lines in four columns (-t disables printing header and footer lines and doesn't add empty lines to the end)
d=2014-12-01;while [[ ! $d > 2015-02-28 ]];do echo $d;d=$(gdate -d "$d+1 day" +%F);done # print a range of dates
ps -t ttys000 # show processes running in the terminal ttys000
xml sel -t -m /aa/bb -v child1 -o , -v child2 -n # print child1 and child2 subelements of /aa/bb separated by commas (-n prints a newline)
xml sel -t -v '//li[@id="someid"]/a/@href'
xml ed -u //xx -v newvalue # set the value of xx elements to newvalue (-u is update)
xml ed --inplace -u //xx -v newvalue file.xml
xml ed -u '//xx[@value="yes"]/@value' -v no
curl "$url" -HContent-Type:application/json -d@data.json # post a JSON file
node # JavaScript REPL
if [ $# = 0 ];then set -f;IFS=$'\n' set -- $(cat);fi # set the arguments to lines from STDIN if there are no arguments
a2p # translate awk to perl
toe # list terminal types and descriptions from the terminfo database
awk '{if(!/^ /){if(NR!=1)print"";print"#"$0}else{print(substr($0,3))}}' # convert an outline where heading lines are unindented and other lines are indented by two spaces to an unindented format where heading lines start with a hash character
printf %s\\n /usr/{s,}bin/*|sed 's,.*/,,'|while read l;do apropos "$l"|grep "^$l([18]) ";done|grep -v 'nothing appropriate'
curl -s 'https://en.wikipedia.org/w/api.php?action=query&prop=revisions&rvprop=content&format=json&titles=Example'|jq -r '.query.pages[].revisions[]."*"' # get the WikiText source of a Wikipedia article
curl -s 'https://en.wikipedia.org/wiki/Example?action=render'|pandoc -f html -t markdown_strict --no-wrap --atx-headers # convert a Wikipedia article to plain text (action=render removes all parts of the layout except the article)
tr A-Z a-z|grep -Eo '[a-z]+'|awk 'NR==FNR{a[$0];next}!($0 in a)' <(look .|awk 'NR==FNR{a[$0];next}{for(i in a)print$0 i}' <(printf %s\\n '' d ed s es ing) -) - # find words that are not included in a dictionary
gsed 's/\([.?!]\) /\1\n/g' # reformat text so that each sentence is displayed on a different line
grep '[^ -~]' * # find files that include non-ASCII characters or non-printable ASCII characters
tr -d \\0-\\177|recode ..dump # find non-ASCII characters and show their code points and Unicode names
smartypants|recode html # convert straight quotes to smart quotes
awk '{if((NR==1||!x)&&/./)$0="  "$0;x=/./}1' # indent the first line in each paragraph
awk '{if(x&&/./)$0="  "$0;x=/./}1' # indent all lines except the first line in each paragraph
printf %04x\\n $(seq $((0x3040)) $((0x309F)))|while read l;do printf "$l \U$l\n";done # print a range of Unicode characters  
gfind dir1 -mindepth 1 -maxdepth 1 -printf '%TY%Tm%Td%TH%TM%TS %f\n'|while read x y;do touch -t ${x%.*} dir2/$y;done # set the modification times of files in dir2 to the modification times of files with the same name in dir1
gfind -printf '%p %f %Ts %z\n' # print path, basename, mtime as seconds since epoch, and size in bytes
gstat -c'%n %Y %s' * # print path, mtime as seconds since epoch, and size in bytes
lynx -dump https://www.youtube.com/user/username/videos|grep -o 'http.*watch.*'|awk '!a[$0]++'|vlc - # create a VLC playlist for videos uploaded by a user
curl -sG --data-urlencode search_query=query https://www.youtube.com/results|grep -o 'href="/watch[^"]*'|cut -d\" -f2|awk '!a[$0]++'|sed s,^,http://youtube.com,|vlc - # create a VLC playlist for the first search results
cat input.md|curl -s https://api.github.com/markdown/raw -HContent-Type:text/plain -d@- # convert GitHub Flavored Markdown to HTML
gdate +%s%3N # milliseconds since epoch
nice bash -ic somefunction # use nice to run a function defined in ~/.bashrc
perl -ne'$x+=$_}{print"$x\n"' # sum
colrm 3 5 # like `cut -c1-2,6-`
od -a # replace control characters with character names
od -c # replace control characters with C-style escape sequences
gls -p # append a slash to directories
xargs ls -d 2>/dev/null # filter a list of paths to remove paths that don't exist
awk '{print gsub("pattern","&")}' # print the number of matches for a pattern
awk -v RS= '{if(gsub(/xx/,"&")==1)print}'|grep xx # print lines that contain xx in paragraphs that contain xx once
[ -c /dev/null -a -b /dev/disk0 ];echo $? # 0 (/dev/null is character special and /dev/disk0 is block special)
a0() { gawk -e 'FILENAME==ARGV[1]{a[$0];next}' -e "$@"; };a0 '$1 in a' <(echo aa) <(printf %s\\n 'aa 1' 'bb 2') # aa 1
awk 'BEGIN{x="a\na\n";gsub("^","b",x);printf x}'|xxd -p # 62610a610a (^ matches start of string instead of start of line)
find -regex-type posix-extended # use ERE with GNU find (GNU find uses Emacs regular expressions by default)
find -E # use ERE with BSD find (BSD find uses POSIX BRE by default)
gzip -c # output to stdout and don't remove the original files
gzip -k # keep the original files (GNU, new OS X gzip, and new FreeBSD gzip)
gzip -9 # higher compression ratio, slower compression speed, same decompression speed
zip -0 # disable compression
unzip -o # overwrite existing files
unzip -j # extract all files to the same directory instead of creating subdirectories (junk paths)
at -b # same as batch
lame -V2 # same as `--preset standard` (usually about 160-260 kb/s for stereo music)
lame -h # same as -q2 which is the default for VBR and recommended by the man page
gawk -c # use BWK awk compatibility mode (BWK awk or nawk is the awk that comes with OS X and BSDs)
gawk -P # use POSIX mode (implies -c and causes a few other changes)
cat -t # same as -v but show tabs as ^I
cat -e # same as -v but show $ at the end of each line
gcat -A # same as `cat -te`
cat -s # squeeze adjacent empty lines
cat -n # add line numbers
cat -u # disable output buffering in BSD (ignored in coreutils)
shuf -r # allow repetitions
readlink -f # resolve symlinks recursively and convert relative paths to absolute paths
cp -p # same as --preserve=mode,ownership,timestamps in coreutils but also preserve extended attributes, ACLs, resource forks, and file flags in OS X
cp -a # equivalent to -pRP in OS X and coreutils but not specified by POSIX
cp -RP # don't follow symlinks (default)
cp -RL # follow symlinks
cp -n # don't overwrite existing files
cp -r # equivalent to -R in coreutils but like `gcp -RL --copy-contents` in OS X
gcp -T # exit if the target directory exists instead of copying files inside it (--no-target-directory)
curl -I # download only headers
curl -i # include headers
curl -O # download files to the current directory
curl -J # make -O use filenames specified in Content-Disposition headers (like `wget --content-disposition`)
curl -R # preserve timestamps (--remote-time)
curl -g # disable globbing (don't interpret characters like angle brackets in URLs)
curl --compressed # decompress gzipped responses
curl -k # turn off SSL certificate verification (--insecure)
cut -s # suppress printing lines with no delimiter character
date -u # same as `TZ=UTC0 date` (-u is the only option for date specified by POSIX)
gdate --rfc-3339=seconds # use a format like `2014-03-31 17:40:03+03:00` (`%F %T%:z`)
gdate -R # use a format like `Mon, 31 Mar 2014 17:40:03 +0300` (`%a, %d %b %Y %T %z`)
diff -b # ignore blanks
diff -B # ignore blank lines
diff -u # output 3 lines of unified context
du -c # show total size at the bottom
du -s # print specified files (same as -d0)
du -x # don't traverse file system mount points
gdu --apparent-size # print apparent sizes instead of disk usage
gdu -b # bytes (same as --apparent-size --block-size=1)
exiftool -overwrite_original # modify files in place
exiftool -S # very short output format (same as -s2)
exiftool -s3 # print only values (same as `-s -S`)
exiftool -T # TSV output
fdupes -1 # print each group of duplicate files on a single line separated by spaces
ffmpeg -y # overwrite existing files
ffmpeg -n # exit if an output file exists
ffmpeg -an # no audio
ffmpeg -formats # list supported formats
ffmpeg -codecs # list supported media bitstream formats
ffmpeg -encoders # list encoders
find -d # use depth-first traversal or visit directories in post-order (same as -depth)
find -L # follow symlinks
grep -h # don't print filenames
grep -l # print only filenames
grep -H # always print filename headers
grep -a # search in binary files (same as --binary-files=text in GNU find)
grep -L # print the names of non-matching files
grep --null # use null as the output delimiter (-Z in coreutils but not in OS X)
ggrep -z # use null input delimiter (`grep -z` is equivalent to zgrep in OS X)
grep -P # PCRE (removed in OS X 10.8)
grep -R # equivalent to -r in OS X but follows symlinks in coreutils
hexdump -C # canonical (input offset, 16 space-separated bytes in two columns, %_p)
hexdump -v # don't replace repeated lines with an asterisk
iconv -l # list encodings
iconv -c # discard characters that cannot be converted instead of exiting with an error
convert -trim # crop transparent or solid color areas on each side of an image
convert -flatten # replace a transparent background with a white background
convert -strip # remove color profiles, comments, and EXIF metadata
jhead -purejpg # -de -dc -du (delete EXIF metadata, comments, and other metadata)
jot -c # same as `jot -w %c`
rs -t # transpose (fill rows before columns)
rs -j # justify to right instead of left
rs -g4 # 4 instead of 2 spaces of gutter between columns
jq -r # use a raw output format instead of printing the output as json
less -RX # use raw escape sequences and don't clear the screen after quitting less
ln -f # replace the target file if it exists (also replaces regular files but not directories)
ln -sF # like -f but also replaces directories (no-op without -s)
locate -i # ignore case
locate -c # count matching files
locate -l2 # show at most two results
locate -S # print statistics about the database and exit
ls -A # show all entries except . and ..
ls -S # sort by size
ls -d # list directories instead of their contents and print paths including parent folders
ls -lh # use human-readable file sizes
ls -lT # print date with year and time with seconds
ls -n # numeric uid and gid
ls -i # show inode numbers
ls -b # use C escape sequences for nonprinting characters
gls -v # use natural sorting for numbers and version numbers
gls -X # sort by filename extension
lsof -i # internet files
man -k # equivalent to apropos
man -f # equivalent to whatis
od -x # equivalent to -h and `-t x2`
od -X # equivalent to -H and `-t x4`
od -v # don't replace duplicated lines with *
od -ta # type ASCII (show characters literally and use names like NUL for ASCII control characters)
od -tx1 # set the output type to single byte in hexadecimal
od -c # C-style escaped characters (like \n), also displays the parts of decomposed characters separately
od -Ax # hexadecimal input address radix
od -w1 # output one byte per line in GNU od
parallel -j10 # run ten jobs in parallel (same as `parallel -P10`)
parallel -j-1 # run one fewer than the number of cores jobs in parallel
parallel -k # keep order for output
parallel -X # take multiple arguments at a time (like xargs)
parallel -q # quote space, single quotes, double quotes, and dollar signs
parallel -n4 # take 4 arguments at a time
parallel -N4 # take 4 arguments at a time and make replacement strings like {1} and {2} available
parallel -0 # same as `parallel -d \\0`
parallel --xapply # cycle through input sources for each new argument
ps -e # include all processes
ps -f # include UID, PPID, CPU use, and start time (full format)
ps -j # include username, PPID, PGID, session ID, job control count, and state (job control)
ps -r # sort by CPU use
ps -emv # sort by memory use and include a column for memory use
kill -l # list signal numbers and names (same as `trap -l`)
top -u # equivalent to `top -o cpu -O time` (sort by CPU use and then CPU time)
pgrep -l # print process names in addition to PIDs
pkill -f # match the full command line
pgrep -fl # match and print the full command line
pgrep -u # username
pgrep -U # UID
pgrep -P # ppid
pkill -xi # case-insensitive killall (-x is like `grep -Fx`)
pkill -n # kill only the newest process
pkill -a # include ancestors in OS X (the procps pkill includes ancestors by default)
pygmentize -L # list lexers, formatters, filters, and styles
recode -l # list encodings
rsync -a # -rlptgoD (--recursive --links --perms --times --group --owner --devices --specials)
rsync -c # compare checksums (slower than the default behavior of comparing modification times and sizes)
rsync --delete # delete extra files in destination
rsync -b # --backup (add a tilde to the end of the filename for files that would normally get overwritten)
irb -m # bc mode (implies --noinspect)
ri -T # no pager (output to terminal)
gsed -s # treat files as separate
gsed -u # unbuffered
gsed -z # null input delimiter
sort -b # don't include blanks at the start of fields
sort -sk1,1 # sort by the first field and keep the original order within groups of lines with the same first field
sort -usk2,2 # uniq by second column
sort -k2.3 # sort starting from the third character of the second column
gsort -h # sort human-readable file sizes
gsort -C # --check=quiet
sort -d # dictionary order (consider only alphanumeric characters and blanks)
sort -cu # check if there is at least one non-unique line
gsort -R # an alternative to shuf (identical lines are sorted together)
gsort --debug # highlight the part of each line used as the sort key
gsort -z # null-terminated
scp -p # preserve mode, mtime, and atime
su - # same as `su - root` or `su -l root` (the root user has to be enabled in OS X)
sudo -s # start a shell with superuser privileges
sudo -v # validate the timestamp (for 5 minutes in OS X and for 15 minutes in Ubuntu)
sudo -k # kill (invalidate the timestamp)
sudo -n # non-interactive (exit with an error instead of asking for a password if authentication is required)
sudo -l # list the allowed and forbidden commands for the current user
tail -fn+0 # print the whole file at the start
tail -c+4 # remove the first 3 characters
ghead -c-3 # remove the last 3 characters
infocmp -1 # list terminfo entries for TERM (-1 prints one entry per line)
infocmp -L # use long variable names
wc -l<file # don't print the filename
gwc -L # length of the longest line
paste -s # replace all linefeeds except the last one with a tab
join -t, # input and output field separator
fmt -1 # print each word on a separate line (keeps spaces at the start of lines)
expand -t4 # replace tabs with four spaces
rs -T # transpose a matrix
tidy -help-config # see `tidy -show-config` for current config
touch -t # change access and modification time
touch -m # change modification time
touch -a # change access time
uniq -u # print only unique lines
uniq -d # print only duplicated lines
uniq -f2 # ignore the first two fields
wget -m # same as `wget -r -N -l inf --no-remove-listing`
wget -N # don't redownload files that have not been modified
wget --no-remove-listing # don't remove .listing files generated by FTP retrievals
wget -p # page requisites (include resources like images and stylesheets)
wget -np # no parent (don't follow links to parent directories)
wget -nd # no directories (download all files to the same directory without creating subdirectories)
wget -nH # --no-host-directories (don't create a directory like www.example.com)
wget -H # span hosts (files on different domains or subdomains are not downloaded by default)
wget --content-disposition # use filenames specified in Content-Disposition headers
wget -e robots=off # ignore robots.txt
wget --no-check-certificate # don't verify SSL certificates or reject downloads with invalid certificates
wget -w5 # wait 5 seconds between retrievals
wget --random-wait # wait between 0.5 and 1.5 times -w seconds
wget --waitretry # retry failed retrievals after increasing intervals
wget -nv # no verbose (less verbose than -v which is the default)
wget -E # add .html extensions
wget -S # print HTTP headers (like `curl -I`)
wget --no-use-server-timestamps # use the current time instead of preserving timestamps
wget --restrict-file-names=windows # percent-encode [\|/:?"*<>\0-\37\200-\237]
wget --restrict-file-names=nocontrol # don't escape non-ASCII characters whose UTF-8 byte sequences contain [\0-\37\200-\237]
wget --no-use-server-timestamps # don't preserve timestamps
gxargs -d\\n # use linefeed as input separator and disable interpreting quotes and backslashes
gxargs -r # don't run the command if the input doesn't contain any nonblank lines (the default in OS X's xargs which doesn't have -r)
xxd -c1 # one byte per line
youtube-dl -x # extract audio
youtube-dl --write-sub # include subtitles
xxd -p<<<$'a\n' # 610a0a
locale -m # list charmaps (or codesets in OS X)
command -v # a POSIX alternative to which
hash -r # reset all hashed locations
jobs -l # include pids
jobs -p # list only pids
stat -x # a multi-line alternative to `ls -l`
fsck -f # force checking clean filesystems in preening mode
fsck -y # answer yes to all questions
tree -d # include only directories
tree --du # include file sizes
strings -a # include all sections
lsof -t # print only PIDs (terse)
lsof -nP # don't convert network numbers to host names and don't convert port numbers to port names
pcregrep -M # multi-line
ssh -n # like `</dev/null ssh`
agrep -2 # find matches with at most two errors
agrep -B # find the best match for the pattern
df -P # use the POSIX format (default in OS X)
gcc -ansi # ANSI C (same as -std=c90)
gcc -std=gnu90 # C90 with GNU extensions (default)
gcc -std=c11 # C11 (ISO/IEC 9899:2011)
gcc -pedantic # issue all warnings required by ISO C and reject programs that use forbidden extensions
gcc -Wall # enable more warnings (some are only enabled by -Wextra or by individual options)
srm -s # overwrite files with a single pass of random data (simple)
mkdir -m 700 # change mode to 700
sshfs -o debug,sshfs_debug,loglevel=debug # include debugging information
dirs -l # don't replace $HOME with ~
umask -S # print the umask of the shell process (usually u=rwx,g=rx,o=rx)
env -i # ignore the environment
wget -P # target directory
gcp -t # target directory
gmv -t # target directory
wget -U # user agent
curl -A # user agent
curl -o # output file
curl -e # referer
curl -H # header
parallel -C # column separator
set -- # unset all positional parameters
set -eu # same as `set -o errexit -o nounset` (exit when trying to substitute an unset variable)
set -f # disable filename expansion
set -b # print messages about finished background jobs immediately and not before displaying the next prompt
unalias -a # remove all alias definitions
id -u # a POSIX alternative to `echo $UID`
uname -srm # print the system name, release, machine name
fc -s # run the previous command again
exec -c # clear the environment
dirs -c # clear the directory stack
tail -c+6 # remove the first 5 characters
sort -sk1,1 # sort lines by first field and keep original order within groups of lines with the same first field
stty -a # display all current settings
column -t # create a monospace table
rev|cut -c-5|rev # print the last 5 characters

#bash
curl http://git.savannah.gnu.org/cgit/bash.git/plain/CHANGES
complete # list completion specifications
complete -o filenames # escape characters like spaces and quotes
echo ${BASH_VERSINFO[@]} # major version, minor version, patch level, build version, release status, and MACHTYPE
bash --noprofile # don't read /etc/profile, .bash_profile, .bash_login, or .profile
[[ $- = *i* || :$BASHOPTS: = *:login_shell:* ]]
bind -p # list functions and keybindings
bind -v # list variables
bind -s # list key sequences (empty by default)
disown -a # remove all jobs
disown -h # don't send SIGHUP on exit and don't remove the job from the process table
env SHELLOPTS=xtrace bash # like `bash -x` but also applies to for example running bash again inside the shell
HISTFILE= # don't save history from the current session
history -p '!!' # print the last history entry
type x # show the definition of a function or an alias
declare -p x # show the definition of a variable (or an array)
!!:p # like `echo "!!"` or `history -p '!!'`
mv file.txt.backup !#:$:r # !#:$:r is the last word of the current line without an extension
caller # return the context of the current subroutine call
f() { [[ $COMP_LINE || $BASH_COMMAND = $PROMPT_COMMAND]]&&return;echo a; };trap f DEBUG # don't run f when completing a line or when running PROMPT_COMMAND
jobs -p # print only PIDs
shopt -s extglob;rm -r !(prefix*)/ # folders that don't start with prefix
rm !(*.txt) # paths that don't end with .txt
rm *.!(txt) # paths that contain . and don't end with txt
rm *!(.txt) # same as *
echo !(!(*foo*)|*bar*) # filenames that contain foo but not bar
[[ $x =~ .*(string 1|string 2).* ]]
ls !(*_*_*)
shopt -s globstar;rm Music/**/*.{m3u,pls}
shopt -s globstar;printf %s\\n **/ # only directories
shopt -s dotglob nullglob;echo .[^.]* ..?*
shopt -s extglob;echo "${x%.@{jpg,png}}"
(shopt -s dotglob;echo ~/*) # like `echo ~/* ~/.*`
(shopt -s failglob;: *.html>/dev/null;echo $?)
[[ $(shopt -s nullglob;printf %s *.html) ]];echo $?
shopt -s nocaseglob # ignore case for filename expansion
shopt -s nocasematch # ignore case inside [[ and in case patterns
shopt -s extdebug;declare -F f # print the name of the file where f was defined in
shopt -s nullglob;f=(/dir1/*);[[ $f ]]||exit;mv ${f[@]} /dir2;open /dir2/${f[0]##*/}
tail -r ~/.bash_history|awk '!a[$0]++'|tail -r>a;mv a ~/.bash_history;history -c;history -r # -c clears the history list and -r reads the history file
history -d $((HISTCMD-2)) # delete the previous command
compgen -e # names of exported variables (an alternative to `env|cut -d= -f1`)
unset $(compgen -e|grep ^LESS)
while read l;do echo "${l^}";done # convert the first character of each line to uppercase
files=(/usr/bin/*);echo ${files[@]##*/}
ls -a|grep -E '^(\.[^.]|\.\.[^$])'
type -t # print type (alias, builtin, file, function, or keyword)
type -p echo # no output if the first echo is not a command on the path
type -P echo # only search the path
read -p 'Continue (y/n)? ' -n1 var;echo;[[ $var = [yY] ]]||exit # -p changes prompt and -n1 reads one character
read -ei 'initial answer' var # -e uses readline and -i changes the initial text when using readline
read -ep 'prompt ' var # `printf 'prompt ';read -e var` would allow deleting the prompt text
read -p 'Password: ' -s pass;echo # -s disables echoing typed characters
read -N4 # read at most 4 characters and don't stop reading if a delimiter is encountered
enable # list all enabled and disabled builtins (same as `enable -a` and `enable -p`)
declare -f # list functions
declare -A a=([x]=1 [y]=2);for i in ${!a[@]};do echo $i ${a[$i]};done
export # list exported variables and functions (like env)
set # list all variables and functions (like declare)
trap -p # show signals ignored at startup (like SIGTSTP, SIGTTIN, and SIGTTOU)
set +H # disable history expansion
echo !:0 # zeroth argument
echo !* # all arguments except the zeroth one
shopt -s failglob # treat globs without matches as errors (like zsh by default)
PS4='$(date +%s) $LINENO ' bash -xc '. .bashrc'
set +o posix # disable POSIX mode when bash is invoked as sh
shopt -u xpg_echo # make echo support options and not interpret escape sequences when bash is invoked as sh
echo $FUNCNAME # the name of the current function ($0 is not changed inside functions in bash)
echo ~+ ~- ~2 # like `echo "$PWD" "$OLDPWD" "${DIRSTACK[2]}"`
TMOUT=20 # exit if there is no input in 20 seconds
curl http://git.savannah.gnu.org/cgit/bash.git/snapshot/bash-4.0.tar.gz|tar -x;cd bash-4.0;./configure;make;mv bash /usr/local/bin/bash40
cd bash-bash-4.3;./configure;make;exec ./bash;cd examples/loadables;make;enable -f finfo finfo;help finfo # enable the finfo loadable builtin
compgen -abck -A function # list aliases, builtins, commands, keywords, and functions
help \* # print all help messages
help # print a list of builtins
help variables # print descriptions of some shell variables
read -e -i 'initial text' # change the initial text for the readline buffer (-e uses readline)
echo "!$:h" # print the head part (dirname) of the last argument
while((SECONDS<300));do sleep 1:;done # wait until the shell or script has run for five minutes
read -d '' -t0.01 -n99999;printf '\e[2K\r' # discard typeahead and clear the readline editing buffer
bind -ps|grep -a '"\\e[a-z]"'|cut -c4|sort|comm -13 - <(printf %s\\n {a..z}) # find unused keybindings under meta (`bind -s` includes keysequences)
export -f $(compgen -A function) # export all functions
x='aa bb'; [[ $x =~ (a+)' '(b+) ]];declare -p BASH_REMATCH # declare -ar BASH_REMATCH='([0]="aa bb" [1]="aa" [2]="bb")'
shopt -s extglob;touch a;x='@(a)';echo $x # a (extended globbing is not disabled after parameter substitution in bash)
case aa in aa)printf 1;&bb)printf 2;;cc)printf 3;esac # 12 (;& also executes the command list of the next clause)
type [[ # [[ is a shell keyword
type [ # [ is a shell builtin
x=-nene;echo "$x" # doesn't print anything in bash
a=();declare -p a # declare -a a='()'
declare -a a;declare -p a # declare -a a='()'
let x=1;declare -p x # declare -- x="1"
declare -i x=1;declare -p x # declare -i x="1"
v1=5;v2=6;for i in 1 2;do var=v$i;printf ${!var};done # 56
x=$'1\n2';echo ${x//$'\n'/, } # 1, 2
a=(aa bbcc);echo ${a[1]//b} # cc
set /a/b/c /a/b/d;echo ${@##*/} # c d
set a b;echo ${@/#/prefix-} # prefix-a prefix-b
x=aabbaaacc;x=${x//[^a]};echo ${#x} # 5
set xyz xxy;echo ${@//x} # yz y
unset a;a+=(1);a+=(2);echo ${a[@]} # 1 2
[[ aa =~ ^(aa|bb)$ ]];printf $?;shopt -s extglob;[[ aa = @(aa|bb) ]];printf $? 00
echo $(x=$'\ta\t\tb';IFS=$'\t' a=($x);echo ${a[1]}) $(x=xaxxb;IFS=x a=($x);echo ${a[3]}) # b b
a=(x y);for i in ${!a[@]};do printf "$i:${a[i]};";done # 0:x;1:y;
a=(x y);touch a0;unset a[0];printf ${#a[@]};unset 'a[0]';printf ${#a[@]} # 21
IFS=, read -a a<<<1,2,3;echo ${a[2]} # 3
echo $(printf '1\n2'|while read l;do printf $l;done) $(printf '1\n2'|while read l||[[ $l ]];do printf $l;done) # 1 12
read -d, -n3<<<a,bc;echo $REPLY # a
read -d, -N3<<<a,bc;echo $REPLY # a,b
eval printf %s "$(printf %q \'\"\$)" # '"$
x=0;seq 3|while read l;do let x+=l;done;echo $x # 0
x=0;while read l;do let x+=l;done< <(seq 3);echo $x # 6
x=066;echo $((x/3)) $((10#$x/3)) # 18 22
set --;[[ $@ ]];printf $?;[[ $# != 0 ]];printf $? # 11
bash -c 'echo $BASH_EXECUTION_STRING' # echo $BASH_EXECUTION_STRING
exit 1|exit 0|exit 9;echo ${PIPESTATUS[@]} # 1 0 9
shopt -s nocasematch;[[ a = A ]];echo $? # 0
shopt -s nocasematch;case a in A)echo true;;esac # true
env 'f=() { echo a; }' bash -c f # a
printf %x $((0x4a+0x96)) # e0
shopt -s xpg_echo;shopt -q xpg_echo;echo $? # 0
shopt -u xpg_echo;shopt -q xpg_echo;echo $? # 1
[[ 11 > 2 ]];printf $?;[[ 11 -gt 2 ]];printf $?;((11>2));printf $? # 100
echo $(x=1;let x+=2;echo $x) $(x=1;((x+=2));echo $x) $(declare -i x=1;x+=2;echo $x) # 3 3 3
e=2.71828;printf -v e %.2f $e;echo $e # 2.72
x=$'line 2\nline 2\n';x=${x//[^$'\n']};echo ${#x} # 2
set some string;echo ${@^} # Some String
x=aa;y=a\*;[[ $x = $y ]];printf $?;[[ $x = "$y" ]];printf $? # 01
printf %x \'$'\u1234' # 1234
echo $((0x7fffffffffffffff)) $((0x7fffffffffffffff+1)) # 9223372036854775807 -9223372036854775808
a=(1 2 3);printf '%s, ' "${a[@]::${#a[@]}-1}";printf '%s\n' "${a[-1]}" # 1, 2, 3
x=y=1;((1-x));echo $y # 1
compgen -k|paste -sd' ' - # if then else elif fi case esac for select while until do done in function time { } ! [[ ]] coproc
set -k;bash -c 'echo $x' x=1 # 1
x='aa?bb';echo "${x%?*}" "${x%\?*}" # aa?b aa
[[ 010+2 -eq 10 ]];printf $?;[ 010+2 -eq 10 ];printf $? # 01
echo $(x=1;x=2|x=3;echo $x) $(shopt -s lastpipe;set +m;x=1;x=2|x=3;echo $x) # 1 3
IFS=0;set {1..101};echo $# "$#" # 1 1 101
contains() { local x;for x in "${@:2}";do [[ $x = $1 ]]&&return 0;done;return 1; };a=(aa bb);contains aa "${a[@]}";echo $? # 0
a=1\\;b=\\;echo "${a%$b}" "${a%"$b"}" # 1\ 1
a=\\;b=\\;echo "${a//$b/x}" "${a//"$b"/x}" # \ x
set 1 2 3;a=();for((i=$#;i>=1;i--));do a+=("${!i}");done;echo "${a[@]}" # 3 2 1
shopt -s globasciiranges # always use ASCII collation order for character ranges in bash 4.3 and later
a=(a b);a[-1]=c;declare -p a # declare -a a='([0]="a" [1]="c")' (bash 4.3 and later)
read a< <(printf 'x\0x');echo $a # `xx` in bash 4.3 but `x` in older versions (read skips null bytes in bash 4.3)
set 'a  b';x=$@;echo "$x" # `a  b` in bash 4.3 but `a b` in older versions
x=1;declare -n y=x;printf $y;x=2;printf $y # 12 in bash 4.3 (-n makes a parameter a nameref)
HISTSIZE=-1 HISTFILESIZE=-1 # unlimited history in bash 4.3 (`HISTFILE= HISTFILESIZE=` also works in older versions)
printf '%(%F)T\n' -1 # an alternative to `date +%F` in bash 4.2 and later (bash 4.3 allows omitting -1 but bash 4.2 doesn't)
unset x;[[ -v x ]];echo $? # 1 (-v tests if a variable is set in bash 4.2 and later)
f() { local x;declare -g x=a; };f;echo $x # a (-g makes a variable global in bash 4.2 and later)
a=(a b);echo ${a[-1]} # b (bash 4.2 and later)
shopt -u extglob;[[ a = @(a|b) ]];echo $? # 0 (bash 4.1 and later)
echo {001..3} # 001 002 003 (bash 4.0 and later)
echo {1..7..3} # 1 3 7 (bash 4.0 and later)
x=abcdef;echo ${x:0:-2} # abcd (bash 4.0 and later)
x=aaa;y=AAA;echo ${x^^} ${x^} ${y,,} ${y,} # AAA Aaa aaa aAA (bash 4.0 and later)
declare -l x;x=A;echo $l # a (bash 4.0 and later)
PROMPT_DIRTRIM=30 # limit the length of \w and \W to 30 characters (bash 4.0 and later)
read -t0;echo $? # test if input is available (bash 4.0 and later)

#OS X
open -e # open files in TextEdit
open -t # open files in the default application for public.plain-text files
open -f # open STDIN in TextEdit
open -h # open a header file
open -R # reveal in Finder
open -F # disable restoring the state of an application in 10.7 and later
open -j # open an application hidden (added in 10.8)
open -g # open an application in the background
man launchd.plist
launchctl unload ~/Library/LaunchAgents/label.plist;launchctl load ~/Library/LaunchAgents/label.plist # apply changes to label.plist
launchctl unload /System/Library/LaunchAgents/com.apple.Finder.plist # quit Finder
cat /var/db/launchd.db/com.apple.launchd.peruser.$UID/overrides.plist # modified when `launchctl load -w` is ran as the user
sudo cat /var/db/launchd.db/com.apple.launchd/overrides.plist # modified when `launchctl load -w` is ran as root
launchctl limit # print soft and hard limits (like `ulimit -a;ulimit -Ha`)
launchctl list # list jobs
launchctl list some.label # show for example the last exit status and the value of LimitLoadToSessionType
launchctl submit -l some.label -- ./script.sh # an alternative to disown and nohup
launchctl stop some.label # terminate a process started with `launchctl submit`
launchctl bsexec $(pgrep -u user2 -x launchd) cmd # run cmd in user2's bootstrap context
launchctl setenv aa bb # set an environment variable for new processes
sudo launchctl limit maxfiles 10000 # change the soft and hard limits for the number of open files for new processes until the launchd process is terminated
echo kern.maxfiles=10000|sudo tee -a /etc/sysctl.conf # change the limits for the number of open files permanently after restarting
mdfind '"exact phrase"'
mdfind -name javascript -onlyin ~/Books
mdfind kind:pdf # match the localized kind description
mdfind -name .pdf
mdfind 'kMDItemFSName=*.pdf'
mdfind 'kMDItemFSName=convert&&kMDItemContentType=public.unix-executable'
mdfind kMDItemContentType=com.apple.application-bundle -onlyin /usr/local
mdfind kMDItemContentTypeTree=com.apple.bundle
mdfind kMDItemContentTypeTree=public.movie
mdfind 'kMDItemTextContent="*expose*"cd' # ignore case and diacritics
mdfind 'kMDItemTextContent="*search phrase*"c' -onlyin ~/Library/Caches/Metadata/Safari/History
mdfind kMDItemFSSize=$(stat -f%z file) # quickly find duplicate files by size
mdfind 'kMDItemFSCreationDate>$time.iso(2014-03-16T01:03:08Z)' -onlyin . # like `TZ=UTC0 find . -newerBt '2014-03-16 01:03:08'`
mdfind 'kMDItemFSContentChangeDate>$time.now(-86400)' -onlyin ~/Library/Caches/Metadata/Safari/History|xargs mdls -n kMDItemURL|cut -d\" -f2
mdfind 'kMDItemDateAdded>$time.today(-7)' # find files that were first indexed or moved in the last week
mdfind 'kMDItemLastUsedDate!=*' -onlyin . # find files that have not been opened before
mdfind 'kMDItemKind=*movie&&kMDItemPixelHeight>=720'
mdfind 'kMDItemAuthors="Artist Name"' -onlyin ~/Music
mdfind 'kMDItemURL=*stackoverflow.com*' -onlyin ~/Library/Caches/Metadata/Safari/History
mdfind 'kMDItemFSSize>1e8'
mdfind -0 -onlyin ~/Music 'kMDItemFSName=*.mp3&&kMDItemAudioBitRate<=192000'|xargs -0 mdls -n kMDItemAlbum|sort -u
mdfind $'kMDItemFSName="*\n*"'
mdfind -onlyin / # like `mdfind -onlyin /Volumes/Macintosh\ HD`
mdfind 'kMDItemDurationSeconds<=180&&kMDItemContentType=public.mp3' -onlyin .
mdfind 'kMDItemUserTags=*' # find files with tags
mdfind -s example # an alternative to `mdfind "$(PlistBuddy -c 'Print RawQuery' ~/Library/Saved\ Searches/example.savedSearch)"`
mdfind 'search phrase' -0|xargs -0 ls -l
sudo mdfind com_apple_backup_excludeItem=com.apple.backupd # find files excluded from Time Machine backups
mdls -rn kMDItemLastUsedDate -n kMDItemFSName *|tr \\0 \\n|paste - -|sort # sort by date last opened
mdls -rn kMDItemCFBundleIdentifier "$(mdfind 'kMDItemContentType=com.apple.application-bundle&&kMDItemFSName=iTunes.app'|head -n1)"
mdls -n kMDItemURL $(mdfind 'search phrase' -onlyin Library/Caches/Metadata/Safari/History)|cut -d\" -f2
for f in *.pdf;do echo $(mdls -rn kMDItemNumberOfPages "$f") "$f";done
for f in ~/Notes/*.txt;do echo $(mdls -rn kMDItemUseCount $f) $f;done|sort -n # times opened
touch a.tex;mdls -n kMDItemContentTypeTree a.tex # see the UTI and parent UTIs for tex files
find ~/Documents -name \*.pdf -exec mdls -n kMDItemFSName -n kMDItemWhereFroms {} +
touch a;xattr -w com.apple.metadata:MyAttribute value a;mdls -n MyAttribute a;mdfind 'MyAttribute=*'
mdimport ~/Documents/ # reindex a folder
mdimport -A # show a list of the kMD attribute identifiers
mdimport -X # show what attributes are indexed for each UTI and what attributes are not searchable
mdimport -L # list mdimporter plugins
sudo mdutil -E / # erase the Spotlight index on the startup volume
sudo mdutil -Ea # erase the Spotlight indexes on all volumes
mdutil -vsa # verbose status information for all volumes
touch /Volumes/Volume/.metadata_never_index
sudo defaults write /.Spotlight-V100/VolumeConfiguration.plist Exclusions -array-add /path # an alternative to adding a folder to the privacy tab in System Preferences
find . -exec mdls -rn kMDItemFSName -rn kMDItemDateAdded {} +|tr \\0 \\n|paste - -|sort
diskutil mount Time\ Machine&&tmutil startbackup -b&&diskutil eject Time\ Machine # -b blocks until the backup has finished
sudo tmutil disablelocal # disable local Time Machine snapshots
tmutil status # show the progress of a backup
cd "$(tmutil machinedirectory)"/Latest/*/Users/$USER/
sudo ln -s "$(tmutil machinedirectory)" /tm;sudo chflags -h hidden /tm
sudo tmutil delete /Volumes/Time\ Machine/Backups.backupdb/Mac/2012-09-13-191910 # delete a snapshot (`tmutil delete` can't be used with individual files)
sudo /System/Library/Extensions/TMSafetyNet.kext/Helpers/bypass rm -rf /Volumes/Time\ Machine/Backups.backupdb/Mac/2012-09-13-191910/folder
tmutil compare 2013-02-24-105019 2013-02-26-184354|grep ^+ # new files
tmutil compare ~/Documents/ /Volumes/*/Backups.backupdb/*/Latest/*/Users/*/Documents/
wc -l /Volumes/*/Backups.backupdb/*/*/*/*/*/.bash_history
tmutil calculatedrift "$(tmutil machinedirectory)" # show the size of changes between backups
tmutil latestbackup # like `tmutil listbackups|tail -n1`
cat /System/Library/CoreServices/backupd.bundle/Contents/Resources/StdExclusions.plist # files excluded by default
cat /System/Library/CoreServices/backupd.bundle/Contents/Resources/System.plist # files excluded when Time Machine is set to exclude all system files
sudo defaults read /Volumes/*/Backups.backupdb/*/Latest/.exclusions.plist # files excluded from the latest snapshot
defaults read /Library/Preferences/com.apple.TimeMachine.plist # files excluded from System Preferences
tmutil addexclusion ~/folder # add a com.apple.metadata:com_apple_backup_excludeItem extended attribute
sudo tmutil addexclusion -p ~/folder # add to /Library/Preferences/com.apple.TimeMachine.plist
xattr -l ~/Music/iTunes/iTunes\ Library.xml # `iTunes Library.xml` has a com.apple.metadata:com_apple_backup_excludeItem extended attribute
screencapture -i ~/Desktop/$(date +%Y%y%m%d%H%M%S).png # -i is interactive (selection) mode
screencapture -ic # like control-shift-command-4
screencapture -cC -T 5 # copy to clipboard, include cursor, and use a 5 second timer
screencapture -l$(osascript -e'tell app "Safari" to id of window 1') /tmp/a.png
screencapture screen1.png screen2.png;rm screen1.png
while :;do screencapture $(date +%F-H%M%S).png;sleep 1;done
security dump-keychain -d ~/Library/Keychains/login.keychain
security find-internet-password -s accounts.google.com -w
security find-generic-password -l 'keychain item name' -w # -l searches by label and -w prints only the password
security lock-keychain # lock the login keychain
security set-keychain-settings -l -ut 180 # -l locks the keychain after sleep and `-ut 180` locks the keychain after 3 minutes
sudo fs_usage -w # force wide display
sudo fs_usage -f exec # new processes
sudo fs_usage -f filesys # filesystem events
sudo fs_usage -f network
sudo fs_usage -w|grep -v 0.000 # show only operations that take a microsecond or longer
sudo fs_usage cmd Safari
otool -L /Applications/iTunes.app/Contents/MacOS/iTunes # libraries used by iTunes
nm -a /sbin/launchd # display symbol table (-a includes symbols inserted for use by debuggers)
osadecompile file.scpt # show file.scpt as text
for f in *.applescript;do osacompile -o "${f%applescript}scpt" "$f";done
for f in *.scpt;do osadecompile "$f">"${f%scpt}applescript";done
find Library/Scripts -name \*.scpt|parallel osadecompile {}\>{.}.applescript\;rm {}
for f in ~/Library/Scripts/**/*.scpt;do osadecompile "$f"|tr \\r \\n|sed 's/search/replace/'|osacompile -o "$f";done
pbpaste|osacompile -o file.scpt
open /System/Library/Frameworks/AppleScriptKit.framework/Versions/A/Resources/AppleScriptKit.sdef -a AppleScript\ Editor
man 5 sdef
find Library/Scripts -name \*.scpt -exec open {} +
defaults write com.apple.ScriptEditor2 ApplePersistence -bool false # disable auto-save
osascript -e'set text item delimiters to linefeed' -e'tell app "System Events" to (name of processes where background only is false) as text'
osascript -e'tell app "System Events" to set require password to wake of security preferences to false'
osascript -e'display dialog "" default answer ""' # display a text dialog in 10.9 and later
osascript -e'tell app (path to frontmost application as text) to display dialog "" default answer ""' # display a text dialog in 10.8 and earlier
osascript -e'on run {a}' -e'display dialog "" default answer a' -eend -- "$(<${TMPDIR}defaultanswer)"
osascript -e'tell application "Safari" to source of document 1'
osascript -e'tell application "Safari" to do JavaScript "document.body.innerHTML" in document 1' # generated source
osascript -e'tell application "Safari" to do JavaScript "out=\"\";all=document.links;for(i=0;e=all[i];i++){out+=e.href+\"\\n\"};out" in document 1'
osascript -e'set text item delimiters to linefeed' -e'tell app "Safari" to (name of tabs of window 1) as text'
osascript -e'tell app "Safari" to URL of document 1'>>~/notes/bookmarks
osascript -e'tell app "Safari" to close tabs of window 1 whose URL contains "text"'
osascript -e'tell window 1 of app "safari" to close (tabs whose index < (get index of current tab))'
osascript -erepeat -e'tell app "safari" to do javascript "window.scroll(0,999999)" in document 1' -eend
osascript -e'tell document 1 of app "safari" to do javascript "out=\"\";all=document.querySelectorAll(\".class\");for(i=0;e=all[i];i++){out+=e.href+\"\\n\"};out"'
osascript -e'tell document 1 of app "safari" to do javascript "window.scroll(0,window.innerHeight*50)"' # scroll 50 pages down
osascript -e'tell window 1 of app "safari" to set current tab to tab 1 whose URL contains "substring"'
open "http://web.archive.org/web/*/$(osascript -e'tell app "Safari" to URL of document 1')"
open http://last.fm/music/$(ruby -rcgi -e'print CGI.escape ARGV[0]' "$(osascript -e'tell app "iTunes" to artist of current track')")
osascript -e'set text item delimiters to linefeed' -e'tell app "iTunes" to (artist of tracks of current playlist) as text'
kill $(osascript -e'tell app "System Events" to unix id of processes where background only is false'|tr -d ,)
osascript -e'tell app "iTunes" to refresh selection' # update the tags of the selected items if the tags have been edited outside iTunes
osascript -e'tell app "Terminal"' -e'do script ""' -e'set current settings of selected tab of window 1 to settings set "Grass"' -eend # `do script ""` opens a new window
osascript /Library/Scripts/Font\ Book/Create\ Font\ Sample.scpt # create an RTF file with samples of the fonts selected in Font Book
osascript -e'tell app "iTunes" to repeat with t in (get tracks of library playlist 1)' -e'if location of t is missing value then delete t' -eend # remove deleted tracks
osascript -e'tell app "System Events" to shut down' # shut down without showing a confirmation dialog
osascript -e'tell app "System Events" to restart' # restart without showing a confirmation dialog
osascript -e'tell app "System Events" to log out' # log out after showing a confirmation dialog
osascript -e'tell app "loginwindow" to «event aevtrlgo»' # log out without showing a confirmation dialog
osascript -e'tell app "Finder" to POSIX path of (insertion location as alias)'
osascript -e'tell app "Google Chrome" to URL of active tab of window 1'
osascript -e'tell app "iTunes" to repeat with t in (get selection)' -e'if rating of t is 0 then delete t' -eend
osascript -e'tell app "iTunes"' -e'set o to ""' -e'repeat with t in (get selection)' -e'set o to o & posix PATH of (get location of t) & linefeed' -eend -eend
osascript -erepeat -e'delay 10' -e'tell app "system events" to keystroke " "' -eend
find . -Btime -2 # files created within 48 hours
find . -acl # files with ACLs
find . -flags +uchg
find . -xattrname com.apple.quarantine
xattr file # list attribute names
xattr -l file # list attribute names and values
xattr -d com.apple.quarantine file # delete a single extended attribute
xattr -c file # delete all extended attributes
xattr -rd com.apple.quarantine ~/Downloads/
xattr -p com.apple.metadata:kMDItemWhereFroms file|xxd -r -p|plutil -convert xml1 - -o -
ditto -c -k --sequesterRsrc --keepParent dir dir.zip # like `zip dir.zip -r dir` but keep extended attributes, ACLs, file flags, and resource forks
ditto -x -k dir.zip # like `unzip dir.zip` but convert metadata stored in AppleDouble files back to native formats
ls -l@eO # show extended attributes, ACLs, and file flags
ls -lU # show creation times
ls -tU # sort by creation time
ls -le ~/ # folders like ~/Documents/ have the ACE `0: group:everyone deny delete`
cp -X # remove extended attributes, ACLs, file flags, and resource forks
cat file/..namedfork/rsrc # `cat file/rsrc` stopped working in 10.7
>file/..namedfork/rsrc # like `xattr -d com.apple.ResourceFork file`
find . -type f -xattrname com.apple.ResourceFork # like `find . -type f -exec test -s {}/..namedfork/rsrc \; -print`
chmod -NR . # delete ACLs recursively
chmod -a # replace an ACL
chmod +a # add an ACE
echo a>test;chmod 0 test;chmod +a "$USER allow read" test;cat test # a (the ACL has precedence over the mode)
touch a;chmod +a 'everyone deny delete' a;rm a # doesn't work (but `sudo rm a` does)
touch a;chflags uchg a;sudo rm -f a # doesn't work (but `sudo chflags nouchg a;rm a` does)
rsync -E # preserve extended attributes and ACLs in OS X's rsync (use -XA in the standard rsync)
COPYFILE_DISABLE= tar -cf dir.tar dir # remove metadata like extended attributes and ACLs instead of creating AppleDouble files
COPYFILE_DISABLE= tar -xf dir.tar # don't convert metadata stored in AppleDouble files back to native formats
chflags hidden ~/{Movies,Pictures,Music/iTunes}
chflags uchg file # lock a file
sudo chflags -h nohidden /etc # -h doesn't follow symlinks (like `chmod -h`)
SetFile -a E file # hide the filename extension
SetFile -d "$(GetFileInfo -m file)" file # set creation time to modification time
SetFile -d "$(date -r $(($(stat -f%B file)+1234567)) '+%m/%d/%Y %H:%M:%S')" file # shift creation time
find file -flags uchg|grep -q . # like `GetFileInfo file|grep -q '^attributes:.*L'`
touch -m -t $(stat -f %SB -t %Y%m%d%H%M file.txt) file.txt # set modification time to creation time
find . -name ._\* -delete
dot_clean . # delete ._ files after converting the metadata stored in them to native formats like extended attributes
yes|hdiutil attach OmniGrafflePro-5.3.3.dmg>/dev/null # bypass a license agreement
hdiutil info -verbose # show information about mounted disk images
hdiutil create -srcfolder folder -format UDTO folder.cdr
hdiutil mount /Volumes/Data/iMac.sparsebundle
hdiutil imageinfo file.dmg # show information about a dmg file
diskutil list # list disks and partitions
diskutil eject WD # unmount all volumes and eject a disk
diskutil unmountDisk WD # unmount all volumes
diskutil mountDisk WD # mount all volumes
diskutil verifyVolume / # an alternative to verifying a volume in Disk Utility
diskutil verifyDisk / # an alternative to verifying a drive in Disk Utility
diskutil repairVolume /Volumes/volume # does not work with /
diskutil repairDisk /dev/disk0 # works with the drive of /
diskutil eraseDisk JHFS+ 'New Name' disk3
diskutil eraseVolume JHFS+ 'New Name' /Volumes/volume
diskutil secureErase 1 /dev/disk1s2 # an alternative to erasing a volume securely from Disk Utility
diskutil secureErase freespace 1 /dev/disk1s2 # an alternative to erasing free space on a volume from Disk Utility
diskutil mergePartitions HFS+ 'Macintosh HD' 'Macintosh HD' 'Recovery HD' # remove the recovery partition
diskutil info /some/path 2>/dev/null;echo $? # test if /some/path is a mountpoint
diskutil eject /dev/disk[1-9]
diskutil mount Recovery\ HD;hdiutil mount /Volumes/Recovery\ HD/com.apple.recovery.boot/BaseSystem.dmg # mount the recovery partition
diskutil unmount Recovery\ HD
diskutil cs convert disk2s1 -passphrase password # an alternative to enabling encryption for a volume from Finder
diskutil activity # show activity reported by the Disk Arbitration framework
diskutil info /Volumes/volume|awk '/^   Volume UUID:/{print$3}' # UUIDs are not shown for NTFS or FAT volumes
diskutil info 5DF7A03E-A7FB-3E80-B61D-F10CD8BF7B5D|sed -n 's/^   Mount Point: *\(.*\)/\1/p'
echo 'UUID=3B5315C1-96AE-3471-B43C-2C41CDB12A64 none hfs rw,noauto'|sudo tee -a /etc/fstab # prevent automatic mounting
mkdir /tmp/efi;sudo mount -t msdos /dev/disk0s1 /tmp/efi # mount the EFI partition
osascript -e'tell app "Finder" to eject' # eject removable disks
cat /System/Library/Filesystems/hfs.fs/Contents/Info.plist
mount -o nobrowse # don't show a volume in Finder
bless --info / # show information like the blessed system folder and the blessed system file
sudo gpt show disk0 # display the offset and size of partitions and other sectors like GPT headers and GPT tables
lsvfs # show the number of mounted virtual filesystems of each type and flags for filesystems
sudo fdesetup enable # an alternative to enabling FileVault 2 from System Preferences
sudo fdesetup status # show if FileVault 2 is enabled or if encryption or decryption is in progress
afplay -r 1.5 -v 0.5 file.m4a # play at 150% rate and 50% volume
afinfo file.m4a
afconvert input.wav output.m4a -q 127 -s 3 -b 256000 -f m4af -d 'aac ' # `-q 127` uses maximum codec quality
afconvert input.wav output.caf -d ima4 -f caff
afconvert -hf # list formats
pbcopy<file.txt
LC_CTYPE=UTF-8 pbcopy # pbcopy and pbpaste don't use UTF-8 if LC_CTYPE is C or unset (like in Automator or AppleScript Editor)
MANPAGER='col -bx' man strftime|open -f # `col -bx` doesn't print backspaces and expands tabs to spaces, `open -f` opens STDIN in TextEdit
wget http://mirror.ctan.org/systems/mac/mactex/MacTeX.pkg;sudo installer -pkg MacTeX.pkg -target /
hdiutil attach command_line_tools*.dmg;sudo installer -pkg /Volumes/Command\ Line\ Tools*/*.mkpg -target /
lsbom $(pkgutil --bom package.pkg) # show the files that would be installed by package.pkg
pkgutil --expand package.pkg dir # create dir and extract package.pkg to it
pkgutil --pkgs # list the IDs of installed packages
pkgutil --files com.adobe.pkg.FlashPlayer # an alternative to `lsbom /var/db/receipts/com.adobe.pkg.FlashPlayer.bom`
pkgutil --package-info com.apple.pkg.iPhoto_AppStore # install time, version, ID, location
pkgutil --export-plist com.apple.pkg.iPhoto_AppStore # print all receipt information
pkgutil --file-info file # show information about the package that installed a file
sudo pkgutil --forget $packageid # remove the plist and bom file for a package from /var/db/receipts/
pkgutil --groups # list package groups
sudo repair_packages --verify --standard-pkgs # an alternative to verifying permissions from Disk Utility
sudo repair_packages --repair --standard-pkgs # an alternative to repairing permissions from Disk Utility
repair_packages --list-standard-pkgs # list the packages that are verified by repair_packages and Disk Utility
pkgutil --group-pkgs com.apple.snowleopard-repair-permissions.pkg-group # list the packages that are verified by repair_packages and Disk Utility
sudo atsutil databases -remove;atsutil server -shutdown # remove fontd databases and cache files (`atsutil server -ping` is not needed)
/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport -I # information
/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I|awk '$1=="SSID"{print$2}'
sudo ifconfig $(networksetup -listallhardwareports|awk '/^Hardware Port: (Wi-Fi|AirPort)/{getline;print$2}') down # turn off Wi-Fi
networksetup -setairportpower $(networksetup -listallhardwareports|awk '/^Hardware Port: (Wi-Fi|AirPort)/{getline;print$2}') off # turn off Wi-Fi
networksetup -listallnetworkservices
networksetup -connectpppoeservice HUAWEIMobile-Modem # an alternative to connecting a device from System Preferences
sudo softwareupdate --schedule off # an alternative to unchecking "Automatically check for updates" from System Preferences
softwareupdate -da # download all updates to /Library/Updates/
sudo softwareupdate -ia # install all updates
sudo pmset schedule shutdown '12/31/2012 23:59:59'
sudo pmset repeat sleep MTWRFSU 23:00:00 wakeorpoweron MTWRFSU 07:00:00
sudo pmset repeat cancel
pmset -g # current settings
pmset -g assertions # power assertions (see what processes are preventing idle sleep or display sleep)
pmset -g sched # scheduled events
pmset -g batt # battery capacity and remaining time
pmset -g log # log of power assertions and events
pmset -g cap # pmset features (capabilities) supported by the computer
pmset -g everything # concatenate output corresponding to all arguments for -g
pmset -g|grep 'Battery Power.*\*' # test if the Mac is on battery power
pmset sleepnow
pmset displaysleepnow # added in 10.9
sudo pmset disksleep 10 # keep disks spinning for at least 10 minutes
sudo pmset -a darkwakes 0 # an alternative to disabling Power Nap from System Preferences
pmset noidle # prevent idle sleep until pressing ^C
sudo pmset -a hibernatemode 0 # suspend to RAM (default on desktop Macs)
sudo pmset -a hibernatemode 3 # suspend to RAM and disk (default on laptops)
sudo pmset -a hibernatemode 25 # suspend to disk
sudo pmset autopoweroff 0 # don't switch to hibernation after four hours of sleep
sudo pmset -c ttyskeepawake # prevent idle sleep when a TTY is active
caffeinate # an alternative to `pmset noidle`
caffeinate script.sh # prevent idle sleep until script.sh exits
caffeinate -d -t 3600 # prevent display sleep for the next hour
caffeinate open -Wa uTorrent&disown $! # prevent idle sleep until uTorrent is closed
pgrep -x uTorrent&&caffeinate -t 300
caffeinate -u -t 1 # wake up displays (-u simulates user activity like moving a mouse)
textutil -convert html file.rtf # RTF to HTML
textutil -convert txt *.doc
printf %b '<h1>\u3042</h1>'|textutil -inputencoding UTF-8 -format html -convert rtf -stdin -stdout
pandoc -f markdown_strict file.md|textutil -inputencoding UTF-8 -format html -convert rtf -stdin -stdout|pbcopy
codesign -vv iTunes.app # verify verbose
sudo codesign -f -s - /Applications/Chess.app/ # replace the code signature with an ad-hoc signature and disable sandboxing
codesign --display --entitlements - /Applications/iTunes.app
asctl container path Preview # ~/Library/Containers/com.apple.Preview
find ~/Library/Containers/com.amazon.Kindle -type f
strings /Applications/iTunes.app/Contents/MacOS/iTunes|grep -E '^[a-zA-Z0-9.-]{10,80}$'|awk '!a[$0]++'
mdfind kMDItemContentType=public.unix-executable -onlyin /System|xargs strings 2>/dev/null|grep -E '^[a-zA-Z0-9.-]{10,80}$'|grep ^Apple
kextstat|grep -v com.apple # list non-Apple kernel extensions
sudo kextunload -b com.github.osxfuse.filesystems.osxfusefs # -b specifies a bundle ID
system_profiler SPHardwareDataType|grep Cores # number of physical cores
system_profiler SPDisplaysDataType|awk '$1=="Resolution:"{print$2,$4}' # width and height of displays
system_profiler SPHardwareDataType|awk '/Model Identifier:/{print$NF}' # model identifier (like iMac 13,1)
system_profiler SPAirPortDataType # Wi-Fi
system_profiler SPAudioDataType # list audio devices
sw_vers # OS X version and build number
system_profiler SPSoftwareDataType # show for example the OS X version, build number, kernel version, computer name, and time since last boot
sudo /System/Library/CoreServices/Setup\ Assistant.app/Contents/MacOS/Setup\ Assistant # run Setup Assistant again
/System/Library/CoreServices/pbs -dump_pboard # list services
xar -xf SafariExtension.safariextz
VERSIONER_PERL_PREFER_32_BIT=1 perl -MMac::InternetConfig -le 'print +(GetICHelper "http")[1]' # default browser
dscl localhost -read /Search/Users/$USER|awk '/^GeneratedUID:/{print$2}'
sudo dscl . -change $HOME UserShell /usr/local/bin/bash # an alternative to `echo /usr/local/bin/bash|sudo tee -a /etc/shells;chsh -s /usr/local/bin/bash`
sudo dscl . -append /Groups/admin GroupMembership user1 # convert user1 from a standard account to an admin account
dscl . -read /Users/user1 NFSHomeDirectory # home directory of user1
dscl . -ls /Users # list users
sudo dscl . passwd /Users/someuser newpassword
dscl . -list /Groups GroupMembership # list users that are part of each group
dscl . -read /Groups/com.apple.access_screensharing
dscl . -read /Users/_mysql RecordName # RecordName: _mysql mysql (_mysql is the primary name and mysql is an alias)
dsenableroot # an alternative to enabling the root user from Directory Utility
dsenableroot -d # disable the root user
dseditgroup -o edit -n /Local/Default -u $USER -p -a username -t user com.apple.access_ssh # allow SSH for username
sudo systemsetup -printCommands
sudo systemsetup -getcomputername
sudo systemsetup -setusingnetworktime off -setdate 12:31:2013 -settime 23:59:59 # an alternative to changing time and date from System Preferences
sudo systemsetup -setremotelogin on # an alternative to enabling SSH from System Preferences
sudo du -sm /var/folders/*/*/*/*|sort -rn
for f in *.icns;do sips -s format png "$f" -o "${f%icns}png";done
for f in *.nef;do sips -s format jpeg -s formatOptions 90 $f -o ${f%nef}jpg;done
sips -Z 500 input.png -o output.png # an alternative to `convert input.png -resize 500x500\> output.png`
sips --getProperty pixelWidth input.png
ioreg -w0 # don't truncate the output lines
ioreg -nr IOHIDKeyboard # -n matches names and -r shows subtrees for a root node
ioreg -c # match C class names
ioreg -d1 -rc IOPlatformExpertDevice|awk -F\" '$2=="IOPlatformUUID"{print$4}' # faster than `system_profiler|awk '/Hardware UUID: /{print$3}'`
ioreg -l|awk '/(Max|Current)Capacity/{print$NF}'
ioreg -l|awk '/AvgTimeToEmpty/{print$NF}' # estimated time before the battery is empty
ioreg -c IOHIDSystem|awk '/HIDIdleTime/{print$NF/1000000000;exit}' # time since the last keyboard or mouse action
qlmanage -p file # show a Quick Look window
qlmanage -r # reset cache
qlmanage -m # show information like the list of generators
nvram -p # print NVRAM variables
sudo nvram boot-args='-x -v' # start up in safe mode and verbose mode
sudo nvram boot-args=iog=0x0 # restore the pre-10.7 clamshell mode behavior where a laptop display is kept disabled after opening the lid
sudo nvram -d boot-args # delete the boot-args variable
sqlite3 Library/Application\ Support/AddressBook/AddressBook-v22.abcddb .dump
sqlite3 ~/Library/Preferences/com.apple.LaunchServices.QuarantineEventsV2 .dump
sqlite3 ~/Library/Preferences/com.apple.LaunchServices.QuarantineEventsV2 'select LSQuarantineDataURLString from LSQuarantineEvent'
sqlite3 ~/Library/Application\ Support/Dock/desktoppicture.db 'select data.value from data' # paths of desktop pictures
sqlite3 ~/Library/Dictionaries/CoreDataUbiquitySupport/$USER~*/UserDictionary/local/store/UserDictionary.db .dump # text replacements synced with iCloud
sudo sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db .dump # applications that are allowed access for assistive devices
sqlite3 ~/Library/Application\ Support/com.apple.TCC/TCC.db .dump # applications that are allowed to access contacts or iCloud
ls -t /var/db/receipts/ # list installed packages by date
cat /Library/Receipts/InstallHistory.plist
system_profiler SPInstallHistoryDataType
lsbom /var/db/receipts/com.adobe.pkg.FlashPlayer.bom # like `pkgutil --info com.adobe.pkg.FlashPlayer`
cat /System/Library/Security/authorization.plist
sudo spctl --master-disable # disable Gatekeeper (the command has to be run as root even though there is no error message if it is run as a normal user)
spctl --status # check if Gatekeeper is enabled
spctl -av --raw /bin/ls # assess verbose
sysctl -a # display all non-opaque variables
sysctl -a|grep kern.max
sysctl -A # display all variables
sudo sysctl -w kern.maxprocperuid=5000
sysctl vm.loadavg # show load averages
sysctl hw.physicalcpu hw.logicalcpu # number of physical and logical cores
sysctl kern.argmax # an alternative to `getconf ARG_MAX`
sysctl kern.maxproc # an alternative to `ulimit -Hu`
syslog # an alternative to `cat /var/log/system.log`
syslog -w # an alternative to `tail -f /var/log/system.log`
syslog -w|while read l;do [[ $l = *'some message'* ]]&&afplay /System/Library/Sounds/Blow.aiff;done
syslog|grep backup
syslog -f /var/log/asl/2013.08.01.G80.asl # display a file
syslog -c Finder -d # -d is debug or higher
syslog -F '$Time $Message' -k Sender /System/Library/CoreServices/backupd -k Time ge -30m
man syslog.config
sudo syslog -config mps_limit 0 # temporarily disable the messages per second limit
sudo syslog -config reset
killall -HUP syslogd # reread asl.conf
syslog -C # console messages (same as syslog -k Facility com.apple.Console)
lipo -thin x86_64 /bin/bash -output /tmp/bash # remove support for i386
lipo -detailed_info /bin/bash # show architectures and the sizes of binaries
file /bin/bash # show architectures
say -r 250 text # same as `say '[[rate 250]] text'`
say '[[volm 0.5]]text' # reduce volume
say -v\? # list voices
pbpaste|sed 's/$/[[slnc 1000]]/'|say
i=10000;cat wordlist.txt|while read jp en;do say -v kyoko "$jp[[slnc 500]]" -o $((i++)).aif;say "[[volm 0.8]]$en[[slnc 2000]]" -o $((i++)).aif;done
defaults read -g # read ~/Library/Preferences/.GlobalPreferences.plist
defaults -currentHost read -g # read ~/Library/Preferences/ByHost/.GlobalPreferences.*.plist
sudo defaults read -g # read /var/root/Library/Preferences/.GlobalPreferences.plist
defaults domains|sed $'s/, /\\\n/g'|grep -v com.apple
defaults write domain key value # same as `defaults write domain key -string value`
defaults delete com.apple.dock persistent-apps;killall Dock # remove all applications from the Dock
defaults find nsquitalw
defaults read ~/Library/Safari/Bookmarks.plist|sed -n 's/^ *URLString = "\(.*\)";/\1/p'
defaults write com.apple.finder NSUserKeyEquivalents -dict 'Show Package Contents' '@\r' Tags... @t
defaults write com.apple.Safari NSUserKeyEquivalents '{"Select Previous Tab"="@j";"Select Next Tab"="@k";}'
plutil file.plist # same as `plutil -lint file.plist`
plutil -convert xml1 ~/Library/Preferences/org.videolan.vlc.LSSharedFileList.plist -o -|xml sel -t -v //string -
plutil -convert xml1 /System/Library/Frameworks/AppKit.framework/Resources/StandardKeyBinding.dict -o -|pl
pl -input xml.plist -output oldstyle.plist # plutil can convert the old-style format to XML but not XML to the old-style format
PlistBuddy -c 'Print AppleSelectedInputSources:0:"KeyboardLayout Name"' ~/Library/Preferences/com.apple.HIToolbox.plist
ruby -rplist -rpp -e 'pp Plist::parse_xml("/Library/Preferences/SystemConfiguration/com.apple.airport.preferences.plist")'
$(locate lsregister) -dump # show the contents of the Launch Services database
$(locate lsregister) -kill -domain local -domain system -domain user # rebuild the Launch Services database
defaults write com.apple.LaunchServices LSHandlers -array-add '{LSHandlerContentType=public.plain-text;LSHandlerRoleAll=org.gnu.Emacs;}'
sudo dave -u $USER # attempt cracking the hash of the login password
sudo dave -s $USER # show the hash data
sudo defaults read /var/db/dslocal/nodes/Default/users/$USER.plist ShadowHashData|tr -dc 0-9a-f|xxd -p -r|plutil -convert xml1 - -o - # show the hash data
defaults read -g AppleLocale # the region selected in System Preferences
PlistBuddy -c 'Print AppleLanguages:0' ~/Library/Preferences/.GlobalPreferences.plist # the primary language selected in System Preferences
PlistBuddy -c 'Print AppleLanguages:0' /Library/Preferences/.GlobalPreferences.plist # the language used in the login window
PlistBuddy -c 'Print AppleLanguages:0' /var/root/Library/Preferences/.GlobalPreferences.plist # used in the lock screen and when opening applications as root if set
sudo languagesetup # change the first item in AppleLanguages in /Library/Preferences/.GlobalPreferences.plist
sudo createinstallmedia --volume /Volumes/Untitled --applicationpath /Applications/Install\ OS\ X\ Mavericks.app --nointeraction # added in 10.9
sudo systemstats # show for example periods of peak I/O and memory activity, bytes read and written since last restart, and a list of USB devices (added in 10.9)
sudo powermetrics # show for example CPU package energy use and processes sorted by a weighted average of package idle wakeups and CPU use (added in 10.9)
wdutil # an alternative to Wireless Diagnostics.app (added in 10.9)
wdutil info # show information like the SSID, transfer rate, the number of paired Bluetooth devices, and the primary network interface
osascript -e'display notification "text" with title "title" subtitle "subtitle"' # added in 10.9
sudo memory-pressure -p 10 # allocate memory until there is 10% free memory (memory_pressure was added in 10.9)
mv /tmp/com.apple.Finder.plist ~/Library/Preferences/;killall cfprefsd;killall Finder # make Finder use the new plist in 10.9 (preferences are cached in 10.9)
mv /tmp/com.apple.Finder.plist ~/Library/Preferences/;defaults read com.apple.Finder;killall Finder # make Finder use the new plist in 10.9
lsappinfo listen +all forever # show when the frontmost application changes, when an application is opened, etc
lsappinfo listen +becameFrontmost forever # show when the frontmost application changes
lsappinfo list # show information like how long applications have been open and if applications are sandboxed
lsappinfo launch nofront=true launchandhide=true /Applications/TextEdit.app # an alternative to `open -gja TextEdit`
lsappinfo launch launchandhideothers=true /Applications/TextEdit.app # open TextEdit and hide other applications
lsappinfo visibleProcessList|cut -d\" -f4 # print the name of the second frontmost application
lsappinfo info -app TextEdit -only kLSLaunchTimeKey # show when TextEdit was opened
lsappinfo info -app TextEdit -only kLSApplicationIsHiddenKey # show if TextEdit is hidden
lsappinfo find ASN=$(lsappinfo front)|cut -d\" -f2 # an alternative to `osascript -e'name of app (path to frontmost application as text)'`
lsappinfo setinfo -app Safari ApplicationType=UIElement # remove Safari's menu bar and remove Safari from the Dock
lsappinfo setinfo -app TextEdit supressRelaunch=true # don't relaunch TextEdit after logging out and back in
open -a VirtualBox;lsappinfo setinfo -app VirtualBox kLSApplicationIsHiddenKey=true
kill $(lsappinfo info -app "$(lsappinfo front)" -only pid|cut -d= -f2)
set $(lsappinfo info -app "$(lsappinfo front)"|sed -n 's/^ *bundleID="\(.*\)"/\1/p;s/^ *pid = \([^ ]*\).*/\1/p');kill $2;open -b $1
/System/Library/CoreServices/Menu\ Extras/User.menu/Contents/Resources/CGSession -suspend # log out to the fast user switching screen
find /Volumes/WD \( -name .DS_Store -o -name ._\* \) -delete;sudo rm -rf /Volumes/WD/{.Spotlight-V100,.TemporaryItems,.Trashes,.fseventsd}
drutil eject # eject optical drives
sudo opensnoop -n cfprefsd # see what property lists are changed
open $(mdls -name kMDItemWhereFroms ~/Desktop/*.download|grep -o 'http[^"]*')
[[ $OSTYPE = darwin* ]]
gshuf -n10 notes/bookmarks.txt|xargs open
open dict://word # show the definition for a word in Dictionary.app
touch $'\xc3\xa4';printf *|xxd -p # 61cc88 (HFS+ stores characters in decomposed form)
touch $'\xc3\xa4';printf *|iconv -f utf-8-mac -t utf-8|xxd -p # c3a4
sudo discoveryutil mdnsflushcache # reset the DNS cache in 10.10
sudo killall -HUP mDNSResponder # reset the DNS cache from 10.7 to 10.9
sudo dscacheutil -flushcache # reset the DNS cache in 10.6 and earlier
cat /Applications/Safari.app/Contents/Resources/com.apple.safari.manifest/Contents/Resources/com.apple.safari.manifest # default settings
uname -r # Darwin version (12.4.0 corresponds to OS X version 10.8.4)
defaults -currentHost delete com.apple.loginwindow TALAppsToRelaunchAtLogin # don't reopen applications when logging out and back in
cat /usr/sbin/apachectl # apachectl is a shell script and `apachectl start` just runs `launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist`
sips -i icon.png;DeRez -only icns icon.png>icon.rsrc;Rez -append icon.rsrc -o folder/Icon$'\r' # `sips -i icon.png` adds icon.png as an icon for itself
DeRez -only icns folder/Icon$'\r'>icon.rsrc;Rez -append icon.rsrc -o folder2/Icon$'\r';SetFile -a C folder2;SetFile -a V folder2/Icon$'\r'
sudo defaults write com.apple.finder AppleShowAllFiles -bool true;sudo /System/Library/CoreServices/Finder.app/Contents/MacOS/Finder
ps -eco comm= # -c changes comm from the absolute path of a command to the command name in OS X
ps -p $(pgrep -x bash) # an alternative to `ps -C bash`
pgrep -a # include ancestor processes in OS X (the procps pgrep includes ancestor processes by default)
sample Finder 5 # sample Finder for 5 seconds
sudo sysdiagnose # save a diagnostic report to /var/tmp (you can also run sysdiagnose by pressing control-option-shift-command-.)
find ~/Music \( -name \*.pls -o -name \*.m3u \) -delete;find ~/Music -name \*.flac -o -name \*.ogg|parallel ffmpeg -i {} -aq 1 {.}.mp3\;rm {}
defaults write com.apple.symbolichotkeys AppleSymbolicHotKeys -dict-add 70 '<dict><key>enabled</key><false/></dict>' # disable the control-command-D shortcut
sudo ls $(find /var/folders/zz -user _locationd)/C/
mdfind kMDItemContentType=com.apple.xcode.strings-text|grep Japanese.lproj|while read l;do PlistBuddy -c Print "$l";done # find strings localized to Japanese
who -u|awk '{print$7}' # show the PID of loginwindow
echo add State:/Network/Interface/en0/RefreshConfiguration temporary|sudo scutil # renew a DHCP lease
scutil --dns # show the DNS configuration
dscacheutil -q host -a name www.apple.com # perform a DNS lookup (nslookup, host, and dig don't check /etc/hosts or resolve .local names)
dscacheutil -q user # list users
grep 'BSD process name' /Library/Logs/DiagnosticReports/*.panic # see what processes have caused kernel panics
cat "$(ls -dt ~/Library/Logs/DiagnosticReports/*|head -n1)" # show the newest crash report
sharing -a ~/folder # add a folder to shared folders
ls /.vol/$(stat -f%d $HOME)/$(stat -f%i ~/Documents) # %d is device ID and %i is inode number
printf %s\\n /Applications/*.app/Contents/_MASReceipt # list applications downloaded from the App Store
macruby -e 'framework "Cocoa";NSWorkspace.sharedWorkspace.setIcon(NSImage.alloc.initWithContentsOfFile("/tmp/a.png"),forFile:"/tmp/dir/",options:0)'
open -a ScreenSaverEngine # start a screensaver
sudo /usr/libexec/locate.updatedb # update the locate database (like the updatedb command on other platforms)
alias locate='find /var/db/locate.database -mtime -10d -exec sudo /usr/libexec/locate.updatedb \;;locate'
rm ~/Library/Fonts/**/{fonts.dir,encodings.dir,fonts.list,fonts.scale} # delete X11 font metadata files
/Applications/Calendar.app/Contents/MacOS/Calendar -AppleLanguages '(de)' # open Calendar with the language temporarily set to German
defaults write -app Calendar AppleLanguages -array de;open -a Calendar # change the default language for Calendar to German
cd /Applications;cp -a iTerm.app MyiTerm.app;defaults write MyiTerm.app/Contents/Info CFBundleIdentifier my.iterm # make a copy of iTerm that uses different preferences files
defaults read /System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/Exceptions.plist # see what applications are forced to quarantine files
tccutil reset AddressBook # reset the list of applications that are allowed to access contacts
xcrun swift # start a Swift REPL
xattr -cr .;chmod -NR . # delete extended attributes and ACLs in the directory tree
rm /var/folders/*/*/*/com.apple.dock.iconcache;killall Dock
cd ~/Library/Caches/Metadata/Safari/History;ls -t|head -n100|xargs mdls -n kMDItemURL
plutil -convert json -o - ~/Library/Safari/History.plist|jq -r '.WebHistoryDates[]|.lastVisitedDate+" "+.[""]'|sort -rn|head
plutil -convert json /Applications/Safari.app/Contents/Info.plist -o -|jq -r '.CFBundleDocumentTypes[].CFBundleTypeExtensions[]'
while sleep 1;do [[ $(ioreg -c IOHIDSystem|awk '/HIDIdleTime/{print$NF/1000000000;exit}'|awk '$0>3') && $(lsappinfo visibleProcessList|cut -d\" -f2) = iTerm ]]&&say a;done
grep PS1= /etc/bashrc # PS1='\h:\W \u\$ '
sleep 300;osascript -e'display notification "" with title "a"'
sudo systemstats|egrep 'Total Time|User Active' # see how often you use your computer actively
osascript -e'set text item delimiters to linefeed' -e 'tell app "safari" to url of tabs of window 1 as text'|awk 'NR==FNR{a[$0];next}!($0 in a)' - ~/notes/toread|sponge ~/notes/toread
echo "osascript -e'display notification \"\" with title \"a\"'"|at '11:59pm 31.12'
rm ~/torrents/**/.DS_Store;find ~/torrents -type d -empty -delete
printf %s\\n {1..10}.pdf|tail -r|while read l;do open "$l";done
afplay "$(printf %s\\n ~/Music/dir/**/*.mp3|gshuf -n1)"
osascript -e'set text item delimiters to linefeed' -e 'tell app "google chrome" to url of tabs of window 1 as text'|xargs open -a safari
mkfile 10k file # like `dd if=/dev/zero bs=10480 of=file`
stat -f'%N %z %Su %Sm %SB' # name, size in bytes, username, modification time, and creation time (birth time)
for f in *;do d=/tmp/$(stat -f%Sm -t%Y-%m $f);mkdir -p $d;mv $f $d;done
find . -exec stat -f '%m %N' {} +|sort -n|tail -n1 # the modification time and name of the newest file
for d in *;do find "$d" -exec stat -f "%m $d" {} +|sort -n|tail -n1;done|sort -n
cksum -o3 # crc32 in BSD cksum (coreutils cksum doesn't have -o)
for f in *.mp4;do mv "$f" "${f%.*} [$(cksum -o3 "$f"|awk '{printf "%08X",$1}')].mp4";done
printf a>file;md5 file # MD5 (file) = 0cc175b9c0f1b6a831c399e269772661
printf a>file;md5 -r file # 0cc175b9c0f1b6a831c399e269772661 file
printf a>file;md5 -q file # 0cc175b9c0f1b6a831c399e269772661
md5 -qs a # 0cc175b9c0f1b6a831c399e269772661
export CLICOLOR= LSCOLORS=dxfxcxdxbxegedabagacad # use colors with BSD ls (GNU ls uses LC_COLORS)
brew update;brew upgrade # update Homebrew and upgrade formulas
brew update;brew upgrade emacs # update Homebrew and upgrade the emacs formula
brew cleanup # remove archive files, symlinks, and old versions of formulas
brew doctor # check for potential sources of errors like unlinked formulas
brew search id3 # search for formulas whose name contains id3
brew search|wc -l # see how many formulas are available from Homebrew (about 3000 in 2014 if tapped formulas are not counted)
find /usr/local/bin ! -lname ../Cellar/\* # find non-Homebrew binaries in /usr/local/bin
brew install coreutils findutils gawk gnu-sed gnu-tar wget
ls /usr/local/opt/coreutils/libexec/gnubin
man /usr/local/opt/coreutils/libexec/gnuman/man1/*
MANPATH=/usr/local/opt/coreutils/libexec/gnuman:$MANPATH
brew install homebrew/dupes/grep --default-names # install GNU grep with the name grep instead of ggrep
find /usr/local/bin -mtime -10d
brew info ffmpeg # show flags, dependencies, etc
brew unlink ruby;brew link ruby # add missing symlinks for binaries included with Ruby gems
brew list --verbose gawk # list the files installed for the gawk formula
brew deps ffmpeg # show dependencies for ffmpeg
brew deps --installed # show dependencies for all installed formulas
brew install gcc47 gdb # install gcc and gdb (they were removed from Xcode in Xcode 5)
brew tap phinze/cask;brew install brew-cask;brew cask install sequential # install Sequential
for x in $(ls /usr/local/Library/LinkedKegs);do brew unlink $x;brew link $x;done # relink kegs
ln -s /usr/local/opt/moreutils/bin/!(parallel) /usr/local/bin
sudo gem install terminal-notifier;terminal-notifier -title title -message ''
terminal-notifier -title title -message '' -group someid;sleep 5;terminal-notifier -remove someid # display a notification for 5 seconds
brew install unar;unar *.zip *.rar *.gz *.iso *.pkg # extract archives (unar is a command line version of The Unarchiver)
unar -p '' # skip archives that require a password
unar -s # skip an archive if a file to be extracted already exists
webkit2png -F http://example.com # -F saves only the full size image
webkit2png -C -s 1 -W 1000 -H 1000 --clipwidth 1000 --clipheight 1000 http://example.com # -C saves only the clipped image and `-s 1` sets the scale to 100%
brew install imagesnap;i=1;while :;do imagesnap $((i++)).png;done # save images from a webcam
wget https://raw2.github.com/chbrown/scripts/master/click.m;gcc -o click click.m -framework ApplicationServices -framework Foundation;./click -x 1000 -y 500
MouseTools -x 1900 -y 60;sleep 1;MouseTools -leftClickNoRelease;MouseTools -releaseMouse
brew install trash;trash *.txt
sudo gem install wkpdf;wkpdf -s http://example.com -o example.pdf
dialog=$(CocoaDialog standard-inputbox --title title --text text --float);[[ ${dialog:0:1} = 2 ]]&&exit;answer=${dialog:2} # display a single line text dialog
CocoaDialog textbox --editable --title Title --button1 OK --button2 Cancel # display a multi-line text dialog
cscreen -i 1234567 -p # make screen id 1234567 the primary screen
git clone https://github.com/pufuwozu/toggle-osx-shadows.git;cd toggle-osx-shadows;make;./toggle-osx-shadows # disable shadows (like ShadowKiller)
brew install coreutils;gdate +%s.%N # show time with nanoseconds
brew install daemontools;echo|tai64n|tai64nlocal # show time with nanoseconds
brew install duti;echo 'net.sourceforge.skim-app.skim .pdf all'>~/.duti;duti ~/.duti # make Skim the default application for PDF files
~/Library/PreferencePanes/RCDefaultApp.prefPane/Contents/Resources/lstool uti com.adobe.pdf Skim # make Skim the default application for PDF files
brew install blueutil;blueutil|grep -q 'Power: 1';blueutil power $? # toggle Bluetooth
tag -l file # list tags
tag -a red file # add a tag
tag -s red,blue file # set tags
tag -r \* file # remove all tags
tag -f green # find files with the green tag
tag -f \* # find files with tags
brew cask install slate;echo 'bind m:cmd move screenOriginX;screenOriginY screenOriginX+screenSizeX;screenOriginY+screenSizeY'>~/.slate;open -a slate
NoSleepCtrl -a -b -s 1,1 # don't put a laptop to sleep when the lid is closed
/usr/libexec/java_home # print the path of the Java home directory (like /Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home)
sqlite3 ~/Library/Application\ Support/Google/Chrome/Default/History 'select urls.url from urls'
printf "\e]1337;File=inline=1:$(base64</tmp/a.png)\a\n" # display an image in iTerm 2.9 or later
qlmanage -x -t input.png -s 500 -o /tmp>/dev/null # resize an image (-t generates a thumbnail, -x uses qlmanage, and -o specifies an output directory)