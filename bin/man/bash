Alt + "." 
Pastes the argument of the recent command executed on the shell.

For e.g.
If we do 
#ls -ld /tmp
then 
if we do 
# cd (then press ALT key with fullstop)
/tmp will appear as an argument for cd command.


---
layout: post
title: "Useful Bash Commands"
author:
modified:
comments: true
categories: linux/commandsoftheday
excerpt: "Most useful Linux/Unix Commands, A collection of commands which can save lot's of our typing time."
tags: [Linux, CommandLine, CommandOfTheDay, Bash]
image:
  feature:
date: 2015-07-07T13:16:28+05:30
---


{% include _toc.html %}

**NOTE!**: If you feel some commands are missing in this post,<br>
Feel free to add those commands in below comments box.
{: .notice}

#### Shortcuts
<pre>
/---------------------------------------------------------------------------------------\
|	!!	Repeat last command							|
|	!char	Repeat last command That started with char				|
|	!num	Repeat a command by its number in history output			|
|										        |
|	!-n	Repeat a command entered n command back					|
|	!?abc	Repeat last command that contains (as opposed to ?started with?) abc    |
\---------------------------------------------------------------------------------------/
</pre>
<pre>
/---------------------------------------------------------------\
|	UP DOWN Keys	Scroll through previous commands	|
|	Ctrl+r		Reverse-i-search		  	|
\---------------------------------------------------------------/
</pre>

#### Clear Terminal
{% highlight bash %}
# Linux/Unix OS
$ <CTRL+l>
# MAC OS
# The following keys not just clear screen but also clear Terminal buffer
# After <COMMAND+k> you can't able to view previous buffer
$ <COMMAND+k>
{% endhighlight %}

#### Run Previous Command With Root/Sudo Privilege
{% highlight bash %}
$ sudo !!
{% endhighlight %}

#### Run Previous Command With Search/Replace For First Instance
{% highlight bash %}
$ echo "Hello Mitesh, Hello Shah, Hello Visitor"
Hello Mitesh, Hello Shah, Hello Visitor
$ ^Hello^Hi
$ echo "Hi Mitesh, Hello Shah, Hello Visitor"
Hi Mitesh, Hello Shah, Hello Visitor
{% endhighlight %}

#### Run Previous Command With Search/Replace For All The Instance
{% highlight bash %}
$ echo "Hello Mitesh, Hello Shah, Hello Visitor"
Hello Mitesh, Hello Shah, Hello Visitor
$ !!:gs/Hello/Hi
$ echo "Hi Mitesh, Hi Shah, Hi Visitor"
Hi Mitesh, Hi Shah, Hi Visitor
{% endhighlight %}

#### Execute Command Without Saving in History

* Prepending one or more spaces to your command won't be saved in history.
{% highlight bash %}
$ <SPACE><COMMAND>
{% endhighlight %}

**NOTE!**: `HISTCONTROL=ignorespace` will ignore just the commands that begin with a space.<br>
Use `HISTCONTROL=ignoreboth` if you also want to ignore duplicates.
{: .notice}

#### Paste Last Argument of Most Recent Command
<pre>
/-----------------------------------------------------------------------\
|	Esc .		The escape key followed by a period.		|
|	Alt+.		Hold down alt key while pressing the period.	|
|	!$		Only valid for last argument			|
\-----------------------------------------------------------------------/
</pre>

{% highlight bash %}
$ cp -v index.html /home/mitesh/shah/miteshshah.github.io/index.html
# Using ALT Dot
$ cd <ALT+.>
$ cd /home/mitesh/shah/miteshshah.github.io/index.html
# Using Esc Dot
$ cd <ESC+.>
$ cd /home/mitesh/shah/miteshshah.github.io/index.html
# Using !$
$ cd !$
$ cd /home/mitesh/shah/miteshshah.github.io/index.html
{% endhighlight %}

#### Paste Selected Argument

* This comes in handy when you've written a long command with multiple arguments and you want to reuse one of them.
{% highlight bash %}
# Use Only 3rd Argument
$ echo a b c d e
a b c d e
$ echo !:3
echo c
c

# Used 1-3 Argument Only
$ echo a b c d e
a b c d e
$ echo !:1-3
echo a b c
a b c

# If you leave off the first digit and just start with `!:-`
# then you'll include argument 0, which is the previous command.
$ echo a b c d e
a b c d e
$ echo !:-3
echo echo a b c
echo a b c
{% endhighlight %}

#### Reset Terminal

* Sometime we send binary output to the terminal, Which make terminal not useable.
* The `reset` command reset your terminal, Note that when you type reset its won't properly echo back on terminal.
{% highlight bash %}
$ reset
{% endhighlight %}

#### Display Mount Filesystem in Nice Layout
{% highlight bash %}
$ mount | column -t
/dev/root  on  /                         type  ext4         (rw,relatime,errors=remount-ro,data=ordered)
devtmpfs   on  /dev                      type  devtmpfs     (rw,relatime,size=4037132k,nr_inodes=1009283,mode=755)
none       on  /dev/pts                  type  devpts       (rw,nosuid,noexec,relatime,mode=600)
none       on  /proc                     type  proc         (rw,nosuid,nodev,noexec,relatime)
none       on  /sys                      type  sysfs        (rw,nosuid,nodev,noexec,relatime)
none       on  /proc/sys/fs/binfmt_misc  type  binfmt_misc  (rw,nosuid,nodev,noexec,relatime)
none       on  /sys/fs/fuse/connections  type  fusectl      (rw,relatime)
none       on  /sys/kernel/security      type  securityfs   (rw,relatime)
none       on  /run                      type  tmpfs        (rw,nosuid,noexec,relatime,size=807520k,mode=755)
none       on  /run/lock                 type  tmpfs        (rw,nosuid,nodev,noexec,relatime,size=5120k)
none       on  /run/shm                  type  tmpfs        (rw,nosuid,nodev,relatime)
{% endhighlight %}

#### ASCII Table
{% highlight bash %}
$ man ascii
{% endhighlight %}

#### Compare Remote File with Local File
{% highlight bash %}
$ ssh USERNAME@HOSTNAME cat /path/to/remotefile | diff /path/to/localfile -
{% endhighlight %}


#### Decide Which Command Run On Success and Fail
{% highlight bash %}
$ cal && echo "Right Command" || echo "Wrong Command"
July 2015
Su Mo Tu We Th Fr Sa  
     1  2  3  4  
5  6  7  8  9 10 11  
12 13 14 15 16 17 18  
19 20 21 22 23 24 25  
26 27 28 29 30 31

Right Command

$  call && echo "Right Command" || echo "Wrong Command"
No command 'call' found, did you mean:
 Command 'wall' from package 'bsdutils' (main)
 Command 'calc' from package 'apcalc' (universe)
 Command 'cal' from package 'bsdmainutils' (main)
call: command not found

Wrong Command
{% endhighlight %}

#### Execute Command After Every 2 Seconds

{% highlight bash %}
$ watch -d df -h
Every 2.0s: df -h                                                                                                                      Tue Jul  7 13:52:39 2015

Filesystem      Size  Used Avail Use% Mounted on
rootfs          500G  250G  250G  50% /
/dev/root       500G  250G  250G  50% /
devtmpfs        3.9G  4.0K  3.9G   1% /dev
none            789M  165M  625M  21% /run
none            5.0M     0  5.0M   0% /run/lock
none            3.9G     0  3.9G   0% /run/shm
{% endhighlight %}

### Check Last Command Status

* If command run Successfully then exit status is zero
* If command doesn't run Successfully then exit status is non-zero
{% highlight bash %}
$ cal ; echo $?
$ call ; echo $?
{% endhighlight %}



---
layout: post
title: "How to Change Bash Custom Prompt (PS1)"
author:
modified:
comments:
categories: linux/commandsoftheday
excerpt: "How to change bash custom prompt and make it more usable. Think when you enter wrong command your bash prompt turn into RED."
tags: [Linux, CommandLine, CommandOfTheDay, PS1]
image:
  feature:
date: 2015-06-25T16:33:54+05:30
---

{% include _toc.html %}

* Most of our work on shell prompt.
* By Default, `PS1` is little bit boring.
* I'll show you how to add useful information on your shell prompt

### Alert Prompt (PS1)

* Alert Prompt (PS1) change your shell color to RED when your previous command exit status is non zero.

{% highlight bash %}
[root@miteshshah.github.io ~]# PS1="\`if [ \$? = 0 ]; then echo \[\e[34m\]^_^[\u@\h:\w]\\$\[\e[0m\]; else echo \[\e[31m\]O_O[\u@\h:\w]\\$\[\e[0m\]; fi\` "
{% endhighlight %}

<img src="https://cloud.githubusercontent.com/assets/1223371/8353379/d71ee752-1b5a-11e5-9017-fd449fc57b73.png">

### Display Date and Time
{% highlight bash %}
[root@miteshshah.github.io ~]# PS1='\[\033[0;32m\]┌──\[\033[0;36m\]\u@\h\[\033[0m\033[0;32m\]─┤├─ \[\033[0m\]\t \d\[\033[0;32m\] ─┤├─ \[\033[0;31m\]\w\[\033[0;32m\] ─┤ \n\[\033[0;32m\]└──▶ \$\[\033[0m\] '
┌──root@miteshshah─┤├─ 11:18:43 Thu Jun 25 ─┤├─ ~ ─┤
└──▶ #
{% endhighlight %}

### Generate Prompt Online

* By using <a href="http://bashrcgenerator.com/"> http://bashrcgenerator.com/</a> you can generate your prompt easily.

**NOTE!**: For more detailed information use `man bash` and search for PROMPTING.
{: .notice}




---
layout: post
title: "Bash & Shell Scripting"
comments: true
modified:
categories: linux/basics
excerpt: "Newbie Guide - BASH & Shell Scripting"
tags: [Linux, BASH, Shell Scripting]
image:
  feature:
date: 2015-05-23T20:57:28+05:30
---

{% include _toc.html %}

### Command Line Shortcuts

#### File Globbing
* Globbing is a wildcard expansion.
* `*` matches zero or more characters.
* `?` matches any single characters.
* `[0-9]` matches a range of numbers.
* `[abc]` matches any of the characters in the list.
* `[^abc]` matches all except the characters in the list.
* Predefined character classes can be used.
* The syntax for a character classes is `[:keyword:]`, where keyword can be - alpha, upper, lower, digit, alnum, punct, space.

**Examples:**
{% highlight bash %}
[mitesh@Matrix work]$ ls
123.doc  abc.txt  file1  file name.txt  jkL.txt
456.doc  Def.txt  file2  Ghi.txt        MnO.txt

[mitesh@Matrix work]$ echo *.txt
abc.txt Def.txt file name.txt Ghi.txt jkL.txt MnO.txt

[mitesh@Matrix work]$ echo *.doc
123.doc 456.doc

[mitesh@Matrix work]$ echo [[:upper:]]*
Def.txt Ghi.txt MnO.txt

[mitesh@Matrix work]$ echo ??[[:upper:]]*
jkL.txt MnO.txt

[mitesh@Matrix work]$ echo *[[:space:]]*
file name.txt

[mitesh@Matrix work]$ echo [[:digit:]]*
123.doc 456.doc

[mitesh@Matrix work]$ echo [^[:digit:]]*
abc.txt Def.txt file1 file2 file name.txt Ghi.txt jkL.txt MnO.txt

[mitesh@Matrix work]$ echo [[:lower:]]?[[[:upper:]]*
jkL.txt
{% endhighlight %}

#### The Tab Key

* Type Tab to complete command lines
* For the command name, it will complete a command name.
* For an argument, it will complete a file name.

**Examples:**
{% highlight bash %}
[mitesh@Matrix work]$ ls
dove  eagle  myfile.txt  pelican  penguin
{% endhighlight %}

<pre>
/---------------------------------------------------------------------------------------\
|	Input   |     1st Tab           |       2nd Tab 				|
|---------------------------------------------------------------------------------------|
|               |                       |   Display all commands                        |
|	ca      |		        |   List all commands that start with ca	|
|	dat     |	date            |	                                	|
|---------------------------------------------------------------------------------------|
|	cat d   |	cat dove        |                                               |
|	cat m   |	cat myfile.txt  |			                        |
|	cat p   |	cat pe          |   List all possible file names		|
\---------------------------------------------------------------------------------------/
</pre>

#### History
* Bash stores a history of commands you've entered.
* Use `history` command to see list of REMEMBERED commands.

<pre>
/---------------------------------------------------------------------------------------\
|	!!	Repeat last command							|
|	!char	Repeat last command That started with char				|
|	!num	Repeat a command by its number in history output			|
|										        |
|	!-n	Repeat a command entered n command back					|
|	!?abc	Repeat last command that contains (as opposed to ?started with?) abc    |
\---------------------------------------------------------------------------------------/
</pre>
<pre>
/---------------------------------------------------------------\
|	UP DOWN Keys	Scroll through previous commands	|
|	Ctrl+r		Reverse-i-search		  	|
\---------------------------------------------------------------/
</pre>

#### To recall last argument from previous command
<pre>
/-----------------------------------------------------------------------\
|	Esc .		The escape key followed by a period.		|
|	Alt+.		Hold down alt key while pressing the period.	|
|	!$		Only valid for last argument			|
\-----------------------------------------------------------------------/
</pre>

* Use `^old^new` to repeat the last command with old changed to new.

{% highlight bash %}
[mitesh@Matrix ~]$ cp filter.c /usr/local/src/project
[mitesh@Matrix ~]$ ^filter^frontend
cp frontend.c /usr/local/src/project
{% endhighlight %}

* You can ignore repeated duplicate commands and repeated lines that only differ in prepended spaces by running the following command below, or by adding it to your `.bashrc` file.

{% highlight bash %}
[mitesh@Matrix ~]$ export HISTCONTROL=ignoreboth
{% endhighlight %}

**NOTE!**: `HISTCONTROL=ignorespace` will ignore just the commands that begin with a space.<br>
Use `HISTCONTROL=ignoreboth` if you also want to ignore duplicates.
{: .notice}


### Command Line Expansion

#### The Tilde

* Tilde (~) refers to home directory.
* Tilde (~) is useful in environment where home directories exist in non-standard locations.

**Examples:**
{% highlight bash %}
[mitesh@Matrix ~]$ cat ~/.bash_history
[mitesh@Matrix ~]$ cat ~neo/.bash_profile
[mitesh@Matrix ~]$ ls ~julie/public_html
{% endhighlight %}

#### Command Substitution
* Use of the backquotes is called command substitution.
* An alternative syntax of backquotes is to place the command in parentheses preceded by a dollar sign `$()`.

**Examples:**
{% highlight bash %}
[mitesh@Matrix ~]$ echo "The system name is `hostname`"
The system name is Matrix
[mitesh@Matrix ~]$ echo "The system name is $(hostname)"
The system name is Matrix
{% endhighlight %}

#### Brace Expansion
* Shorthand for printing repetitive strings.

**Examples:**
{% highlight bash %}
[mitesh@Matrix ~]$ echo file{1,2,3}
file1 file2 file3

[mitesh@Matrix ~]$ echo file{1..5}
file1 file2 file3 file4 file5

[mitesh@Matrix ~]$ rm -rf file{1..5}

[mitesh@Matrix ~]$ mkdir -p work/{inbox,outbox,pending}/{normal,urgent,important}
{% endhighlight %}


### Bash Variables

* Variables are named values useful for storing data or commands output.
* Set with
`VARIABLE=VALUE`
* Referenced with `$VARIABLE`

**Examples:**
{% highlight bash %}
[mitesh@Matrix ~]$ HI="Hello, and welcome to $(hostname)"
[mitesh@Matrix ~]$ echo $HI
Hello, and welcome to Matrix

[mitesh@Matrix ~]$ FILES=$(ls /etc)
[mitesh@Matrix ~]$ echo $FILES
abrt acpi adjtime aliases aliases.db alsa alternatives anacrontab anthy-conf asound.conf at.deny audisp audit autofs_ldap_auth.conf
...output truncated...
{% endhighlight %}

**NOTES!:** Bash recognizes that you are trying to set a variable when it sees the pattern `text=text`. Note that there can be no spaces on either side of the = or you will get an error.
{: .notice}

### Command Editing Tricks
<pre>
/---------------------------------------------------------------\
|	Ctrl+a		Moves to beginning of the line		|
|	Ctrl+e		Moves to end of the line		|
|	Ctrl+u		Deletes to beginning of the line	|
|	Ctrl+k		Deletes to end of the line		|
|	Ctrl+Arrow	Moves left or right by word		|
\---------------------------------------------------------------/
</pre>

### Gnome Terminal

* Accessed via Applications -> Accessories -> Terminal
* Graphical Terminal supports multiple tabbed shells.
<pre>
/-----------------------------------------------------------------------\
|	Ctrl+Shift+t		Creates a new tab			|
|	Ctrl+Shift+c		Copies selected text			|
|	Ctrl+Shift+v		Paste text				|
|	Ctrl+PgUp/Pgdn		Switches to next/previous tab		|
|	Shift+PgUp/PgDn		Scroll up and down a screen at a time	|
\-----------------------------------------------------------------------/
</pre>

### Scripting Basics

* A shell script is simply a text file containing a series of commands or statements to be executed.
* Shell scripts are useful for
  1. Automating commonly used commands.
  2. Performing a system administration and troubleshooting.
  3. Creating simple applications.
  4. Manipulation of text or files.

#### Creating Shell Script
* Comments start with a `#`
* First line contains the Magic Shebang Sequence `#!`
* This tells the operating system which interpreter to use in order to execute the script.
{% highlight bash %}
#!/bin/bash
#!/bin/sh
#!/bin/csh
#!/usr/bin/perl
#!/usr/bin/python
{% endhighlight %}

* Make the script executables
{% highlight bash %}
[mitesh@Matrix ~]$ chmod u+x myscript.sh
[mitesh@Matrix ~]$ chmod 750 myscript.sh
{% endhighlight %}

* Ensure that the script is located in a directory listed by the `PATH` environmental variable.
* To do this enter the following command
{% highlight bash %}
[mitesh@Matrix ~]$ echo $PATH
/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/mitesh/bin
{% endhighlight %}

* If the script is not in a directory listed in the `PATH` variable, either move the script to a directory that is (such as `$HOME/bin`) or specify the absolute or relative path on the command line when executing the script

{% highlight bash %}
[mitesh@Matrix ~]$ /home/mitesh/mytestscript.sh
[mitesh@Matrix ~]$ cd /home/mitesh
[mitesh@Matrix ~]$ ./mytestscript.sh
{% endhighlight %}

#### First Shell Script
{% highlight bash %}
#!/bin/bash
# This script displays some information about your environment


echo "Greetings. The date and time are $(date)"
echo "Your working directory is: $(pwd)"

[mitesh@Matrix ~]$ chmod u+x info.sh
[mitesh@Matrix ~]$ ls -l info.sh
-rwxrw-r--. 1 mitesh mitesh 165 May 23 20:00 info.sh

[mitesh@Matrix ~]$ ./info.sh
[mitesh@Matrix ~]$ ~/info.sh
[mitesh@Matrix ~]$ /home/mitesh/info.sh
Greetings. The date and time are Sat May 23 20:02:20 IST 2015
Your working directory is: /home/mitesh
{% endhighlight %}

> "~" does not refer to the home directory; ~ does.

Not able to find where i was used "~".

> echo $HI

Again tested and get same content which include whitespace, but agree with you whenever we want to display wildcard, whitespace we should use "". I think that also cover in some of Linux Basic article.

> $(pwd); use $PWD.

Can you explain little bit more what's difference between that two.

Also feel free to edit whenever you feel you can find edit button just after the share buttons ( Bash & Shell Scripting was published on May 23, 2015 .)



Tilde (~) is the first item under "Command Line Expansion".

Note the difference in output between the echo commands:

HI=' ab cd ef ' ## Note: Put 2 spaces between each "word"
echo $HI:
echo "$HI:"

$(pwd) uses command substitution; $PWD is a variable. Command substitution is orders of magnitude slower than a simple variable reference.


---
layout: post
title: "Standard IO & Pipes"
comments: true
modified:
categories: linux/basics
excerpt: "Newbie Guide - Standard Input/Output & Pipes"
tags: [Linux, Standard IO, Pipes]
image:
  feature:
date: 2015-05-23T23:20:24+05:30
---
{% include _toc.html %}

### Standard Input and Output

* Linux provides three I/O channels to the programs.
  1. Standard Input  (STDIN),	File Descriptor Number 0,	By Default Keyboard
  2. Standard Output (STDOUT),	File Descriptor Number 1,	By Default Screen or Terminal Window
  3. Standard Error  (STDERR),	File Descriptor Number 2,	By Default Screen or Terminal Window

**Syntax:**
{% highlight bash %}
command operator filename
{% endhighlight %}



#### Supported Operators
* \>	Redirect STDOUT to File
* 2>	Redirect STDERR to File
* &>	Redirect All Output (STDOUT and STDERR)

**NOTE!:** File contents are overwritten by default. Use >\> to appends.
{: .notice}
<br>

### Redirecting Output to File

* STDOUT and STDERR can be redirected to files.

**Examples:**
<pre>
* command < file                Send file as a Input to the command.
* command > file		Redirect STDOUT of command to file.
* command >> file		Append STDOUT of command to file.
* command 2> file		Redirect STDERR of command to file.
* command 2>> file    	        Append STDERR of command to file.
</pre>



Run the following command as a non-root user
{% highlight bash %}
[mitesh@Matrix ~]$ find /etc -name passwd
find: `/etc/dhcp': Permission denied
find: `/etc/lvm': Permission denied
/etc/passwd
...output truncated...
{% endhighlight %}

Note what happens when the same command is run but STDOUT is redirected to a file
{% highlight bash %}
[mitesh@Matrix ~]$ find /etc -name passwd > find.out
find: `/etc/dhcp': Permission denied
...output truncated...

[mitesh@Matrix ~]$ cat find.out
/etc/passwd
/etc/pam.d/passwd
{% endhighlight %}

**NOTE!:** The STDOUT and STDERR are distinct, Redirecting one does not affect the other.
{: .notice}

<br>
The following command would redirect STDERR to a file
{% highlight bash %}
[mitesh@Matrix ~]$ find /etc -name passwd 2> find.err
/etc/passwd
/etc/pam.d/passwd
{% endhighlight %}

* The above command only show the STDOUT of the command.
* If you really do not care about the errors then why you waste a file (find.err)?
* There is a special file on your system that is very useful in this sort of situation, `/dev/null`.
* `/dev/null` is a black hole for data. Anything sent to is simply ignored.


#### Display only STDOUT
{% highlight bash %}
[mitesh@Matrix ~]$ find /etc -name passwd 2> /dev/null
/etc/passwd
/etc/pam.d/passwd
{% endhighlight %}

#### Store STDOUT but ignore STDERR
{% highlight bash %}
[mitesh@Matrix ~]$ find /etc -name passwd > find.out 2> /dev/null
{% endhighlight %}

Guess what happen when run the following command
{% highlight bash %}
[mitesh@Matrix ~]$ find /etc -name passwd > find.out 2> find.err
[mitesh@Matrix ~]$ find /etc -name passwd >> find.out 2>> find.err
{% endhighlight %}


### Redirecting Output to Program
* Linux and UNIX provides many small utilities that perform one task very well.
* A core design feature of Linux and UNIX is that the output of one command can be fed directly as a input for another command.
* Pipes can connect the commands.
{% highlight bash %}
command1 | command2
command1 | command2 | command3...
{% endhighlight %}

**NOTE!:** STDERR is not forwarded across the pipes.
{: .notice}
<br>
**Examples:**
{% highlight bash %}
[mitesh@Matrix man]$ pwd
/usr/share/man

[mitesh@Matrix man]$ ls -C | tr 'a-z' 'A-Z'
MAN1 MAN2 MAN3 MAN4 MAN5 MAN6 MAN7 MAN8 MAN9 MAIN PT_BR TMAC.H WHATIS
{% endhighlight %}

In the above example, All the lower case letters are converted to upper case letters
<br><br>
**less - View input one page at a time**
{% highlight bash %}
[mitesh@Matrix ~]$ ls -l /etc | less
Note: Input can be searched with /
{% endhighlight %}

**mail - Send input via email**
{% highlight bash %}
[mitesh@Matrix ~]$ echo "Test Email" | mail -s "Testing Mail" user@example.com
{% endhighlight %}

**lpr - Send input to a printer**
{% highlight bash %}
[mitesh@Matrix ~]$ echo "Test Printer" | lpr
[mitesh@Matrix ~]$ echo "Test Printer" | lpr -P printer_name
{% endhighlight %}



### Redirecting All Output

* Some operators affect both STDOUT and STDERR
* `&>` Redirect All Output (STDOUT and STDERR)
{% highlight bash %}
[mitesh@Matrix ~]$ find /etc -name passwd &> find.all
{% endhighlight %}

#### Redirecting I/O Channels to Each Other

* Run the following command as a non-root user:
{% highlight bash %}
[mitesh@Matrix ~]$ find /etc -name passwd | less
{% endhighlight %}

* You will find that while STDOUT is display through less, STDERR is not.
* This is because a pipe only redirect STDOUT.
* If you wanted to send all output to less you would needed to redirect STDERR to STDOUT first.
* You can redirect one I/O channel to another using `>` and the channel's file descriptor numbers.

**For Example:**
{% highlight bash %}
[mitesh@Matrix ~]$ find /etc -name passwd 2>1
{% endhighlight %}
* The above command simply redirect all STDERR to a file called 1 rather than to file descriptor 1 (STDOUT).
* To tell your shell that you are referring to a file descriptor, prepend the `&`

**For Example:**
{% highlight bash %}
[mitesh@Matrix ~]$ find /etc -name passwd 2>&1 | less
{% endhighlight %}

### Combining Outputs

* Suppose you wanted to run two command back to back and send their output through the pipe.

**For Example:**
{% highlight bash %}
[mitesh@Matrix ~]$ cal 2014; cal 2015 | lpr
{% endhighlight %}
* The output of these commands, you would find that only the calendar for 2015 was printed, while the calendar for 2014 went to the screen

* This can be overcome by running the cal command in a subshell.
{% highlight bash %}
[mitesh@Matrix ~]$ (cal 2011; cal 2012) | lpr
{% endhighlight %}

### Redirecting to Multiple Target

**Syntax:**
{% highlight bash %}
command1 | tee filename | command2
{% endhighlight %}
* Stores STDOUT of command1 in filename, then pipes to command2

**Uses:**

* Troubleshooting complex pipelines.
* Simultaneous viewing and logging of output

**Examples:**
{% highlight bash %}
[mitesh@Matrix ~]$ ls -lR /etc | tee stage1.out | sort | tee stage2.out | uniq -c | tee stage3.out | sort -r | tee stage4.out | less
[mitesh@Matrix work]$ generate_report.sh | tee report.txt
{% endhighlight %}

### Redirecting STDIN from a file
* Redirect STDIN with `<`

**Examples:**
{% highlight bash %}
[mitesh@Matrix work]$ tr 'A-Z' 'a-z' < .bash_profile
[mitesh@Matrix work]$ cat .bash_profile | tr 'A-Z' 'a-z'

[mitesh@Matrix work]$ cat filename.txt
Hello, World!
[mitesh@Matrix work]$ cat < filename.txt
Hello, World!
{% endhighlight %}

### Sending Multiple Lines to STDIN
* Redirect Multiple line from keyboard to STDIN with <\<WORD
* All text untill WORD is sent to STDIN.
* Sometimes called heretext

**Example:**
{% highlight bash %}
[mitesh@Matrix work]$ mail -s "Please call" jane@example.com <<END
> Hi Jane,
>
> Please give me a call when you get in. We may need to do some maintenance on server1.
>
> Details when you're on-site,
> Boris
> END
{% endhighlight %}

### For Loop - Shell Scripting
* Performs actions on each member of a set of values.

**Syntax:**
{% highlight bash %}
for variable in value1 value2...
do
  command using $variable
done
{% endhighlight %}

**Examples:**
{% highlight bash %}
for NAME in root neo mitesh
do
  ADDRESS="$NAME@localhost"
  MESSAGE='Projects are due today!'
  echo $MESSAGE | mail-s Reminder $ADDRESS
done
{% endhighlight %}

{% highlight bash %}
for USER in $(grep bash /etc/passwd)...
for FILE in *.txt...

for num in {1..10}
for num in $(seq 1 10)
for num in $(seq 0 10 100)
{% endhighlight %}

{% highlight bash %}
#!/bin/bash
# alive2.sh
# Check to see if hosts 192.168.0.1-192.168.0.255 are alive

for n in {1..255}
do
  host=192.168.0.$n
  ping -c2 $host &> /dev/null

  if [ $? = 0 ]; then
    echo "$host is UP"
  else
    echo "$host is DOWN"
  fi
done
{% endhighlight %}




---
layout: post
title: "Configuring the Bash Shell"
author:
modified: 2015-06-05T17:00:00+05:30
comments: true
categories: linux/basics
excerpt: "Newbie Guide - How to configure BASH Shell"
tags: [Linux, Basics, BASH]
image:
  feature:
date: 2015-06-01T10:00:00+05:30
---

{% include _toc.html %}


### Variables

* A variable is a label that equates some value.
* The value can change over the time, across the accounts or across the systems but the label remains constant.

**For Example:**

* A shell script may place a file in `$HOME`, a reference to the value of the variable `HOME`.
* This value may differ, depending on who is running the shell script.

**NOTE!:** Some variables, like `$HOME`,
Are intended to be referenced but not set by the user.
{: .notice}

* However, users can also create their own variables:

**For Examples:**

{% highlight bash %}
[mitesh@Matrix ~]$ HI="Hello, pleased to meet you."
[mitesh@Matrix ~]$ echo $HI
Hello, pleased to meet you.
{% endhighlight %}

#### Types of Variables

##### Local(Shell) Variable
* Bash variables are local to a single shell By Default.
* Set with `VARIABLE=VALUE`

##### Environment Variable
* Accessed by some programs for configuration
* Set with `export VARIABLE=VALUE`


* The `set`, `env`, and `echo` commands can be used to display all variables, environment variables, and a single variable value, respectively.

**For Examples:**
{% highlight bash %}
[mitesh@Matrix ~]$ set | less
[mitesh@Matrix ~]$ env | less
[mitesh@Matrix ~]$ echo $HOME
/home/mitesh
{% endhighlight %}

#### Common Variables
<pre>
/-------------------------------------------------------------------------------------------------------\
|													|
|	PS1		|	Appearance of the bash prompt						|
|	PATH		|	Directories to look for executables in					|
|	EDITOR		|	Default text editor							|
|	LS_COLORS	|	Display different file types in different colors			|
|	HISTFILESIZE	|	Maximum number of commands saved in a user's .bash_history file		|
|													|
\-------------------------------------------------------------------------------------------------------/
</pre>

**Examples:**
{% highlight bash %}
[mitesh@Matrix ~]$ echo $PS1
[\u@\h \W]\$
{% endhighlight %}

#### Common Escape Sequences
<pre>
/----------------------------------------------------------------------\
|	\u	|	User Name					|
|	\h	|	Short Hostname (Not FQDN)			|
|	\w	|	The Current Working Directory			|
|	\!	|	The History Number Of This Command		|
|	\$	|	If The Effective UID Is 0, a #, Otherwise a $	|
\-----------------------------------------------------------------------/
</pre>

**NOTE!:** For complete list of escape sequence, see the PROMPTING section of the bash man page.
{: .notice}
<br>

#### Information Variables
<pre>
/-----------------------------------------------\
|						|
|	HOME	|	User's Home Directory	|
|	EUID	|	User's Effective UID	|
|						|
\-----------------------------------------------/
</pre>

#### Aliases

* Aliases are shortcut names for longer commands.
* Use alias by itself to see all set aliases
* Use alias followed by alias name to see alias value
* Aliases can be used for security purposes to force you to use certain flags


**Example:**
{% highlight bash %}
[mitesh@Matrix ~]$ alias
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias vi='vim'

[mitesh@Matrix ~]$ alias l.
alias l.='ls -d .* --color=auto'
{% endhighlight %}


**Example:**
{% highlight bash %}
[mitesh@Matrix ~]$ alias rm="rm -i"
{% endhighlight %}

**NOTE!:**	In this case, If you ever want to use the rm command itself, instead of your alias.
You can precede the command with a blackslash (\).
{: .notice}
{% highlight bash %}
[mitesh@Matrix ~]$ \rm -r Junk
{% endhighlight %}

**NOTE!:** The alias value must be a single word and so you will almost always want to quote the value as shown. <br>
Aliases are local to a single shell By Default.
{: .notice}


### How Bash Expand a Command Line

1. Split The Line Into Words
2. Expand Aliases
3. Expand Curly-Brace Statements ({})
4. Expand Tilde Statements (~)
5. Expand Variables ($) And Command-Substitution ($() and ``)
6. Split The Line Into Words Again
7. Expand File Globs (*, ?, [abc], etc)
8. Prepare I/O Redirections (<, >)
9. Run The Command!

**Example:**
{% highlight bash %}
[mitesh@Matrix ~]$ ll ~/*.{o,c} >> $HOME/co-files-$(date -I)
[mitesh@Matrix ~]$ ls -l --color=auto /home/mitesh/hello.c /home/mitesh/hello.o >> /home/mitesh/co-files-2009-09-03
{% endhighlight %}

#### Preventing Expansion

**Backslash (\\) Makes The Next Characters Literal**
{% highlight bash %}
[mitesh@Matrix ~]$ echo Your Cost: \$5.00
Your Cost: $5.00
{% endhighlight %}

**Quoting Prevents Expansion**

* `'` (Single Quotes) - Inhibit All Expansion
* `"` (Double Quotes) - Inhibit All Expansion Except
  * \ (Backslash)		-	Single Character Inhibition
  * $ (Doller Sign)	-	Variable Expansion
  * ` (Back Quotes)	-	Command Substitution
  * ! (Exclamation Point)	-	History Substitution


**Examples:**
{% highlight bash %}
[mitesh@Matrix ~]$ echo 'Welcome To $(hostname)'
Welcome To $(hostname)

[mitesh@Matrix ~]$ echo "Welcome To $(hostname)"
Welcome To Matrix

[mitesh@Matrix ~]$ echo \*\*\* SALE \*\*\*
*** SALE ***

[mitesh@Matrix ~]$ echo '*** SALE ***'
*** SALE ***
{% endhighlight %}

### Login vs Non-login Shells

* Startup Is Configured Differently For Login and Non-login Shells
<pre>
/---------------------------------------------------------------\
|	Login Shell		|	Non-login Shell		|
|----------------------------------------------------------------
|								|
|	/etc/profile		|	~/.bashrc		|
|	/etc/profile.d/		|	/etc/bashrc		|
|				|	/etc/profile.d/		|
|	~/.bash_profile		|				|
|	~/.bashrc		|				|
|	/etc/bashrc		|				|
|								|
\---------------------------------------------------------------/
</pre>

**Login Shell**

* `su -` Any Shell Created At Login (Includes X Login)

**Non-login Shell**

* su
* Executed Script
* Graphical Terminals
* Any Other Bash Instance


### Bash Startup Tasks

* By Default, Most of the configuration items,
That we have seen in this unit are only valid for the given shell.
* But Typically, We want settings to be established every time we start a shell,
Rather than typing all of our variables, aliases, and other commands on a per shell basis.
* To accomplish this, we use startup scripts, scripts that runs when a shell is created.

**profile**

* Stored in `/etc/profile` (Global) and `~/.bash_profile` (User)
* Runs For Login Shells Only
* Used For
  * Running Commands (Example: Mail Checker Script)
  * Setting Environment Variables (Such As PATH, USER, LOGNAME, MAIL, HOSTNAME, HISTSIZE, HISTCONTROL)

**bashrc**

* Stored in `/etc/bashrc` (Global) and `~/.bashrc` (User)
* Runs For All The Shells
* Used For
  * Setting umask
  * Defining/Undefining Aliases
  * Setting Local Variables (Such As PS1)

### Bash Exit Tasks

**logout**

* Stored in `~/.bash_logout` (User)
* Runs when Login Shell Exits
* Used For
  * Creating Automatic Backup
  * Cleaning Out Temporary Files

### Sourcing Files

* Changes made to profile and bashrc files need to be sourced.
* This will execute the file and read it into the running shell.

* For Instance, If you make a changes to `/etc/bashrc`.
Opening a new terminal will source this file and activate your changes.
However, The original terminal where you made those changes still has old settings.
From the original terminal, Run one of the following command
{% highlight bash %}
[root@Matrix ~]# . /etc/bashrc
[root@Matrix ~]# source /etc/bashrc
{% endhighlight %}