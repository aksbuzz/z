<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage">
<head>
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<script type="text/javascript">/* Copyright 2008 Google. */ (function() { var b=window,e="chrome",g="tick",h="wtsrt_",l="tbsd_",m="tbnd_",n="start",p="_wtsrt",q="_tbnd",r="CSI/";(function(){function k(a){this.t={};this.tick=function(a,d,c){this.t[a]=[void 0!=c?c:(new Date).getTime(),d];if(void 0==c)try{b.console.timeStamp(r+a)}catch(f){}};this[g](n,null,a)}var a;b.performance&&(a=b.performance.timing);var t=a?new k(a.responseStart):new k;b.jstiming={Timer:k,load:t};if(a){var d=a.navigationStart,f=a.responseStart;0<d&&f>=d&&(b.jstiming.srt=f-d)}if(a){var c=b.jstiming.load;0<d&&f>=d&&(c[g](p,void 0,d),c[g](h,p,f),c[g](l,h))}try{a=null,b[e]&&b[e].csi&&(a=Math.floor(b[e].csi().pageT),
c&&0<d&&(c[g](q,void 0,b[e].csi().startE),c[g](m,q,d))),null==a&&b.gtbExternal&&(a=b.gtbExternal.pageT()),null==a&&b.external&&(a=b.external.pageT,c&&0<d&&(c[g](q,void 0,b.external.startE),c[g](m,q,d))),a&&(b.jstiming.pt=a)}catch(u){}})(); })()
</script>
<link rel="shortcut icon" type="image/x-icon" href="//www.google.com/images/icons/product/sites-16.ico" />
<link rel="apple-touch-icon" href="https://ssl.gstatic.com/sites/p/f193b7/system/app/images/apple-touch-icon.png" type="image/png" />
<script type="text/javascript">/* Copyright 2008 Google. */ (function() { var d=window,e="length",h="",k="__duration__",l="function";function m(c){return document.getElementById(c)}d.byId=m;function n(c){return c.replace(/^\s+|\s+$/g,h)}d.trim=n;var p=[],q=0;d.JOT_addListener=function(c,a,b){var f=new String(q++);c={eventName:c,handler:a,compId:b,key:f};p.push(c);return f};d.JOT_removeListenerByKey=function(c){for(var a=0;a<p[e];a++)if(p[a].key==c){p.splice(a,1);break}};d.JOT_removeAllListenersForName=function(c){for(var a=0;a<p[e];a++)p[a].eventName==c&&p.splice(a,1)};
d.JOT_postEvent=function(c,a,b){var f={eventName:c,eventSrc:a||{},payload:b||{}};if(d.JOT_fullyLoaded)for(a=p[e],b=0;b<a&&b<p[e];b++){var g=p[b];g&&g.eventName==c&&(f.listenerCompId=g.compId||h,(g=typeof g.handler==l?g.handler:d[g.handler])&&g(f))}else d.JOT_delayedEvents.push({eventName:c,eventSrc:a,payload:b})};d.JOT_delayedEvents=[];d.JOT_fullyLoaded=!1;
d.JOT_formatRelativeToNow=function(c,a){var b=((new Date).getTime()-c)/6E4;if(1440<=b||0>b)return null;var f=0;60<=b&&(b/=60,f=2);2<=b&&f++;return a?d.JOT_siteRelTimeStrs[f].replace(k,Math.floor(b)):d.JOT_userRelTimeStrs[f].replace(k,Math.floor(b))}; })()
</script>
<script>

  

  var breadcrumbs = [{"path":"/site/steveyegge2/tour-de-babel","deleted":false,"title":"tour-de-babel","dir":"ltr"}];
  var JOT_clearDotPath = 'https://ssl.gstatic.com/sites/p/f193b7/system/app/images/cleardot.gif';

  
  var JOT_userRelTimeStrs = ["a minute ago","__duration__ minutes ago","an hour ago","__duration__ hours ago"];

  
  

  

  var webspace = {"enableAnalytics":false,"pageSharingId":"jotspot_page","enableUniversalAnalytics":false,"sharingPolicy":"OPENED","siteTitle":"steveyegge2","isStartPageEnabled":false,"adsensePublisherId":null,"features":{"languageSelectDefaultTextSetToDefault":true,"moreMobileStyleImprovements":true,"accessibleSortingButtons":false,"driveImageLinkFromOnepick":true,"analyticsFullSamplingRate":true,"domainAnalyticsInGAOnly":true,"noCaptcha":true,"fileCabinetScreenReaderFix":true,"updatedTosAndPrivacyLinks":null,"pageDrafts":false,"mobileOrientationFix":true,"plusBadge":false,"pdfEmbedSupport":false,"jsClickFix":true},"isPublic":true,"isConsumer":true,"serverFlags":{"cajaBaseUrl":"//www.gstatic.com/caja","cajaDebugMode":false},"onepickBaseUrl":"https://docs.google.com","domainAnalyticsAccountId":"","plusPageId":"","signInUrl":"https://www.google.com/a/SelectSession?continue\u003dhttps://sites.google.com/site/steveyegge2/tour-de-babel\u0026service\u003djotspot","analyticsAccountId":"","scottyUrl":"/_/upload","homePath":"/","siteNoticeUrlEnabled":null,"plusPageUrl":"","adsensePromoClickedOrSiteIneligible":true,"csiReportUri":"https://gg.google.com/csi","sharingId":"jotspot","termsUrl":"//www.google.com/intl/en/policies/terms/","gvizVersion":1,"editorResources":{"sitelayout":["https://ssl.gstatic.com/sites/p/f193b7/system/app/css/sitelayouteditor.css"],"text":["https://ssl.gstatic.com/sites/p/f193b7/system/js/codemirror.js","https://ssl.gstatic.com/sites/p/f193b7/system/app/css/codemirror_css.css","https://ssl.gstatic.com/sites/p/f193b7/system/js/trog_edit__en.js","https://ssl.gstatic.com/sites/p/f193b7/system/app/css/trogedit.css","/site/steveyegge2/_/rsrc/1436682018000/system/app/css/editor.css","https://ssl.gstatic.com/sites/p/f193b7/system/app/css/codeeditor.css","/site/steveyegge2/_/rsrc/1436682018000/system/app/css/camelot/editor-jfk.css"]},"sharingUrlPrefix":"/_/sharing","isAdsenseEnabled":true,"domain":"defaultdomain","baseUri":"/site/steveyegge2","name":"steveyegge2","siteTemplateId":false,"siteNoticeRevision":null,"siteNoticeUrlAddress":null,"siteNoticeMessage":null,"page":{"isRtlLocale":false,"canDeleteWebspace":false,"isPageDraft":null,"parentPath":null,"parentWuid":null,"siteLocale":"en","timeZone":"America/Los_Angeles","type":"text","title":"tour-de-babel","locale":"en","wuid":"wuid:gx:5018e87eb4b3d744","revision":1,"path":"/tour-de-babel","isSiteRtlLocale":false,"pageInheritsPermissions":null,"name":"tour-de-babel","canChangePath":true,"state":"","properties":{},"bidiEnabled":false,"currentTemplate":{"path":"/system/app/pagetemplates/text","title":"Web Page"}},"canPublishScriptToAnyone":true,"user":{"keyboardShortcuts":true,"sessionIndex":0,"guest_":false,"displayNameOrEmail":"Zac Anger","userName":"zacanger","uid":"11331526341757538279","domainUser":false,"renderMobile":false,"domain":null,"namespace":"","hasWriteAccess":false,"namespaceUser":false,"primaryEmail":"zacanger@gmail.com","hasAdminAccess":false},"gadgets":{"baseUri":"/site/steveyegge2/system/app/pages/gadgets"}};
  webspace.page.breadcrumbs = breadcrumbs;

  
  var JOT_siteRelTimeStrs = ["a minute ago","__duration__ minutes ago","an hour ago","__duration__ hours ago"];

</script>
<script type="text/javascript">
                window.jstiming.load.tick('scl');
              </script>
<meta name="title" content="tour-de-babel - steveyegge2" />
<meta itemprop="name" content="tour-de-babel - steveyegge2" />
<meta property="og:title" content="tour-de-babel - steveyegge2" />
<style type="text/css">
</style>
<link rel="stylesheet" type="text/css" href="https://ssl.gstatic.com/sites/p/f193b7/system/app/themes/microlite/standard-css-microlite-ltr-ltr.css" />
<link rel="stylesheet" type="text/css" href="/site/steveyegge2/_/rsrc/1436682018000/system/app/css/overlay.css?cb=microliteundefineda710px150goog-ws-noside" />
<link rel="stylesheet" type="text/css" href="/site/steveyegge2/_/rsrc/1436682018000/system/app/css/camelot/allthemes-view.css" />
<!--[if IE]>
          <link rel="stylesheet" type="text/css" href="/site/steveyegge2/system/app/css/camelot/allthemes%2die.css" />
        <![endif]-->
<title>tour-de-babel - steveyegge2</title>
<meta itemprop="image" content="stevey-email.png" />
<meta property="og:image" content="stevey-email.png" />
<script type="text/javascript">
                window.jstiming.load.tick('cl');
              </script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
<div id="sites-page-toolbar" class="sites-header-divider">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-status" class="sites-status" style="display:none;"><div id="sites-notice" class="sites-notice" role="status" aria-live="assertive"> </div></div>
</div>
<div id="sites-chrome-everything-scrollbar">
<div id="sites-chrome-everything" class="">
<div id="sites-chrome-page-wrapper" style="direction: ltr">
<div id="sites-chrome-page-wrapper-inside">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-chrome-header-wrapper" style="">
<table id="sites-chrome-header" class="sites-layout-hbox" cellspacing="0" style="">
<tr class="sites-header-primary-row" id="sites-chrome-userheader">
<td id="sites-header-title" class="" role="banner"><div class="sites-header-cell-buffer-wrapper"><h2></h2></div></td><td class="sites-layout-searchbox  "></td>
</tr>
<tr class="sites-header-secondary-row" id="sites-chrome-horizontal-nav">
<td colspan="2" id="sites-chrome-header-horizontal-nav-container" role="navigation">
</td>
</tr>
</table>
</div>
<div id="sites-chrome-main-wrapper">
<div id="sites-chrome-main-wrapper-inside">
<table id="sites-chrome-main" class="sites-layout-hbox" cellspacing="0" cellpadding="{scmCellpadding}" border="0">
<tr>
<td id="sites-chrome-sidebar-left" class="sites-layout-sidebar-left" style="display: none; width: 150px">
</td>
<td id="sites-canvas-wrapper">
<div id="sites-canvas" role="main">
<div id="goog-ws-editor-toolbar-container"> </div>
<div xmlns="http://www.w3.org/1999/xhtml" id="title-crumbs" style="display: none;">
</div>
<h3 xmlns="http://www.w3.org/1999/xhtml" id="sites-page-title-header" style="display: none;" align="left">
<span id="sites-page-title" dir="ltr" tabindex="-1" style="outline: none">tour-de-babel</span>
</h3>
<div id="sites-canvas-main" class="sites-canvas-main">
<div id="sites-canvas-main-content">
<div xmlns="http://www.w3.org/1999/xhtml" class="sites-layout-name-one-column-hf sites-layout-vbox"><div class="sites-layout-tile sites-tile-name-header"><p>Tour de Babel </p><br /><a href="blog-rants">Stevey's Drunken Blog Rants™</a></div><div class="sites-layout-tile sites-tile-name-content-1"><p> This is my whirlwind languages tour — the one I was going to write for the Amazon Developers Journal this month, but couldn't find a way to do it that was... presentable. </p>
<p> For one thing, I lapse occasionally into coarseness and profanity here, so it wasn't appropriate for an official-ish Amazon publication. Instead, I'm stuffing it into my blog, which nobody reads. Except for you. Yep, just you. Hiya. </p>
<p> For another, it's really a work in progress, just a few snippets here and there, not polished at all. Another great reason to make it a blog entry. Doesn't have to be good, or complete. It's just what I've got today. Enjoy! </p>
<p>My whirlwind tour will cover C, C++, Lisp, Java, Perl, (all languages we use at Amazon), Ruby (which I just plain <em>like</em>), and Python, which is in there because — well, no sense getting ahead of ourselves, now. </p>
<h3><a name="TOC-C"></a>C</h3>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="2116789767" name="2116789767" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D0131103628%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cDnSCNlduHnegaxDYQ3vJtGYDPrS1WeC9ZNOnd8jAYy8TMImBPOe8Uz1lYP8XQ8cNYJkZIRT55FIIP3NrixRSzpCn8qGYzZC9IP32kFDcqHCVkpQYx%252FMNGeZDWU2u3CDd%252FDqNvd%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p> You just have to know C. Why? Because for all practical purposes, every computer in the world you'll ever use is a von Neumann machine, and C is a lightweight, expressive syntax for the von Neumann machine's capabilities. </p>
<p> The von Neumann architecture is the standard computer architecture you use every day: a CPU, RAM, a disk, a bus. Multi-CPU doesn't really change it that much. The von Neumann machine is a convenient, cost-effective, 1950s realization of a Turing Machine, which is a famous abstract model for performing computations. </p>
<p> There are other kinds of machines too. For instance, there are Lisp Machines, which are convenient 1950s realizations of Lisp, a programming language notation based on the lambda calculus, which is another model for performing computations. Unlike Turing machines, the lambda calculus can be read and written by humans. But the two models are equivalent in power. They both model precisely what computers are capable of. </p>
<p> Lisp Machines aren't very common though, except at garage sales. von Neumann machines won the popularity race. There are various other kinds of computers, such as convenient realizations of neural networks or cellular automata, but they're nowhere as popular either, at least not yet. </p>
<p> So you have to know C. </p>
<p> You also have to know C because it's the language that Unix is written in, and happens also to be the language that Windows and virtually all other operating systems are written in, because they're OSes for von Neumann machines, so what else would you use? Anything significantly different from C is going to be too far removed from the actual capabilities of the hardware to perform well enough, at least for an OS — at least in the last century, which is when they were all written. </p>
<p> You should also know Lisp. You don't have to use it for real work, although it comes in quite handy for lots of GNU applications. In particular, you should learn Scheme, which is a small, pure dialect of Lisp. The GNU version is called <a href="http://www.gnu.org/software/guile/guile.html" rel="nofollow">Guile.</a> </p>
<p> They teach Scheme at MIT and Berkeley to new students for a semester or two, and the students have absolutely no clue as to why they're learning this weird language. It's a lousy first language, to be honest, and probably a lousy second one too. You should learn it, eventually, and not as your first or second language. </p>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="1794758668" name="1794758668" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D0262560992%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cDWBSRxcM%252FoqrwMdiVc%252BBl1GrBWwwhvsegqCUsVLwp3ZXYUMVTApqmIAN6Xxj%252FOVgrlabK0pZ05tLNlKUs9j2PCq3uUWm23vkcjLKkXeKWKOqlFWSUVVVi6xRkxBmfeNUnd8rpD%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p>It's hard, though. It's a big jump. It's not sufficient to learn how to write C-like programs in Lisp. That's pointless. C and Lisp stand at opposite ends of the spectrum; they're each great at what the other one sucks at. </p> 
If C is the closest language to modeling how computers work, Lisp is the closest to modeling how <em>computation</em> works. You don't need to know a lot of Lisp, really. Stick with Scheme, since it's the simplest and cleanest. Other Lisps have grown into big, complex programming environments, just like C++ and Java have, with libraries and tools and stuff. <em>That</em>, you don't need to know. But you should be able to write programs in Scheme. If you can make your way through all the exercises in <u>The Little Schemer</u> and <a href="http://www.amazon.com/o/asin/026256100X" rel="nofollow">The Seasoned Schemer</a>, you'll know enough, I think. 
<p></p>
<p> But you choose a language for day-to-day programming based on its libraries, documentation, tools support, OS integration, resources, and a host of other things that have very little to do with how computers work, and a whole lot to do with how <em>people</em> work. </p>
<p> People still write stuff in straight C. Lots of stuff. You should know it! </p>
<h3 style="clear:both"><a name="TOC-C-"></a>C++</h3>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="947523974" name="947523974" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D0070296898%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cDCwX47NuttG3cHq86gtGI6O%252Fn8JLnAwMK5H%252FRjWA6IuM0nWNV79aC3WfTiewIDoCuCxJBQW%252F8wEILDlK59VWqBs9q880OXf7WGDvqZf40OPbu1wm%252Bn%252BWSTKjFZqGFzoXrm4Cdu%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p> C++ is the dumbest language on earth, in the very real sense of being the least sentient. It doesn't know about itself. It is not <em>introspective</em>. Neither is C, but C isn't "Object-Oriented", and object orientation is in no small measure about making your programs know about themselves. Objects are actors. So OO languages need to have runtime reflection and typing. C++ doesn't, not really, not that you'd ever use. </p>
<p> As for C: it's so easy to write a C compiler that you can build tools on top of C that act like introspection. C++, on the other hand, is essentially un-parseable, so if you want to write smart tools that can, for example, tell you the signatures of your virtual functions, or refactor your code for you, you're stuck using someone else's toolset, since <em>you</em> sure as heck aren't gonna parse it. And all the toolsets for parsing C++ out there just plain suck. </p>
<p> C++ is dumb, and you can't write smart systems in a dumb language. Languages shape the world. Dumb languages make for dumb worlds. </p>
<p> All of computing is based on <em>abstractions</em>. You build higher-level things on lower-level ones. You don't try to build a city out of molecules. Trying to use too low-level an abstraction gets you into trouble. </p>
<p> We are in trouble. </p>
<p> The biggest thing you can reasonably write in C is an operating system, and they're not very big, not really. They look big because of all their apps, but kernels are small. </p>
<p> The biggest thing you can write in C++ is... also an operating system. Well, maybe a little bigger. Let's say three times bigger. Or even ten times. But operating system kernels are at most, what, maybe a million lines of code? So I'd argue the biggest system you can reasonably write in C++ is maybe 10 million lines, and then it starts to break down and become this emergent thing that you have no hope of controlling, like the plant in Little Shop of Horrors. Feeeeeed meeeeeee... </p>
<p> If you can get it to compile by then, that is. </p>
<p> We have 50 million lines of C++ code. No, it's more than that now. I don't know what it is anymore. It was 50 million last Christmas, nine months ago, and was expanding at 8 million lines a quarter. The expansion rate was increasing as well. Ouch. </p>
<p> Stuff takes forever to do around here. An Amazon engineer once described our code base as "a huge mountain of poop, the biggest mountain you've ever seen, and your job is to crawl into the very center of it, every time you need to fix something." </p>
<p> That was four years ago, folks. That engineer has moved on to greener pastures. Too bad; he was really good. </p>
<p> It's all C++'s fault. Don't argue. It is. We're using the dumbest language in the world. That's kind of meta-dumb, don't you think? </p>
<p> With that said, it <em>is</em> obviously possible to write nice C++ code, by which I mean, code that's mostly C, with some C++ features mixed in tastefully and minimally. But it almost never happens. C++ is a vast playground, and makes you feel smart when you know all of it, so you're always tempted to use all of it. But that's really, really hard to do <em>well</em>, because it's such a crap language to begin with. In the end, you just make a mess, even if you're good. </p>
<p> I know, this is Heresy, with a capital-'H'. Whatever. I loved C++ in college, because it's all I knew. When I heard that my languages prof, Craig Chambers, absolutely detested C++, I thought: "Why? I like it just fine." And when I heard that the inventor of STL was on record as saying he hated OOP, I thought he was cracked. How could anyone hate OOP, especially the inventor of STL? </p>
<p> Familiarity breeds contempt in most cases, but not with computer languages. You have to become an expert with a <em>better</em> language before you can start to have contempt for the one you're most familiar with. </p>
<p> So if you don't like what I'm saying about about C++, go become an expert at a better language (I recommend Lisp), and then you'll be armed to disagree with me. You won't, though. I'll have tricked you. You won't like C++ anymore, and you might be irked that I tricked you into disliking your ex-favorite language. So maybe you'd better just forget about all this. C++ is great. Really. It's just ducky. Forget what I said about it. It's fine. </p>
<h3><a name="TOC-Lisp"></a>Lisp</h3>
<p> <em>(I'm betting this next section will astonish you, even if you've been here a while.)</em> </p>
<p> When Amazon got its start, we had brilliant engineers. I didn't know all of them, but I knew some of them. </p>
<p> Examples? Shel Kaphan. Brilliant. Greg Linden. Brilliant. Eric Benson. Independently famous in his own right, before he ever even came to Amazon. Also brilliant. </p>
<p> They wrote the Obidos webserver. Obidos made Amazon successful. It was only later that poop-making engineers and web devs, frontend folks mostly — schedule-driven people who could make their managers happy by delivering crap fast — it was only later that these people made Obidos bad. Clogged the river, so to speak. But Obidos was a key cornerstone of Amazon's initial success. </p>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="541470292" name="541470292" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D1590592395%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cCjSpXJfjlp6gC%252FB9TQvbL5f0U%252BJT8XVyXkv9PxHdX5TCQl6FMGvK%252BJpLHPZ1mIaMQCKIc5Rx5l7BekDBGXIda5Y7W%252B3DnFLPrwBFsGjIXj8xNOU6OVfsqjMeRimCyBtrg7uU6P%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p> The original brilliant guys and gals here only allowed two languages in Amazon's hallowed source repository: C and Lisp. </p>
<p> Go figure. </p>
<p> They all used Emacs, of course. Hell, Eric Benson was one of the <em>authors</em> of XEmacs<sup><a href="#note1">1</a></sup>. All of the greatest engineers in the world use Emacs. The world-changer types. Not the great gal in the cube next to you. Not Fred, the amazing guy down the hall. I'm talking about the greatest software developers of our profession, the ones who changed the face of the industry. The James Goslings, the Donald Knuths, the Paul Grahams<sup><a href="#note2">2</a></sup>, the Jamie Zawinskis, the Eric Bensons. Real engineers use Emacs. You have to be way smart to use it well, and it makes you incredibly powerful if you can master it. Go look over Paul Nordstrom's shoulder while he works sometime, if you don't believe me. It's a real eye-opener for someone who's used Visual Blub .NET-like IDEs their whole career. </p>
<p> Emacs is the 100-year editor. </p>
<p> Shel, Eric, Greg, and others like them that I wasn't fortunate enough to work with directly: they didn't allow C++ here, and they didn't allow Perl. (Or Java, for that matter). They knew better. </p>
<p> Now C++, Java and Perl are all we write in. The elders have moved on to greener pastures too.</p>
<p> Shel wrote Mailman in C, and Customer Service wrapped it in Lisp. Emacs-Lisp. You don't know what Mailman is. Not unless you're a longtime Amazon employee, probably non-technical, and you've had to make our customers happy. Not indirectly, because some bullshit feature you wrote broke (because it was in C++) and pissed off our customers, so you had to go and fix it to restore happiness. No, I mean directly; i.e., you had to <em>talk</em> to them. Our lovely, illiterate, eloquent, well-meaning, hopeful, confused, helpful, angry, happy customers, the real ones, the ones buying stuff from us, our <em>customers</em>. Then you know Mailman. </p>
<p> Mailman was the Customer Service customer-email processing application for ... four, five years? A long time, anyway. It was written in Emacs. Everyone loved it. </p>
<p> People <em>still love it</em>. To this very day, I still have to listen to long stories from our non-technical folks about how much they miss Mailman. I'm not shitting you. Last Christmas I was at an Amazon party, some party I have no idea how I got invited to, filled with business people, all of them much prettier and more charming than me and the folks I work with here in the Furnace, the Boiler Room of Amazon. Four young women found out I was in Customer Service, cornered me, and talked for <em>fifteen minutes</em> about how much they missed Mailman and Emacs, and how Arizona (the JSP replacement we'd spent years developing) still just wasn't doing it for them. </p>
<p> It was truly surreal. I think they may have spiked the eggnog. </p>
<p> Shel's a genius. Emacs is a genius. Even non-technical people love Emacs. I'm typing in Emacs right now. I'd never voluntarily type anywhere else. It's more than just a productivity boost from having great typing shortcuts and text-editing features found nowhere else on the planet. I type 130 to 140 WPM, error-free, in Emacs, when I'm doing free-form text. I've timed it, with a typing-test Emacs application I wrote. But it's <em>more</em> than that. </p>
<p> Emacs has the Quality Without a Name. </p>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="1511825602" name="1511825602" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D1565922611%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cA%252B%252FaPLGHJRgzD5mlPzbiCG%252BsEz9I8pbuKfP%252FM33ZlxgqRzj2Zgz%252FGlM%252BAcYuS5e5Et48jFUFiinGDYcvO%252F8FHYtlQ3O%252FVZYr64I39ktyrnB6N0D7i81SrHhHfDUWe35LmR%252BZY6%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p> We retired Mailman. That's because we have the Quality <em>With</em> a Name — namely, Suckiness. We suck. We couldn't find anyone who was good enough at Emacs-Lisp to make it work. Nowadays it would be easy; Amazon's filled up with Emacs Lisp hackers, but back then, CS Apps couldn't get the time of day from anyone, so they did what they could with what they had, and there weren't enough Emacs-Lisp folks. For a while, they even had Bob Glickstein on contract, the guy who wrote the O'Reilly "giraffe" book <u>Writing Gnu Emacs Extensions</u>, sitting there writing Gnu Emacs Extensions for Mailman in this little office in the Securities building. </p>
<p> CS Apps was Amazon's first 2-pizza team, you know. They're completely autonomous — then and now. Nobody talks to them, nobody helps them, they build everything themselves. They don't have web devs, they don't have support engineers, they don't have squat, except for rock-solid engineers and a mentoring culture. And that's all they've ever needed. </p>
<p> But they had to retire Mailman. Alas. Alackaday. And I still get to hear about how much people miss it. At parties, even. </p>
<p> I think there may still be more Lisp hackers, per capita, in CS Apps than in any other group at Amazon. Not that they get to use it much, but as Eric Raymond said, even if you don't program in it much, learning Lisp will be a profound experience that will make you a better engineer for the rest of your life. </p>
<p> Religion isn't the opiate of the masses anymore, Karl. IDEs are. </p>
<h3><a name="TOC-Java"></a>Java</h3>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="978371228" name="978371228" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D0471697036%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cBvFD1O%252BrPF72J8PqDdEDqd3b44CVMFhVHiIIFifHjt%252FR%252BuOKPwzcdpQlIYRzHuieotaJGTvSRgUNJbpKBop89j3yLKQHwobYF9%252Bfv4%252FGgaGDhROh%252BXGUy9GSpikgvpBMy4nB51%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p> Java is simultaneously the best and the worst thing that has happened to computing in the past 10 years. </p>
<p> On the one hand, Java frees you up from many mundane and error-prone details of C++ coding. No more bounds errors, no more core dumps. Exceptions thrown point you to the exact line of code that erred, and are right 99% of the time. Objects print themselves intelligently on demand. Etc., etc. </p>
<p> On the other hand, in addition to being a language, a virtual machine, a huge set of class libraries, a security model, and a portable bytecode format, Java is a religion. So you can't trust anyone who loves it too much. It's a tricky business to hire good Java programmers. </p>
<p> But Java really has been a big step forward for software engineering in general. </p>
<p> Going from C++ to Java isn't just changing syntax. It's a shocking paradigm shift that takes a while to sink in. It's like suddenly getting your own Executive Assistant. You know how VPs always seem to have all this time to be in meetings, and know how the company's running, and write cool documents, and stuff like that? VPs tend to forget that they're actually TWO full-time people: their self and their EA. Having an EA frees you up to think about the <em>problems</em> you need to solve; not having one forces you to spend half your time on mundane tasks. Switching to Java turns you into two programmers — one taking care of all this <em>stuff</em> that you no longer have to think much about, and another one focused on the problem domain. It's a staggering difference, and one you can get used to in a real hurry. </p>
<p> As Jamie Zawinski said in his famous "java sucks" article: "First the good stuff: Java doesn't have free(). I have to admit right off that, after that, all else is gravy. That one point makes me able to forgive just about anything else, no matter how egregious. Given this one point, everything else in this document fades nearly into insignificance." </p>
<p> Jamie's article was written in 1997, which in Java years is a <em>long</em> time ago, and Java has improved a lot since he wrote it; some of the things he complains about are even fixed now. </p>
<p> Most of them aren't. Java does still kind of suck, as a language. But as Jamie points out, it's "the best language going today, which is to say, it's the marginally acceptable one among the set of complete bagbiting loser languages that we have to work with out here in the real world." </p>
<p> Really, you should <a href="http://www.jwz.org/doc/java.html" rel="nofollow">read it</a>. </p>
<p> Java is truly wonderful along almost every dimension except for the language itself, which is mostly what JWZ was griping about. But that's a <em>lot</em> to gripe about. Libraries can only get you so far if your language sucks. Trust me: you may know many, many things better than I do, but I know that libraries can't really save a sucky language. Five years of assembly-language hell at Geoworks taught me that. </p>
<p> Compared to C++, Java as a language is about even. Well, scratch that, it's a lot better, because it has <em>strings</em>, oh man, how can you use a language with lousy string support. </p>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="2100781846" name="2100781846" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D0321246780%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cDMXWeEh1LwwESr8fvepOIXU%252BVhYoCV9z5fqucSQr76IGazTikdwq9tCJip5snP%252BxLTcmmGCwogN3LPAfbaLdEnRsLsaZaMXOphcVHhPGOVf5Eb00i6u6hlE22vljfmKNMRdO7N%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p>But Java's missing some nice features from C++, such as pass-by-reference(-to-stack-object), typedefs, macros, and operator overloading. Stuff that comes in handy now and again. </p>
<p>Oh, and multiple inheritance, which now I've come to appreciate in my old age. If you think my <a href="when-polymorphism-fails">Opinionated Elf</a> was a good counterpoint to polymorphism dogma, I've got several brilliant examples of why you <em>need</em> multiple inheritance, or at least Ruby-style mixins or automatic delegation. Ask me about the Glowing Sword or Cloak of Thieving sometime. Interfaces suck. </p>
<p>Gosling even said, a few years ago, that if he had to do it all over again, he wouldn't have used interfaces. </p>
<p> But that's <em>just exactly</em> what the problem with Java is. When James said that, people were shocked. I could feel the shock waves, could feel the marketing and legal folks at Sun maneuvering to hush him up, brush it off, say it wasn't so. </p>
<p> The problem with Java is that people are blinded by the marketing hype. That's the problem with C++, with Perl, with any language that's popular, and it's a serious one, because languages can't become popular <em>without</em> hype. So if the language designer suggests innocently that the language might not have been designed perfectly, it's time to shoot the language designer full of horse tranquilizers and shut down the conference. </p>
<p> Languages need hype to survive; I just wish people didn't have to be <em>blinded</em> by it. </p>
<p> I drank the OOP Kool-Aid, I regurgitated the hype myself. When I started at Amazon, I could recite for you all the incantations, psalms, and voodoo chants that I'd learned, all in lieu of intelligence or experience, the ones that told me Multiple Inheritance is Evil 'cuz Everyone Says So, and Operator Overloading Is Evil, and so on. I even vaguely sort of knew why, but not really. Since then I've come to realize that it's not MI that sucks, it's developers who suck. <em>I</em> sucked, and I still do, although hopefully less every year. </p>
<p> I had an interview candidate last week tell me that MI is Evil because, for instance, you could make a Human class that multiply-inherits from Head, Arm, Leg, and Torso. He was both right and wrong. That MI situation was evil, sure, but it was all him. Stupid from a distance, evil if he'd made it in through the front door. </p>
<p> Bad developers, who constitute the majority of all developers worldwide, can write bad code in any language you throw at them. </p>
<p> That said, though, MI is no picnic; mixins seem to be a better solution, but <em>nobody</em> has solved the problem perfectly yet. But I'll still take Java over C++, even without MI, because I know that no matter how good my intentions are, I will at some point be surrounded by people who don't know how to code, and they will do far less damage with Java than with C++. </p>
<p> Besides, there's way more to Java than the core language. And even the language is evolving, albeit glacially, so there's hope. It's what we should be using at Amazon. </p>
<p> You just have to be careful, because as with any other language, you can easily find people who know a lot about the language environment, and very little about taste, computing, or anything else that's important. </p>
<p> When in doubt, hire Java programmers who are polyglots, who detest large spongy frameworks like J2EE and EJB, and who use Emacs. All good rules of thumb. </p>
<p> </p>
<h3><a name="TOC-Perl"></a>Perl</h3>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="1325058931" name="1325058931" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D0596000278%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cCB9cOc65QGB%252FORZFDw4VGZ0NYvm7346jS8gns6bUa9qXLI8C%252FQEAkNfawVufbmDd4YEKTPnk6kS63H2fxZ%252B6bU4UqZq16iq9UUeOWVqFpLbffoljW9OwhPcczONIstD1YFKT3k%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p> Perl. Where to start? </p>
<p> Perl is an old friend. Perl and I go way back. I started writing Perl stuff in maybe 1995, and it's served me well for nearly a decade. </p>
<p> It's like that old bicycle you've put 100k or 200k miles on, and you'll always have a warm fuzzy spot for it, even though you've since moved on to a more modern bike that weighs 5 lbs and doesn't make your ass hurt so much. </p>
<p> Perl is popular for three reasons: </p>
<ol>
<li>
<p> You can <em>get stuff done</em> really fast in Perl, which is what really matters, in the end. </p>
</li>
<li>
<p> Perl has the best marketing in the world. You could write a book about how brilliant their marketing is. Sun has marketed Java with money, and Perl is almost keeping up, popularity-wise, purely on the on sheer marketing brilliance of Larry Wall and his buddies. Folks at Harvard Business School should study Perl's marketing. It's astonishing. </p>
</li>
<li>
<p> Until roughly, oh, <em>now</em>, it had no real competitors. </p>
</li>
</ol>
<p> There are "better" languages than Perl — hell, there are lots of them, if you define "better" as "not being insane". Lisp, Smalltalk, Python, gosh, I could probably name 20 or 30 languages that are "better" than Perl, inasmuch as they don't look like that Sperm Whale that exploded in the streets of Taiwan over the summer. Whale guts everywhere, covering cars, motorcycles, pedestrians. That's Perl. It's charming, really. </p>
<p> But Perl has many, many things going for it that, until recently, no other language had, and they compensated for its exo-intestinal qualities. You can make all sorts of useful things out of exploded whale, including perfume. It's quite useful. And so is Perl. </p>
<p> While all those other languages (Lisp and Smalltalk being particularly noteworthy offenders) tried to pretend that operating systems don't exist, and that lists (for Lisp) or objects (for Smalltalk) are the be-all, end-all of getting shit done, Perl did exactly the opposite. Larry said: Unix and string processing are the be-all, end-all of getting shit done. </p>
<p> And for many tasks, he was absolutely right. So Perl is better at Unix integration and string processing than any language on the planet, save one, and that one only arrived on the scene recently, from the land of Godzilla. I'll get to that one later. </p>
<p> Sadly, Larry focused sooooo hard on Unix integration and string processing that he totally forgot about lists and objects until it was far too late to implement them properly. In fact, a few key mistakes he made early on in Perl's... well, I hesitate to use the word "design" for whale guts, but let's call it Perl's "lifecycle" — those mistakes made it so hard to do lists and objects correctly that Perl has evolved into a genuine Rube Goldberg machine, at least if you want to use lists or objects. </p>
<p> Lists and objects are pretty farging important too, Larry! </p>
<p> Perl can't do lists because Larry made the tragically stupid decision early on to flatten them automatically. So (1, 2, (3, 4)) magically becomes (1, 2, 3, 4). Not that you <em>ever</em> want it to work this way. But Larry happened to be working on some problem for which it was convenient on that particular day, and Perl's data structures have been pure exploded whale ever since. </p>
<p> Now you can't read a book or tutorial or PowerPoint on Perl without spending at least a third of your time learning about "references", which are Larry's pathetic, broken, Goldbergian fix for his list-flattening insanity. But Perl's marketing is so incredibly good that it makes you feel as if references are the best thing that ever happened to you. You can take a reference to anything! It's fun! Smells good, too! </p>
<p> Perl can't do objects because Larry never r<i>eeee</i>ally believed in them. Maybe that's OK; I'm still not quite sure if I believe in them either. But then why did he try adding them? Perl's OO is a halfhearted add-on that never caught on with the Perl community. It's just not as inspired as the string-processing or Unix integration stuff. </p>
<p> And of course, Perl has plenty of other crackpot design features. Take its "contexts", for instance, which are a horrid outgrowth of Larry's comical decision to have N variable namespaces, dereferenced by sigils, which he sort of copied from shell-script. In Perl, every operator, every function, every <em>operation</em> in the language behaves randomly in one of six different ways, depending on the current "context". There are no rules or heuristics governing how a particular operation will behave in a given context. You just have to commit it all to memory. </p>
<p> Need an example? Here's one: accessing a hash in a scalar context gives you a string containing a fraction whose numerator is the number of allocated keys, and the denominator is the number of buckets. Whale guts, I'm telling you. </p>
<p> Like I said, though — until recently, nothing could get the job done like Perl could. </p>
<h3><a name="TOC-Ruby"></a>Ruby</h3>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="1558866825" name="1558866825" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D0974514055%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cCBTW9l75LQRhptYZbojwAWtIn6MgDDtNU3NYCHx3dVOkFCSSZSCiGNtedvz1jhfVpUHE6WLZfvjWKcla36GVOyojwha7Toavxg8njqQ7DwLKqsYQkq4ErjXtbU8byCUvn%252B80TT%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p> Every 15 years or so, languages are replaced with better ones. C was replaced by C++, at least for large-scale application development by people who needed performance but desperately wanted data types too. C++ is being replaced by Java, and Java will doubtless be replaced with something better in seven years — well, seven years after it finishes replacing C++, which evidently hasn't fully happened yet, mostly because Microsoft was able to stall it before it became ubiquitous on the desktop. But for server-side applications, C++ is basically on its way out. </p>
<p> Perl will be gone soon, too. That's because a new language called Ruby has finally been translated into English. Yep, it was invented in Japan, of all places — everyone else was as surprised as you are, since Japan's known for its hardware and manufacturing, but not for its software development. Why, is anyone's guess, but I'm thinking it's the whole typing thing; I just can't imagine they were able to type fast enough before, what with having an alphabet with ten thousand characters in it. But Emacs got multibyte support a few years ago, so I can imagine they're pretty dang fast with it now. (And yes, they use Emacs — in fact Japanese folks did the majority of the Mule [multibyte] support for Emacs, and it's rock-solid.) </p>
<p> Anyway, Ruby stole <em>everything</em> good from Perl; in fact, Matz, Ruby's author (Yukihiro Matsumoto, if I recall correctly, but he goes by "Matz"), feels he may have stolen a little too much from Perl, and got some whale guts on his shoes. But only a little. </p>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="242650086" name="242650086" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D0596523696%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cAHwYk0gubUjxeB8O9EUNOUAox6HXAXqDg6O8DQedyFFPWBX50wNKxwxPjqAQn4liAir1mc%252BMxI5mSHSXK2oaRB%252BS%252FSBrchtqaJ8I99TpDmS1o64kKKGgHqXYGka6%252BlsPw4KiSo%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p> For the most part, Ruby took Perl's string processing and Unix integration <em>as-is</em>, meaning the syntax is identical, and so right there, before anything else happens, you already have the Best of Perl. And that's a great start, especially if you don't take the Rest of Perl. </p>
<p> But then Matz took the best of list processing from Lisp, and the best of OO from Smalltalk and other languages, and the best of iterators from CLU, and pretty much the best of everything from everyone. </p>
<p> And he somehow made it all work together so well that you don't even notice that it <em>has</em> all that stuff. I learned Ruby faster than any other language, out of maybe 30 or 40 total; it took me about 3 days before I was more comfortable using Ruby than I was in Perl, after eight years of Perl hacking. It's so consistent that you start being able to guess how things will work, and you're right most of the time. It's beautiful. And fun. And practical. </p>
<p> If languages are bicycles, then Awk is a pink kiddie bike with a white basket and streamers coming off the handlebars, Perl is a beach cruiser (remember how cool they were? Gosh.) and Ruby is a $7,500 titanium mountain bike. The leap from Perl to Ruby is as significant as the leap from C++ to Java, but without any of the downsides, because Ruby's essentially a proper superset of Perl's functionality, whereas Java took some things away that people missed, and didn't offer real replacements for them. </p>
<p> I'll write more about Ruby sometime. I need to be inspired first. Read <a href="http://poignantguide.net/ruby/" rel="nofollow">Why the Lucky Stiff's (poignant) guide to Ruby</a>. <em>That</em> is an inspired piece of work. Really. Read it. It's amazing. I don't understand the kind of mind that could produce it, but it's funny, and poignant, and all about Ruby. Sort of. You'll see. </p>
<p> </p>
<h3><a name="TOC-Python"></a>Python</h3>
<div class="sites-embed-align-left-wrapping-off"><div class="sites-embed-border-off sites-embed" style="width:400px;"><div class="sites-embed-content sites-embed-type-ggs-gadget"><iframe width="400" height="300" scrolling="no" frameborder="0" id="247843814" name="247843814" allowtransparency="true" class="igm" src="//mj89sp3sau2k7lj1eg3k40hkeppguj6j-a-sites-opensocial.googleusercontent.com/gadgets/ifr?url=http://www.gstatic.com/sites-gadgets/iframe/iframe.xml&amp;container=enterprise&amp;view=default&amp;lang=en&amp;country=ALL&amp;sanitize=0&amp;v=44d6b25297941457&amp;libs=core&amp;parent=https://sites.google.com/site/steveyegge2/tour-de-babel#up_scroll=no&amp;up_iframeURL=http://rcm.amazon.com/e/cm?t%3Dsteveysblogra-20%26o%3D1%26p%3D8%26l%3Das1%26asins%3D0596007973%26fc1%3D000000%26IS2%3D1%26lt1%3D_blank%26lc1%3D0000ff%26bc1%3D000000%26bg1%3Dffffff%26f%3Difr&amp;st=e%3DAIHE3cC50YdltT4OiOZLEu74APK7RZo2pZh1HJfNLjqTzo%252BtuIKe2%252FUUoscEAA8WpBNit1uzNjFxTsVzUYxeMkBXPIOwa1il1RbFaG3nNZc%252BDG55oajS6MAglTmYBgq7ADt4sCgzc1PV%26c%3Denterprise&amp;rpctoken=3401045333547609882"></iframe></div></div></div>
<p> Well gosh, what about Python, a nice language that has patiently been waiting in the wings for all these years? The Python community has long been the refuge for folks who finally took the red pill and woke up from the Perl Matrix. </p>
<p> Well, they're just like the Smalltalk folks, who waited forever to replace C++, and then Java came along and screwed them royally, and permanently. Oops. Ruby's doing exactly that to Python, right now, today. Practically overnight. </p>
<p> Python <em>would</em> have taken over the world, but it has two fatal flaws: the whitespace thing, and the permafrost thing. </p>
<p> The whitespace thing is simply that Python uses indentation to determine block nesting. It forces you to indent everything a certain way, and they do this so that everyone's code will look the same. A surprising number of programmers <em>hate</em> this, because it feels to them like their freedom is being taken away; it feels as if Python is trampling their constitutional right to use shotgun formatting and obfuscated one-liners.<sup><a href="#note3">3</a></sup></p>
<p> Python's author, Guido Van Rossum, also made some boneheaded technical blunders early on — none quite as extravagant as Larry's blunders, but a few were real doozies nonetheless. For instance, Python originally had no lexical scoping. But it didn't have dynamic scoping either, and dynamic scoping may have its share of problems, but it at least sort of works. Python had NOTHING except for global and local (function) scope, so even though it had a "real" OO system, classes couldn't even access their own damned instance variables. You have to pass a "self" parameter to EVERY instance method and then get to your instance data by accessing it through self. So everything in Python is self, selfself, selfselfself, selfSELFselfSELF__SELF__, and it drives you frigging nuts, even if you don't mind the whitespace thing. </p>
<p>Etc.</p>
<p> But in my opinion, it's really the frost thing that killed Python, and has prevented it from ever achieving its wish to be the premier scripting language, or the premier anything language, for that matter. Heck, people still use Tcl as an embedded interpreter, even though Python is far superior to Tcl in every conceivable way — except, that is, for the frost thing. </p>
<p> What's the frost thing, you ask? Well, I used to have a lot of exceptionally mean stuff written here, but since Python's actually quite pleasant to work with (if you can overlook its warts), I no longer think it's such a great idea to bash on Pythonistas. The "frost thing" is just that they used to have a tendency to be a bit, well, frosty. Why? </p>
<p>Because they were so tired of hearing about the whitespace thing!</p>
<p> I think that's why Python never reached Perl's level of popularity, but maybe I'm just imagining things. </p>
<h3><a name="TOC-Coda"></a>Coda</h3>
<p> That was the ADJ article I really wanted to write. Or at least something like it. For some reason, though, my true feelings only seem to come out during insomniac attacks between 3am and 6am. Time for bed! 2 hours 'til my next meeting. </p>
<p> </p>
<div style="font-style:italic">(Published September 2004. Minor updates on 3/28/2006)</div>
<p></p>
<hr />
<p> <b> Notes </b> </p>
<p><sup><a name="note1">1</a></sup> Eric tells me it was actually almost all Jamie Zawinski, when they worked at Lucid together.</p>
<p> <sup><a name="note2">2</a></sup> It's been pointed out many times since I wrote this that Paul Graham actually uses vi. Go figure!</p>
<p> </p>
<p> <sup><a name="note3">3</a></sup> For the record, I personally don't mind the whitespace thing at all. I think it's silly to dislike Python for that reason. What I'm saying is that a surprising percentage of *other* programmers hate it. </p></div><div class="sites-layout-tile sites-tile-name-footer"><table width="100%">
<tbody><tr>
<td width="100%">
<a href="blog-rants">Back to Stevey's Drunken Blog Rants™</a>
</td>
<td align="right">
<img src="stevey-email.png" alt="image of my email address, steve dot yegge at ye olde gmail" />
</td>
</tr></tbody></table>
<p>
</p></div></div>
</div> 
</div> 
<div id="sites-canvas-bottom-panel">
<div id="sites-attachments-container">
</div>
</div>
</div> 
</td> 
</tr>
</table> 
</div> 
</div> 
<div id="sites-chrome-footer-wrapper">
<div id="sites-chrome-footer-wrapper-inside">
<div id="sites-chrome-footer">
</div>
</div>
</div>
</div> 
</div> 
<div id="sites-chrome-adminfooter-container">
<div xmlns="http://www.w3.org/1999/xhtml" class="sites-adminfooter" role="navigation"><p><a class="sites-system-link" href="https://www.google.com/accounts/AddSession?service=jotspot&amp;continue=https://sites.google.com/site/steveyegge2/tour-de-babel">Sign in</a><span aria-hidden="true">|</span><a class="sites-system-link" href="/site/steveyegge2/system/app/pages/recentChanges">Recent Site Activity</a><span aria-hidden="true">|</span><a class="sites-system-link" href="/site/steveyegge2/system/app/pages/reportAbuse" target="_blank">Report Abuse</a><span aria-hidden="true">|</span><a class="sites-system-link" href="javascript:;" onclick="window.open(webspace.printUrl)">Print Page</a><span aria-hidden="true">|</span><span class="sites-system-link">Powered By</span> <b class="powered-by"><a href="http://sites.google.com">Google Sites</a></b></p></div>
</div>
</div> 
</div> 
<div id="sites-chrome-onebar-footer">
</div>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    window.jstiming.load.tick('sjl');
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" src="https://ssl.gstatic.com/sites/p/f193b7/system/js/jot_min_view__en.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    window.jstiming.load.tick('jl');
  </script>
<script xmlns="http://www.w3.org/1999/xhtml">
      
          sites.core.Analytics.createTracker();
          sites.core.Analytics.trackPageview();
        
    </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
      gsites.HoverPopupMenu.createSiteDropdownMenus('sites-header-nav-dropdown', false);
    </script>
<script xmlns="http://www.w3.org/1999/xhtml">
                    window.onload = function() {
                      if (false) {
                        JOT_setMobilePreview();
                      }
                      var loadTimer = window.jstiming.load;
                      loadTimer.tick("ol");
                      loadTimer["name"] = "load," + webspace.page.type + ",user_page";
                      window.jstiming.report(loadTimer, {}, 'https://gg.google.com/csi');
                    }
                  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
        JOT_insertAnalyticsCode(false,
            false);
      </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    var maestroRunner = new gsites.pages.view.SitesMaestroRunner(
        webspace, "en");
    maestroRunner.initListeners();
    maestroRunner.installEditRender();
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
  //<![CDATA[
    // Decorate any fastUI buttons on the page with a class of 'goog-button'.
    if (webspace.user.hasWriteAccess) {
      JOT_decorateButtons();
    }

    // Fires delayed events.
    (function() {
      JOT_fullyLoaded = true;
      var delayedEvents = JOT_delayedEvents;
      for (var x = 0; x < delayedEvents.length; x++) {
        var event = delayedEvents[x];
        JOT_postEvent(event.eventName, event.eventSrc, event.payload);
      }
      JOT_delayedEvents = null;
      JOT_postEvent('pageLoaded');
    })();
  //]]>
</script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    JOT_postEvent('decorateGvizCharts');
  </script>
<script type="text/javascript">
          JOT_setupPostRenderingManager();
        </script>
<script type="text/javascript">
          JOT_postEvent('renderPlus', null, 'sites-chrome-main');
        </script>
<div id="server-timer-div" style="display:none"> </div>
<script type="text/javascript">
          window.jstiming.load.tick('render');
          JOT_postEvent('usercontentrendered', this);
        </script>
</body>
</html>
