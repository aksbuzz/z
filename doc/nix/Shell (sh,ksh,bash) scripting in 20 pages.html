<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Shell (sh,ksh,bash) scripting in 20 pages
</TITLE>
</HEAD>
<BODY bgcolor="cornsilk">

 
<p>
  
 




 















<p><center><H1><FONT color=#003300>Shell scripts in 20 pages</FONT></H1></center>
<center><H3><FONT color=teal>A guide to writing shell scripts for C/C++/Java and unix programmers</FONT></H3></center>
<center><H3><FONT color=teal>Russell Quong</FONT></H3></center>
<center><H3><FONT color=teal>Oct  3 2008 - Document version 2002a </FONT></H3></center>

<p>

<p>Keywords: Shell documentation, Shell tutorial, Shell beginners, Guide to
shell scripts.  (For internet search engines.)

<p>

<p><STRONG><FONT color=maroon>This is a work in progess; you will find unfinished sections,
paragraphs and even sentences.</FONT></STRONG>

<p>Table of Contents <a name="LtohTOCentry-0"></a>

<ol>
  <li><a href="#LtohTOCentry-1">Introduction</a>
<ul>
  <li><a href="#LtohTOCentry-2">What is a shell?</a>
  <li><a href="#LtohTOCentry-3">My own history with Unix shells</a>
  <li><a href="#LtohTOCentry-4">Useful links</a>
</ul>
  <li><a href="#LtohTOCentry-5">The Operating System</a>
<ul>
  <li><a href="#LtohTOCentry-6">Why program in the shell instead of (Perl, Python, etc)?</a>
  <li><a href="#LtohTOCentry-7">Interactive versus scripts</a>
  <li><a href="#LtohTOCentry-8">Overall evaluation</a>
  <li><a href="#LtohTOCentry-9">Command processing I</a>
</ul>
  <li><a href="#LtohTOCentry-10">Interactive Use of shells</a>
<ul>
  <li><a href="#LtohTOCentry-11">Setting your prompt</a>
  <li><a href="#LtohTOCentry-12">Real or physical paths (bash)</a>
</ul>
  <li><a href="#LtohTOCentry-13">Processes or jobs or tasks</a>
  <li><a href="#LtohTOCentry-14">Variables</a>
<ul>
  <li><a href="#LtohTOCentry-15">Environment (or public) variables</a>
  <li><a href="#LtohTOCentry-16">Common environment variables</a>
</ul>
  <li><a href="#LtohTOCentry-17">Scripting</a>
  <li><a href="#LtohTOCentry-18">True and false</a>
  <li><a href="#LtohTOCentry-19">Relational operators</a>
<ul>
  <li><a href="#LtohTOCentry-20">If</a>
  <li><a href="#LtohTOCentry-21">While</a>
  <li><a href="#LtohTOCentry-22">For</a>
  <li><a href="#LtohTOCentry-23">Case</a>
</ul>
  <li><a href="#LtohTOCentry-24">Syntax of control structures</a>
<ul>
  <li><a href="#LtohTOCentry-25">Quick summary of special shell operation</a>
  <li><a href="#LtohTOCentry-26">Testing if it is an interactive shell</a>
  <li><a href="#LtohTOCentry-27">Conditional Tests</a>
  <li><a href="#LtohTOCentry-28">Clarification A</a>
  <li><a href="#LtohTOCentry-29">Conditional Assignment</a>
</ul>
  <li><a href="#LtohTOCentry-30">I/O redirection</a>
  <li><a href="#LtohTOCentry-31">Debugging Scripts</a>
  <li><a href="#LtohTOCentry-32">Command line argument processing</a>
<ul>
  <li><a href="#LtohTOCentry-33">Special variables</a>
</ul>
  <li><a href="#LtohTOCentry-34">Tilde, brace, and globbing expansions</a>
<ul>
  <li><a href="#LtohTOCentry-35">Globbing and Filename expansion</a>
  <li><a href="#LtohTOCentry-36">Filename expansion</a>
</ul>
  <li><a href="#LtohTOCentry-37">Arithmetic</a>
  <li><a href="#LtohTOCentry-38">Back tick expansion or command substitution</a>
  <li><a href="#LtohTOCentry-39">Embedding verbatim text with here documents</a>
  <li><a href="#LtohTOCentry-40">Process management</a>
  <li><a href="#LtohTOCentry-41">Useful commands</a>
  <li><a href="#LtohTOCentry-42">Reading input</a>
  <li><a href="#LtohTOCentry-43">Some useful functions</a>
  <li><a href="#LtohTOCentry-44">Tips for writing scripts</a>
  <li><a href="#LtohTOCentry-45">Tips, tricks and examples</a>
<ul>
  <li><a href="#LtohTOCentry-46">Seeing variables</a>
  <li><a href="#LtohTOCentry-47">Doing glob matching</a>
  <li><a href="#LtohTOCentry-48">Extracting data</a>
  <li><a href="#LtohTOCentry-49">Precede debugging/verbose messages with common prefix</a>
  <li><a href="#LtohTOCentry-50">No full paths</a>
  <li><a href="#LtohTOCentry-51">Finding executables in a script</a>
  <li><a href="#LtohTOCentry-52">Guarenteed Cleanup</a>
  <li><a href="#LtohTOCentry-53">Simple regular expression substitution</a>
  <li><a href="#LtohTOCentry-54">Floating point math and base calculations</a>
  <li><a href="#LtohTOCentry-55">One liners</a>
  <li><a href="#LtohTOCentry-56">Sending the output of multiple commands</a>
</ul>
  <li><a href="#LtohTOCentry-57">Final thoughts</a>
</ol>
</ol>


<p><STRONG><FONT color=maroon>This is a work in progess; you will find unfinished sections,
paragraphs and even sentences.</FONT></STRONG>

<p><a name="LtohTOCentry-1"></a>
<hr><H2><FONT color=black>Introduction</FONT></H2>

<p>This document assumes you are using bash version 2; most of the examples
will work for sh and ksh too.  

<p>A PDF version of this file is at
<a href="http://www.quong.com/shellin20/shellin20.pdf"> http://www.quong.com/shellin20/shellin20.pdf </a>.

<p><a name="LtohTOCentry-2"></a>
<H3><FONT color=teal>What is a shell?</FONT></H3>

<p>A shell is a program that reads commands and executes them.  Another
name for a shell is a <EM>command interpreter</EM>.  For those who only
know Windows: MS-DOS is a shell.

<p>Current Unix shells, such as bash, ksh, and tcsh, provide numerous
conveniences and features for both interactive and programmatic purposes
and are complicated programs in their own right.  The <FONT face="monospace" color="#000099">bash</FONT>
manual page is over 50 pages of dense documentation.  Finally, if all
you have used is MS-DOS, be aware it is an extremely primitive shell.

<p>There are many (30+) Unix shells, but the most popular are <FONT face="monospace" color="#000099">sh</FONT>,
<FONT face="monospace" color="#000099">ksh</FONT>, <FONT face="monospace" color="#000099">bash</FONT>, <FONT face="monospace" color="#000099">csh</FONT> and <FONT face="monospace" color="#000099">tcsh</FONT>.

<p><a name="LtohTOCentry-3"></a>
<H3><FONT color=teal>My own history with Unix shells</FONT></H3>

<p>I started using <FONT face="monospace" color="#000099">csh</FONT> many years ago as an undergraduate, because
I was too stupid to figure out the <FONT face="monospace" color="#000099">/bin/sh</FONT> syntax, in
particular <SAMP>${var:-val}</SAMP>.  Despite encountering many
mysterious <TT><FONT color=#660000>/bin/sh</FONT></TT> scripts and having to use <FONT face="monospace" color="#000099">make</FONT>,
which uses <FONT face="monospace" color="#000099">/bin/sh</FONT>, I resisted <FONT face="monospace" color="#000099">sh</FONT> and wrote csh shell
scripts and used the <FONT face="monospace" color="#000099">tcsh</FONT> as my login shell.  Finally, in 1999,
I couldn't stand <FONT face="monospace" color="#000099">csh</FONT> scripting any more, and "re"-learned
/bin/sh.

<p><a name="LtohTOCentry-4"></a>
<H3><FONT color=teal>Useful links</FONT></H3>

<p><table border>
<TR> <TD align=left>   Short overview of different shells </TD> <TD align=left>
    http://www.faqs.org/faqs/unix-faq/shell/shell-differences/ </TD></TR>
<TR> <TD align=left>   Short overview of different shells </TD> <TD align=left>   
    http://www.faqs.org/faqs/unix-faq/faq/part5/ </TD></TR>
<TR> <TD align=left>   List of csh problems </TD> <TD align=left> 
    http://www.faqs.org/faqs/unix-faq/shell/csh-whynot/ </TD></TR>
</table>

<p><a name="LtohTOCentry-5"></a>
<hr><H2><FONT color=black>The Operating System</FONT></H2>

<p>A typical home user is completetely insulated from the OS.  So when
someone says, "I really like computer XXX (e.g. the Mac or Windows 95 or
Unix)", they are NOT talking about the operating system.  Rather they
are talking about the user interface or <EM>UI</EM> on top of the OS.

<p>Externally, an operating system is a programming API, typically in the C
programming language.  The API lets some other program do low level
operations like:

<p><table border>
<TR> <TD align=left>   Unix API call </TD> <TD align=left> Description </TD></TR>
<TR> <TD align=left>   exec </TD> <TD align=left> run a program, given a fully specified command </TD></TR>
<TR> <TD align=left>   open </TD> <TD align=left> open file or some other I/O stream </TD></TR>
<TR> <TD align=left>   read/write </TD> <TD align=left> read or write data to a file descriptor </TD></TR>
</table>

<p>Directly interacting with the OS is incessantly tedious, as the OS is
very picky and works at a low level.  Its akin to communication via
Morse Code.

<p>Instead, people use graphical environments (like the Mac or Win32) or
command line interpreters like Unix <EM>shells</EM> or the (very
minimal) MSDOS prompt.  

<p><a name="LtohTOCentry-6"></a>
<H3><FONT color=teal>Why program in the shell instead of (Perl, Python, etc)?</FONT></H3>

<p>1) You may not have Perl or Python available.  E.g. for system
administration, when the system is first coming up, the shell maybe your
only option.

<p>2) For simple file based manipulation, the shell is terser and cleaner
than Perl.

<p><a name="LtohTOCentry-7"></a>
<H3><FONT color=teal>Interactive versus scripts</FONT></H3>

<p>When you manually type commands to the shell, you are running an
<EM>interactive shell</EM>.  The shell features beneficial for
interactive use are different from those needed when running a script,
in which the shell reads commands from a file.

<p>In interactive use, shell features that minimize typing and tedium are
important.  For scripting or programmatic use, flexibility, power and
expressiveness are more imporant.

<p><a name="LtohTOCentry-8"></a>
<H3><FONT color=teal>Overall evaluation</FONT></H3>

<p><table border>
<TR> <TD align=left>   Shell </TD> <TD align=left> Interactive </TD> <TD align=left> Scripting </TD></TR>
<TR> <TD align=left>   sh    </TD> <TD align=left>   C-        </TD> <TD align=left>  B        </TD></TR>    
<TR> <TD align=left>   ksh   </TD> <TD align=left>   B+        </TD> <TD align=left>  A-       </TD></TR>    
<TR> <TD align=left>   bash  </TD> <TD align=left>   A         </TD> <TD align=left>  A        </TD></TR>
<TR> <TD align=left>   csh   </TD> <TD align=left>   B+        </TD> <TD align=left>  C-       </TD></TR>    
<TR> <TD align=left>   tcsh  </TD> <TD align=left>   A         </TD> <TD align=left>  C+       </TD></TR>
<TR> <TD align=left>   zsh   </TD> <TD align=left>   A- (?)    </TD> <TD align=left>  A (?)    </TD></TR>
<TR> <TD align=left>   rc/es </TD> <TD align=left>   A- (?)    </TD> <TD align=left>  A (?)    </TD></TR>
</table>

<p><a name="LtohTOCentry-9"></a>
<H3><FONT color=teal>Command processing I</FONT></H3>

<p>Consider how the shell processes the following command.

<p><FONT color=navy><PRE>
  % ls -l *.c &gt; listing.out
</PRE></FONT>

<p><OL>
  <li><strong></strong> Split the command into words based on whitespace.  Here, there
  are three words (ls) (-l) and (*.c) before the redirection (&gt;) word.
  Each word is processed separately.

<p>  <li><strong></strong> Set aside the redirection specification (&gt; listing.out).  

<p>  <li><strong></strong> We redirect standard out to the file <TT><FONT color=#660000>listing.out</FONT></TT>.

<p>  <li><strong></strong> We apply globbing (or pathname expand) on the <FONT face="monospace" color="#000099">*</FONT> in
  the <SAMP>*.c</SAMP> word, replacing *.c with matching file names, say
  <TT><FONT color=#660000>apple.c</FONT></TT>, <TT><FONT color=#660000>banana.c</FONT></TT> and <TT><FONT color=#660000>cherry.c</FONT></TT>.
  The command now consists of the words (ls) (-l) (apple.c) (banana.c)
  (cherry.c).

<p>  <li><strong></strong> The first word (ls) is the program to run.  We search each
  directory in the <FONT face="monospace" color="#000099">PATH</FONT> variable for an executable <FONT face="monospace" color="#000099">ls</FONT>
  file; we execute the first one we find.
</OL>

<p>We can break up the command into parts as follows.

<p><table border>
<TR> <TD align=left>   Term </TD> <TD align=left> What </TD> <TD align=left> Example </TD></TR>
<TR> <TD align=left>   program </TD> <TD align=left> first word in command </TD> <TD align=left> ls </TD></TR>
<TR> <TD align=left>   flags   </TD> <TD align=left> options that affect the command </TD> <TD align=left> -l </TD></TR>
<TR> <TD align=left>   arguments </TD> <TD align=left> all words but the program </TD> <TD align=left> -l *.c </TD></TR>
</table>

<p><a name="LtohTOCentry-10"></a>
<hr><H2><FONT color=black>Interactive Use of shells</FONT></H2>

<p>For interactive use, I prefer <FONT face="monospace" color="#000099">bash</FONT> and <FONT face="monospace" color="#000099">tcsh</FONT>, because
they have easily accessible filename and command completion (via TAB)
and good editing capabilities.  Note the phrase <EM>completes</EM> means
that if you partially type a word, the shell will either

<p><table border>
<TR> <TD align=left>   On a ... </TD> <TD align=left> the shell does ... </TD></TR>
<TR> <TD align=left>   unique match </TD> <TD align=left> finishes the rest of the word </TD></TR>
<TR> <TD align=left>   multiple matches </TD> <TD align=left> shows all possible completions of the partial word </TD></TR>
</table>

<p>The features I rely on from most important to least important are

<p><table border>
<TR> <TD align=left>   What </TD> <TD align=left> Keys </TD> <TD align=left> Description </TD></TR>
<TR> <TD align=left>   filename completion </TD> <TD align=left> TAB </TD> <TD align=left> completes partially typted file,path names </TD></TR>
<TR> <TD align=left>   command history access </TD> <TD align=left> CNTL-p (CNTL-n ) </TD> <TD align=left> fetch the previous (next)
  command to edit or execute </TD></TR>
<TR> <TD align=left>   command history search </TD> <TD align=left> CNTL-r phrase </TD> <TD align=left> (bash) reverse search
for phrase (as you type it) through the history.  CNTL-r again to skip
back to the previous command matching.  Just try it.  </TD></TR>
<TR> <TD align=left>   command completion </TD> <TD align=left> TAB </TD> <TD align=left> completes the command name </TD></TR>
<TR> <TD align=left>   CDPATH </TD> <TD align=left> &nbsp; </TD> <TD align=left> variable of directories to search when you type <FONT face="monospace" color="#000099">cd</FONT> </TD></TR>
</table>

<p><STRONG>ksh:</STRONG> To enable command editing in <FONT face="monospace" color="#000099">ksh</FONT>, use <FONT face="monospace" color="#000099">set
-o emacs</FONT> or <FONT face="monospace" color="#000099">set -o vi</FONT>.  Skip the <FONT face="monospace" color="#000099">fc</FONT>

<p><a name="LtohTOCentry-11"></a>
<H3><FONT color=teal>Setting your prompt</FONT></H3>

<p>Set the <FONT face="monospace" color="#000099">PS1</FONT> (prompt string 1) variable.  In <FONT face="monospace" color="#000099">PS1</FONT>, the
following escape sequences can be used.  I have listed only the most
useful; see the bash man page for a full listing.

<p><table border>
<TR> <TD align=left>   \h </TD> <TD align=left> hostname </TD> <TD align=left> \u </TD> <TD align=left> user name </TD></TR>
<TR> <TD align=left>   \H </TD> <TD align=left> hostname.domainname </TD> <TD align=left> \w </TD> <TD align=left> current working directory (CWD) </TD></TR>
<TR> <TD align=left>   \n </TD> <TD align=left> newline </TD> <TD align=left> \W </TD> <TD align=left> basename of CWD </TD></TR>
<TR> <TD align=left>   \r </TD> <TD align=left> carriage return </TD> <TD align=left> \! </TD> <TD align=left> history number of the current command </TD></TR>
<TR> <TD align=left>   \s </TD> <TD align=left> shell name </TD> <TD align=left> $ </TD> <TD align=left> if UID is 0 (root), use a '#', else use a '$' </TD></TR>
</table>

<p>I personally set

<pre>
  PS1='\h \! \w\\$ '

  crank 647 ~/src/template$ ls            # my prompt before 'ls'
</pre>

<p><a name="LtohTOCentry-12"></a>
<H3><FONT color=teal>Real or physical paths (bash)</FONT></H3>

<p>In the presense of symbolic links and home directories, bash by default
uses the logical directory structure.  To force bash to show the actual,
real or physical directory structure use <FONT face="monospace" color="#000099">cd -P <i>&lt;dir&gt;</i></FONT>; I alias
<FONT face="monospace" color="#000099">cdp</FONT> to <FONT face="monospace" color="#000099">cd -P . </FONT>. As an example if,
<FONT face="monospace" color="#000099">/home/quong</FONT> is a symbolic link to
<TT><FONT color=#660000>/box22/disk88/c/quong</FONT></TT>, then 

<p><FONT color=navy><PRE>
  % cd /home/quong      # current dir as /home/quong
  % cd ..               # cd to /home
  % cd -P /home/quong   # current dir as /box22/disk88/c/quong
  % cd ..               # cd to /box22/disk88/c
</PRE></FONT>

<p><a name="LtohTOCentry-13"></a>
<hr><H2><FONT color=black>Processes or jobs or tasks</FONT></H2>

<p>Each command run by a shell is a separate child process, whether run
interactively or via a script.  The child process inherits various
values, such as <i>(i)</i> who is running the command, <i>(ii)</i> the current
directory, and <i>(iii)</i> the environment variables.

<p><a name="LtohTOCentry-14"></a>
<hr><H2><FONT color=black>Variables</FONT></H2>

<p>Shell variables contain string values, though you can force the values
to be used numerically.  Normal variables are local/private to one shell
job/process and are only accessible (or visible) to the shell in which
they are set.  If you a globally visible variable, you must
<SAMP>export</SAMP> it.

<p>Assign to variables using <FONT face="monospace" color="#000099">=</FONT> <EM>with no surrounding space</EM>
between variable name and value.  Access the value of variable by using
a $ before the variable name, e.g. <SAMP>$showWarnings</SAMP>.

<p><FONT color=navy><PRE>
 % color=red                   # correct
 % color= red                  # WRONG, space after equal
 % echo I want a ${color}der than $color shirt  # I want a redder than red  shirt
</PRE></FONT>

<p>If there is any ambiguity what the variable name is, you can use
<FONT face="monospace" color="#000099">${varname}</FONT>.  In the preceding example, see how we echo'ed
"redder".

<p>Because the shell uses space to break up commands, to store a string
value with a space in a variable, use quotes.

<p><FONT color=navy><PRE>
  % colors="red green blue"
  % for c in $colors ; do echo $c ; done
red
green
blue
  % for c in "$colors" ; do echo $c ; done
red green blue  
</PRE></FONT>

<p><a name="LtohTOCentry-15"></a>
<H3><FONT color=teal>Environment (or public) variables</FONT></H3>

<p>Public or <EM>environment variables</EM> are accessible by all child
processes/jobs of the shell.

<p><a name="LtohTOCentry-16"></a>
<H3><FONT color=teal>Common environment variables</FONT></H3>

<p><table border>
<TR> <TD align=left>   PATH </TD> <TD align=left> dirs to search for commands </TD></TR>
<TR> <TD align=left>   SHELL </TD> <TD align=left> path of shell </TD></TR>
<TR> <TD align=left>   TERM </TD> <TD align=left> terminal type </TD></TR>
<TR> <TD align=left>   USER </TD> <TD align=left> user (login) name </TD></TR>
<TR> <TD align=left>   HOME </TD> <TD align=left> home dir of user </TD></TR>
<TR> <TD align=left>   PS1  </TD> <TD align=left> main interactive prompt (ba/k/sh) </TD></TR>
<TR> <TD align=left>   CDPATH </TD> <TD align=left> dirs to search when you do a cd or pushd </TD></TR>
</table>

<p><a name="LtohTOCentry-17"></a>
<hr><H2><FONT color=black>Scripting</FONT></H2>

<p>(To be done.)

<p><a name="LtohTOCentry-18"></a>
<hr><H2><FONT color=black>True and false</FONT></H2>

<p>For various control constructs, like <FONT face="monospace" color="#000099">if</FONT>, <FONT face="monospace" color="#000099">while</FONT>,
<FONT face="monospace" color="#000099">&amp;&amp;</FONT> and <FONT face="monospace" color="#000099">||</FONT>, the shell runs a command and the command
has an exits or returns either true (success) and false (failure).
Every command in Unix has an exit value.  However, unlike C/C++, true
is 0 (zero) and false is anything else, non-zero.  I remember is this
notation because there is only one way for a command to succeed but
there are many ways a command can fail (no such file, missing
permissions, out of disk space, bad name, and many others).

<p>Each command returns a (normally) hidden integer value.  In C/C++
programs, the return value of <FONT face="monospace" color="#000099">int main()</FONT> or the parameter
passed to the <FONT face="monospace" color="#000099">exit()</FONT> function.  Here is the C source code for a
that always returns true.

<pre>
int main (int argc, char* [] argv) { return 0; } 
</pre>
<p>
The special variable <FONT face="monospace" color="#000099">$?</FONT> contains the exit status of the last command
run, however you should rarely have to access this variable.  Evaluate
the command in the if/while directly.  The following example shows how
to process a file <SAMP>$fx</SAMP> if it contains a java class.

<p><FONT color=navy><PRE>
  # poor, too wordy
grep -c ~class $fx &gt; /dev/null
if [ $? = 0 ]; then 
  process $fx
fi

<p>  # much better, directly run grep
if grep -c <sup>c</sup>lass $fx &gt; /dev/null; then
  process $fx
fi
</PRE></FONT>

<p><a name="LtohTOCentry-19"></a>
<hr><H2><FONT color=black>Relational operators</FONT></H2>

<p><a name="LtohTOCentry-20"></a>
<H3><FONT color=teal>If</FONT></H3>

<p>The <FONT face="monospace" color="#000099">if</FONT> construct looks as follows with an optional else and
multiple optional elif (else if).  

<p><FONT color=navy><PRE>
if EXPR; then  <br>
&nbsp;&nbsp; body <br>
fi <br> 
if [ -d $ff ]; then  <br>
&nbsp;&nbsp; echo "Dir: $ff"  <br>
fi <br> 
</PRE></FONT>

<p><FONT color=navy><PRE>
if [ -d $ff ]; then  <br>
&nbsp;&nbsp; echo "Directory: $ff, here is the total size:"  <br>
&nbsp;&nbsp; du -s $ff  <br>
elif [ -f $ff ]; then  <br>
&nbsp;&nbsp; echo "File: $ff" <br>
else  <br>
&nbsp;&nbsp; echo "What the heck is $ff?"  <br>
&nbsp;&nbsp; ls -l $ff  <br>
fi <br> 
</PRE></FONT>

<p><a name="LtohTOCentry-21"></a>
<H3><FONT color=teal>While</FONT></H3>

<p>The <FONT face="monospace" color="#000099">while</FONT> command is the only way to loop in the shell.
The looping continues so long as the EXPR returns true.

<pre>
  while EXPR ; do
    body
  done
</pre>
<p>
For example, to store all the command line arguments but the last one
in <FONT face="monospace" color="#000099">allbutlast</FONT> in a script

<pre>
#! /bin/bash

allbutlast=""
while [ $# -gt 1 ]; do
  allbutlast="$allbutlast $1"
  shift
done
last=$1
shift
</pre>
<p>
<a name="LtohTOCentry-22"></a>
<H3><FONT color=teal>For</FONT></H3>

<p>The <FONT face="monospace" color="#000099">for</FONT> construct is a "foreach" in that a variable is assigned
each value in a list one by one.  For example, to find out which files in
the subdirectory <TT><FONT color=#660000>infodir</FONT></TT> are text files, we run the
<FONT face="monospace" color="#000099">file</FONT> command and grep for the word <FONT face="monospace" color="#000099">text</FONT>.

<pre>
  for VAR in LIST ; do
    body
  done

  for ff in infodir/* ; do
    if file $ff | grep text &gt; /dev/null ; then
      echo "File $ff is text"
    fi
  done    
</pre>
<p>
<a name="LtohTOCentry-23"></a>
<H3><FONT color=teal>Case</FONT></H3>

<p>The case statement lets you determine if a string SSS, which is almost
always contained by a variable VVV, matches any of several "cases".  For
example we test which state a traffic signal is in via:

<pre>
  case $trafficLight in
    red ) echo "stop" ;;
    yellow | orange ) echo "decision time..." ;;
    green ) echo "GO" ;;
    default ) echo "Unknown color ($trafficLight)" ;;  
  esac
</pre>
<p>
The <FONT face="monospace" color="#000099">case</FONT> construct is the only way to apply glob matching to
arbitrary strings.  The following example ask the user a Yes-no question
and then treats any response beginning with a 'y' or 'Y' as a "yes".
Also, any response starting with a 'q' quits out.  Also, note that the
<FONT face="monospace" color="#000099">break</FONT> statement breaks out of the <FONT face="monospace" color="#000099">while</FONT> loop, not the
<FONT face="monospace" color="#000099">case</FONT>, unlike C/C++/Java.

<pre>
while true; do
  echo -n "list the current dir? (y/n) "
  read yn
  case $yn in
    y* | Y* ) ls -l . ; break ;;
    [nN]* )   echo "skipping" ; break ;;
    q* ) exit ;;
    * ) echo "unknown response.  Asking again" ;;
  esac
done  
</pre>
<p>
<a name="LtohTOCentry-24"></a>
<hr><H2><FONT color=black>Syntax of control structures</FONT></H2>

<p>It is possible to write any shell script in a single line.  In practice,
it is sometimes convenient to do so.  For example, in a makefile, shell
commands spanning more than one line are ugly and error prone.

<p>When processing control constructions, the ba/k/sh shells need a
<EM>delimiter</EM>, either a <FONT face="monospace" color="#000099">newline</FONT> or a <FONT face="monospace" color="#000099">;</FONT>
(semi-colon), to terminate arbitrary commands.  Thus, after the keywords
<FONT face="monospace" color="#000099">if, then, do, while</FONT> we do not need a delimiter, but before the
<FONT face="monospace" color="#000099">fi</FONT> or <FONT face="monospace" color="#000099">done</FONT>, we need a delimeter indicating the end of
the previous command.  As an example, remove the delimiters from the
following legal (!) command to see the ensuing confusion.

<p><FONT color=navy><PRE>
  % if echo then fi if then ; then ls fi fi ; fi
</PRE></FONT>

<p>Thus in the following, <font color=red>DELIM</font> means either a <FONT face="monospace" color="#000099">newline</FONT> or a
<FONT face="monospace" color="#000099">;</FONT> delimiter.  Thus the following four if-statements are all
equivalent.

<p><FONT color=navy><PRE>
  if EXPR <font color=red>DELIM</font> then STMT(S) <font color=red>DELIM</font> fi   # general syntax
  if [ -f /bin/mv ]<font color=red>DELIM</font> then echo "looks like unix" <font color=red>DELIM</font> fi
  if [ -f /bin/mv ]; then echo "looks like unix" ; fi
  if [ -f /bin/mv ]; then
    echo "looks like unix"
  fi
  if [ -f /bin/mv ]
      then
    echo "looks like unix" ; fi
</PRE></FONT>

<p>The syntax for control constructs is

<p><table border>
<TR> <TD align=left>   if </TD> <TD align=left> if EXPR <font color=red>DELIM</font> then STMT(S) <font color=red>DELIM</font> fi </TD></TR>
<TR> <TD align=left>   if else </TD> <TD align=left> if EXPR <font color=red>DELIM</font> then STMT(S) <font color=red>DELIM</font> elif EXPR ; then STMT(S) <font color=red>DELIM</font> fi </TD></TR>
<TR> <TD align=left>   for </TD> <TD align=left> for VAR in LIST <font color=red>DELIM</font> do STMT(S) <font color=red>DELIM</font> done </TD></TR>
<TR> <TD align=left>   while </TD> <TD align=left> while EXPR <font color=red>DELIM</font> do STMT(S) <font color=red>DELIM</font> done </TD></TR>
<TR> <TD align=left>   case </TD> <TD align=left> case VALUE in [[ PATTERN [ | PATTERNS ] ) STMTS ;; ] esac </TD></TR>
</table>

<p><a name="LtohTOCentry-25"></a>
<H3><FONT color=teal>Quick summary of special shell operation</FONT></H3>

<p><FONT color=navy><PRE>
  # boolean testing
  if [[ <i>file =&nbsp; .*cc</i> ]]; ... ; fi    # NEW, supports regex op =&nbsp;
  if [ -f file.txt ]; then ... ; fi    # OLD
  if test -f file; then ... ; fi       # OLD, external test (ugh)

<p>  # capturing command output
  result=$(echo *.cc | head -33)      # NEW
  result=<b><font color=#000099>`</font></b>echo *.cc | head -33)        # OLD
  
<p>  # Doing arithmetic
  t=$((t * (t-1) + 3))              # arithmetic evaluation  
</PRE></FONT>

<p><a name="LtohTOCentry-26"></a>
<H3><FONT color=teal>Testing if it is an interactive shell</FONT></H3>

<p>All shells read a startup file, in which you can set and customize
various settings (variables, aliases, functions, prompt, terminal
settings).  There are three cases to consider, (a) when shell handles an
interactive login, (b) when a remote shell runs a command and (c) when
the shell reads a script.

<p>When you interactively "login" you get an interacitve shell and you
probably want to (heavily) customize its use.  However if you run a
command remotely, say via the Unix rsh, rcp or rsync commands, you start
a non-interactive remote shell to run the remote command and you usually
to set the path correctly.  In particular, you <STRONG>must not</STRONG> print
any messages when the remote shell start up.

<p>To test if a shell is interactive, <i>(i)</i> test for the existance of the
shell prompt string variable <FONT face="monospace" color="#000099">PS1</FONT> or <i>(ii)</i> run <FONT face="monospace" color="#000099">tty -s</FONT>
which returns true (0) for an interactive shell, as there is an
underlying tty.

<p><a name="LtohTOCentry-27"></a>
<H3><FONT color=teal>Conditional Tests</FONT></H3>

<p>To perform a conditional test on files, strings or numbers, use either
<FONT face="monospace" color="#000099">[ <EM>expr</EM> ]</FONT> or <FONT face="monospace" color="#000099">test <EM>expr</EM></FONT> as in the
following two examples.

<p><FONT color=navy><PRE>
  if [[ -f $file  ]]; then ... ; fi    # NEW, supports regex op =&nbsp;
  if [ -f file.txt ]; then ... ; fi
  if test -f file; then ... ; fi
</PRE></FONT>

<p>The following table shows the conditional tests provided by bash from
most to least common in this authors experience.  Some descriptions are
directly from the bash man page.

<p><table border>
<TR> <TD align=center colspan=2>String operations </TD></TR>
<TR> <TD align=left> string1 = string2 </TD> <TD align=left> True  if  the  strings are equal.  </TD></TR>
<TR> <TD align=left> string1 != string2 </TD> <TD align=left>
      True if the strings are not equal. </TD></TR>
<TR> <TD align=left> -z string </TD> <TD align=left>
      True if the length of string is zero.</TD></TR>
<TR> <TD align=left> string </TD> <TD align=left> True if the length of string is non-zero. </TD></TR>
<TR> <TD align=left> -n string </TD> <TD align=left> True if the length of string is non-zero. </TD></TR>
<TR> <TD align=left> string1 == string2 </TD> <TD align=left> (Bash only) True  if  the  strings are equal. </TD></TR>
<TR> <TD align=left> str =&nbsp; regex </TD> <TD align=left> (Bash in [[ ]] only) True iff regex matches str.
BASH_REMATCH[0] = entire match, BASH_REMATCH[i] = i-th paren submatch.
  </TD></TR>
<TR> <TD align=left> -o optname </TD> <TD align=left> 
      True  if  shell option optname is enabled.  See the
      list of options under the  description  of  the  -o
      option to the set builtin below.</TD></TR>
</table>

<p><table border>
<TR> <TD align=center colspan=2>Numeric operations </TD></TR>
<TR> <TD align=left> arg1 OP arg2 </TD> <TD align=left>
      OP is one of -eq,  -ne,  -lt,  -le,  -gt,  or  -ge.
      These  arithmetic  binary  operators return true if
      arg1 is equal to, not equal  to,  less  than,  less
      than  or equal to, greater than, or greater than or
      equal to arg2, respectively.  Arg1 and arg2 may  be
      positive or negative integers. </TD></TR>
<TR> <TD align=left> string1 &lt; string2 </TD> <TD align=left>
      True if string1 sorts before string2  lexicographi-
      cally in the current locale. </TD></TR>
<TR> <TD align=left> string1 &gt; string2 </TD> <TD align=left>
      True  if  string1 sorts after string2 lexicographi-
      cally in the current locale. </TD></TR>
</table>

<p><table border>
<TR> <TD align=center colspan=2>File operations </TD></TR>
<TR> <TD align=left> -e file </TD> <TD align=left>
      True if file exists.</TD></TR>
<TR> <TD align=left> -d file </TD> <TD align=left>
      True if file exists and is a directory.</TD></TR>
<TR> <TD align=left> -f file </TD> <TD align=left>
      True if file exists and is a regular file.</TD></TR>
<TR> <TD align=left> -L file </TD> <TD align=left>
      True if file exists and is a symbolic link.</TD></TR>
<TR> <TD align=left> -r file </TD> <TD align=left>
      True if file exists and is readable.</TD></TR>
<TR> <TD align=left> -w file </TD> <TD align=left>
      True if file exists and is writable.</TD></TR>
<TR> <TD align=left> -x file </TD> <TD align=left>
      True if file exists and is executable.</TD></TR>
<TR> <TD align=left> file1 -nt file2 </TD> <TD align=left>
      True  if  file1 is newer (according to modification
      date) than file2. </TD></TR>
<TR> <TD align=left> file1 -ot file2 </TD> <TD align=left>
      True if file1 is older than file2. </TD></TR>
<TR> <TD align=left> file1 -ef file2 </TD> <TD align=left>
      True if file1 and file2 have the  same  device  and
      inode numbers.</TD></TR> </TD></TR>
<TR> <TD align=center colspan=2>Less frequently used operations </TD></TR>
<TR> <TD align=left> -a file </TD> <TD align=left>
      True if file exists.</TD></TR>
<TR> <TD align=left> -b file </TD> <TD align=left>
      True if file exists and is a block special file.</TD></TR>
<TR> <TD align=left> -c file </TD> <TD align=left>
      True  if  file  exists  and  is a character special
      file.</TD></TR>
<TR> <TD align=left> -g file </TD> <TD align=left>
      True if file exists and is set-group-id.</TD></TR>
<TR> <TD align=left> -h file </TD> <TD align=left>
      True if file exists and is a symbolic link.</TD></TR>
<TR> <TD align=left> -k file </TD> <TD align=left>
      True if file exists and its "sticky'' bit is  set.</TD></TR>
<TR> <TD align=left> -p file </TD> <TD align=left>
      True if file exists and is a named pipe (FIFO).</TD></TR>
<TR> <TD align=left> -s file </TD> <TD align=left>
      True  if  file  exists  and has a size greater than
      zero.</TD></TR>
<TR> <TD align=left> -t fd  </TD> <TD align=left> True if file descriptor fd is open and refers to a 
      terminal.</TD></TR>
<TR> <TD align=left> -u file </TD> <TD align=left>
      True if file exists and its set-user-id bit is set.</TD></TR>
<TR> <TD align=left> -O file </TD> <TD align=left>
      True if file exists and is owned by  the  effective
      user id.</TD></TR>
<TR> <TD align=left> -G file </TD> <TD align=left>
      True  if  file exists and is owned by the effective
      group id.</TD></TR>
<TR> <TD align=left> -S file </TD> <TD align=left>
      True if file exists and is a socket.</TD></TR>
<TR> <TD align=left> -N file </TD> <TD align=left>
      True if file exists and has been modified since  it
      was last read. </TD></TR>
</table>

<p><a name="LtohTOCentry-28"></a>
<H3><FONT color=teal>Clarification A</FONT></H3>

<p>Both the <FONT face="monospace" color="#000099">if</FONT> and the <FONT face="monospace" color="#000099">while</FONT> constrol constructs take
commands.  However, what about the common syntax <FONT face="monospace" color="#000099">if [
<EM>expr</EM> ]; ...</FONT>?  The simple but non-obvious answer is that
<FONT face="monospace" color="#000099">[</FONT> (yes, left bracket) is a (built-in) command, which parses its
arguments.  The right bracket argument is needed so the <FONT face="monospace" color="#000099">[</FONT>
command knows its own last argument.  You need spaces between each
argument because these are command line parameters, i.e. there is no
parsing of values.

<p><a name="LtohTOCentry-29"></a>
<H3><FONT color=teal>Conditional Assignment</FONT></H3>

<p>Many times we want a conditionally assign a value to a variable VVV.
The syntax <SAMP>VVV=${ZZZ:-DefaultVal}</SAMP> is equivalent to

<pre>
VVV=${ZZZ:-DefaultVal\}
     # same as 
if [ "$ZZZ" != "" ]; then
  VVV=$ZZZ
else
  VVV=DefaultVal
fi
</pre>
<p>
Thus we assign the value of <FONT face="monospace" color="#000099">$ZZZ</FONT> to VVV if <FONT face="monospace" color="#000099">ZZZ</FONT> has a
value, otherwise we assign DefaultVal.

<p><a name="LtohTOCentry-30"></a>
<hr><H2><FONT color=black>I/O redirection</FONT></H2>

<p>One strength of Unix and its shells is the ability to redirect I/O
to/from files and or other commands.  For example, to see the 5 newest
files in the directory DDD, we list the files sorted by time (ls -t) and
select the first 6 lines (head -6) via:

<pre>
  ls -t DDD | head -6
</pre>
<p>
Deep down in Unix, all files are refereced by a integer <EM>file
descriptor</EM>, which is the index into a table of the open streams (files)
that each process has.  There are three standard pre-opened streams in
Unix (actually, the shell pre-opens these three streams.)

<p><table border>
<TR> <TD align=left>   File Desc </TD> <TD align=left> name </TD> <TD align=left> by default </TD></TR>
<TR> <TD align=left>   0      </TD> <TD align=left> stdin </TD> <TD align=left> keyboard </TD></TR>
<TR> <TD align=left>   1      </TD> <TD align=left> stdout </TD> <TD align=left> screen, buffered, not-flushed  </TD></TR>
<TR> <TD align=left>   2      </TD> <TD align=left> stderr </TD> <TD align=left> screen, always flushed </TD></TR>
</table>

<p>The I/O redirection directives are:

<p><table border>
<TR> <TD align=left>   &gt; filename </TD> <TD align=left> send stdout to the file <TT><FONT color=#660000>filename</FONT></TT> </TD></TR>
<TR> <TD align=left>   <i>n&gt;</i> filename </TD> <TD align=left> redirect FD <FONT face="monospace" color="#000099">n</FONT> to the file <TT><FONT color=#660000>filename</FONT></TT> </TD></TR>
<TR> <TD align=left>   n<i>&gt;&amp;</i>k </TD> <TD align=left> redirect FD <FONT face="monospace" color="#000099">n</FONT> to FD <FONT face="monospace" color="#000099">k</FONT> </TD></TR>
<TR> <TD align=left>   <i>|</i> command </TD> <TD align=left> send stdout (FD 1) to the program <FONT face="monospace" color="#000099">command</FONT>  </TD></TR>
</table>

<p>The shell processes directives in order from left to right.  This is
significant for cases where you want to redirect both stdout and stderr.
We explain via the examples below.  And while some of the examples may
seem contrived, this author has used all the examples trying to get real
work done.

<p><table border>
<TR> <TD align=left>   ls &gt; /tmp/list </TD> <TD align=left> send ls output to <TT><FONT color=#660000>/tmp/list</FONT></TT> </TD></TR>
<TR> <TD align=left>   ls &gt; /tmp/list 2&gt; ./err </TD> <TD align=left> as above, but send stderr to <TT><FONT color=#660000>./err</FONT></TT> </TD></TR>
<TR> <TD align=left>   ls &gt; /tmp/list 2&gt;&amp;1 </TD> <TD align=left> send both stdout and stderr to <TT><FONT color=#660000>/tmp/list</FONT></TT> </TD></TR>
<TR> <TD align=left>   ls 2&gt;&amp;1 &gt; /tmp/list </TD> <TD align=left> send stdout to <TT><FONT color=#660000>/tmp/list</FONT></TT> and
  stderr to the screen via the default stdout stream </TD></TR>
<TR> <TD align=left>   ls 2&gt;&amp;1 | less </TD> <TD align=left> send both stdout and stderr to <FONT face="monospace" color="#000099">less</FONT> </TD></TR> 
</table>

<p>Here is a shell function <FONT face="monospace" color="#000099">echoerr</FONT> that echos its arguments to
<FONT face="monospace" color="#000099">stderr</FONT> instead of <FONT face="monospace" color="#000099">stdout</FONT>.  It is useful for generating
error messages in a large script.

<pre>
 \% echoerr () { echo "$@" 1&gt;&2 ; }
 \% echoerr "Oooh.  Not good."
</pre>
<p>
<a name="LtohTOCentry-31"></a>
<hr><H2><FONT color=black>Debugging Scripts</FONT></H2>

<p><OL>
  <li><strong></strong> Use <FONT face="monospace" color="#000099">echo</FONT> statements.

<p>  <li><strong></strong> Run <FONT face="monospace" color="#000099">bash -n script</FONT> to check for syntax errors.

<p>  <li><strong></strong> Use the command <FONT face="monospace" color="#000099">set -v</FONT> to get a verbose dump of each
  line the shell reads.  Use <FONT face="monospace" color="#000099">set +v</FONT> to turn off verbose mode.

<p>  <li><strong></strong> Use the command <FONT face="monospace" color="#000099">set -x</FONT> to see what each command expands
  to.  Again, <FONT face="monospace" color="#000099">set +x</FONT> turns this mode off.

<p></OL>

<p><a name="LtohTOCentry-32"></a>
<hr><H2><FONT color=black>Command line argument processing</FONT></H2>

<p>The command line parameters to a script are stored in the nearly
identical variables <FONT face="monospace" color="#000099">$*</FONT> and <FONT face="monospace" color="#000099">$</FONT>.  The following table
summarizes the variables you would use for command line processing.  For
the example values, assume you wrote a ba/k/sh script
<FONT face="monospace" color="#000099">/usr/bin/args.sh</FONT> and ran it as shown below.

<p><table border>
<TR> <TD align=left>   Variable </TD> <TD align=left> Meaning </TD> <TD align=left> Ex: echoArgs -t two "let's go" </TD></TR>
<TR> <TD align=left>   <SAMP>$*</SAMP>       </TD> <TD align=left> Command line args </TD> <TD align=left> -t two let's go </TD></TR>
<TR> <TD align=left>   <SAMP>$@</SAMP>       </TD> <TD align=left> Command line args </TD> <TD align=left> -t two "let's go" </TD></TR>
<TR> <TD align=left>   <SAMP>$#</SAMP>      </TD> <TD align=left> Number of args    </TD> <TD align=left> 3 </TD></TR>
<TR> <TD align=left>   <SAMP>$0</SAMP>       </TD> <TD align=left> Name of script    </TD> <TD align=left> /usr/bin/args.sh </TD></TR>
<TR> <TD align=left>   <SAMP>$1</SAMP>       </TD> <TD align=left> First arg in $*   </TD> <TD align=left> -t </TD></TR>
<TR> <TD align=left>   <SAMP>$2</SAMP>       </TD> <TD align=left> Second arg in $*  </TD> <TD align=left> two </TD></TR>  
<TR> <TD align=left>   <SAMP>$3</SAMP>       </TD> <TD align=left> Third arg in $*  </TD> <TD align=left> let's go </TD></TR>  
<TR> <TD align=left>   <SAMP>$4</SAMP>       </TD> <TD align=left> Fourth arg in $*  </TD> <TD align=left> (empty) </TD></TR>  
</table>

<p>The following shell function echoArgs shows the difference between
<FONT face="monospace" color="#000099">$*</FONT> and <FONT face="monospace" color="#000099">$@</FONT>.  To use <FONT face="monospace" color="#000099">$@</FONT> in a for loop, you
must put it in double quotes.

<pre>
echoArgs () { 
    echo $#
    for i in "$@"; do
        echo "($i)";
    done;
    for i in $*; do
        echo "(($i))";
    done
}
$ echoArgs -t two "let's go"
  3
  (-t)
  (two)
  (let's go)
  ((-t))
  ((two))
  ((let's))
  ((go))
</pre>
<p>
To parse command line arguments, I prefer using the <FONT face="monospace" color="#000099">case</FONT>
construct, as shown below, instead of the builtin <FONT face="monospace" color="#000099">getopts</FONT> in
<FONT face="monospace" color="#000099">ba/k sh</FONT>, because case is easier to understand, handles all flag
situations, and will work in <FONT face="monospace" color="#000099">sh</FONT> too.

<p>Here is a more realistic example for a command that takes five possible
flags, in any order.  For the <FONT face="monospace" color="#000099">-n</FONT> flag, we set a shell
variables to remember the state; this technique is common.

<p><table border>
<TR> <TD align=left>   Flag </TD> <TD align=left> Description </TD></TR>
<TR> <TD align=left>   -o OUT </TD> <TD align=left> send output to file OUT </TD></TR>
<TR> <TD align=left>   -n     </TD> <TD align=left> show what you would do but do not do it </TD></TR>
<TR> <TD align=left>   -v     </TD> <TD align=left> give more output, each -v increases verboseness </TD></TR>
<TR> <TD align=left>   -l     </TD> <TD align=left> same as -verbose </TD></TR>
<TR> <TD align=left>   -version </TD> <TD align=left> show the version and quit </TD></TR>
</table>

<p>Here is the code snippet.  Notice the <FONT face="monospace" color="#000099">shift 2</FONT> and the
<FONT face="monospace" color="#000099">$2</FONT> for the -o flag.  Notice that any flag beginning
<FONT face="monospace" color="#000099">-ver</FONT> is considered the same are <FONT face="monospace" color="#000099">-version</FONT>.

<pre>
nflag=0
vlevel=0
OUT=
while [ $# -gt 0 ]; do
  case "$1" in 
   -o ) OUT=$2 ; shift 2 ;;
   -n ) nflag=1 ; shift ;;
   -l | -v ) vlevel=$(( vlevel+1 )) ; shift ;;
   -ver* ) echo "Version $version"  ; exit 1 ;;
   * ) echo "Saw non flag $arg" ; break ;;
  esac
done
... continue processing remaining args ...
</pre>
<p>
<a name="LtohTOCentry-33"></a>
<H3><FONT color=teal>Special variables</FONT></H3>

<p><table border>
<TR> <TD align=left>   $ </TD> <TD align=left> shell's process ID, e.g. tempfile=/tmp/out.$$ </TD></TR>
<TR> <TD align=left>   PATH </TD> <TD align=left> command search path </TD></TR>
<TR> <TD align=left>   CDPATH </TD> <TD align=left> cd search path </TD></TR>
<TR> <TD align=left>   ... </TD> <TD align=left> more to be added </TD></TR>
</table>

<p>
<a name="LtohTOCentry-34"></a>
<hr><H2><FONT color=black>Tilde, brace, and globbing expansions</FONT></H2>

<p>The shells will expand the following strings

<p><table border>
<TR> <TD align=left>   Expansion </TD> <TD align=left> You type </TD> <TD align=left> the shell generates </TD></TR>
<TR> <TD align=left>   Tilde </TD> <TD align=left>  ~  </TD> <TD align=left> your home directory  (<FONT face="monospace" color="#000099">$HOME</FONT>)  </TD></TR>
<TR> <TD align=left>   Tilde </TD> <TD align=left>  ~alison  </TD> <TD align=left> home directory for user <SAMP>alison</SAMP>  </TD></TR>
<TR> <TD align=left>   Brace </TD> <TD align=left>  {1,blue,dot.com}  </TD> <TD align=left> 1 blue dot.com </TD></TR>
<TR> <TD align=left>   Brace </TD> <TD align=left>  x{0,11}y{2,33,}z </TD> <TD align=left> x0y2z x0y33z x0yz x11y2z x11y33z x11yz </TD></TR>
</table>

<p><a name="LtohTOCentry-35"></a>
<H3><FONT color=teal>Globbing and Filename expansion</FONT></H3>

<p>On the command line, the shell does filename expansion replacing
<FONT face="monospace" color="#000099">*.pdf</FONT> will all filenames ending in <SAMP>.pdf</SAMP>.  There are
two separate concepts being used.  The first, called glob matching or
<EM>globbing</EM>, means that some characters like <FONT face="monospace" color="#000099">*</FONT> have
special meaning.  The second concept is that globbing is being applied
to filenames.  Because the two are used almost synomously, most people
think incorrectly think globbing only applies to file names.  However,
the case statement uses globbing on an arbitrary string.

<p>On a command line, the following characters have special meaning.
This process is called <EM>globbing</EM>.  

<p><table border>
<TR> <TD align=left>   * </TD> <TD align=left> Any sequence of characters not containing a <FONT face="monospace" color="#000099">/</FONT>  </TD></TR>
<TR> <TD align=left>   ? </TD> <TD align=left> Any single character </TD></TR>  
<TR> <TD align=left>   [aeiou] </TD> <TD align=left> Any single a, e, i, o or u character</TD></TR>  
<TR> <TD align=left>   [&#094;aeiou] </TD> <TD align=left> Any character <EM>except</EM> a, e, i, o or u </TD></TR>  
</table>

<p>A leading <FONT face="monospace" color="#000099">*</FONT> or <FONT face="monospace" color="#000099">?</FONT> will not match a leading dot
(<FONT face="monospace" color="#000099">.</FONT>) to prevent from * from matching <FONT face="monospace" color="#000099">.</FONT> and <FONT face="monospace" color="#000099">..</FONT>
which would normally cause havoc.  To match files like <TT><FONT color=#660000>.profile</FONT></TT>,
you can use the glob pattern <FONT face="monospace" color="#000099">.*</FONT>.

<p><a name="LtohTOCentry-36"></a>
<H3><FONT color=teal>Filename expansion</FONT></H3>

<p>The shell applies does applies globbing to all command line arguments
matched against filenames starting in the current directory.  Thus
*/*.pdf matches all <FONT face="monospace" color="#000099">.pdf</FONT> files in all subdirectories of the
current directory.

<p><a name="LtohTOCentry-37"></a>
<hr><H2><FONT color=black>Arithmetic</FONT></H2>

<p>In ksh,bash use <FONT face="monospace" color="#000099">$(( expression ))</FONT> to perform arithmetic
operations and <EM>get the result</EM>.  Note that inside <FONT face="monospace" color="#000099">$((
expression ))</FONT>, you do not need to prefix variables with a $ and that
spacing between operators is allowed.  The <FONT face="monospace" color="#000099">(( expression ))</FONT>
syntax is like <FONT face="monospace" color="#000099">$(( expression ))</FONT> but returns true or false iff the
expression succeeded or not; it is used in <SAMP>for</SAMP> loops.

<pre>
echo "Printing out the first few powers of two"
for ((i=1; i&lt;47; i = i * 2)); do
  printf "%4d\n" $i
done

echo "Printing the first few fibonacci numbers"
for ((i = 1, j=0; i &lt; 47; t = i+j, j=i, i=t)); do printf "%4d\n" $i ; done

echo 'using $(( var + 1 )) style'
i=0 j=0 k=0 ll=0
while [ $i -le 4 ]; do
  echo $i $j $k $ll
  i=$(( $i + 1 ))         # OK to use $i
  j=$(( j + i ))          # just 'j' is fine, too
  ll=$(( k += i ))
done
</pre>
<p>
<a name="LtohTOCentry-38"></a>
<hr><H2><FONT color=black>Back tick expansion or command substitution</FONT></H2>

<p>The notation <FONT face="monospace" color="#000099">$(command)</FONT> or the older historic
<FONT face="monospace" color="#000099"><b><font color=#000099>`</font></b>command<b><font color=#000099>`</font></b></FONT> (we use back quotes not the normal forward quotes) is
replaced by the output of the command.  Typically command only produces
one line of output.  For example the <FONT face="monospace" color="#000099">basename PATH</FONT> command
strips off any directory portion of path, so to get the file name in a
script you usually see:

<pre>
  fff=/usr/share/timezone/Pacific.tz
  filepart=$(basename $fff)      # filepart=Pacific.tz
  filepart=`basename $fff`      # filepart=Pacific.tz
</pre>
<p>
To set a variable value to be the contents of a file, you can use either
of

<pre>
  hostname=`cat /etc/HOSTNAME`
  hostname=$(&lt; /etc/HOSTNAME)         # special form
</pre>
<p>
<a name="LtohTOCentry-39"></a>
<hr><H2><FONT color=black>Embedding verbatim text with here documents</FONT></H2>

<p>If you need to print out text nearly verbatim, e.g. you need to generate
a standard 40-line disclaimer, then use a <EM>here document</EM>.  The
general notation is as follows, where you can use any string of your
choice to replace <SAMP>END_DELIMITER</SAMP>.

<pre>
  some-previous-shell-command
  cat &lt;&lt;-END_DELIMITER
    verbatim text
  ...
END_DELIMITER

  cat &lt;&lt;-'END_DELIMITER'             # single quote variation
  cat &lt;&lt;-"END_DELIMITER"             # double quote variation 
</pre>
<p>
The optional minus sign <SAMP>-</SAMP> before END_DELIMITER tells bash to
ignore beginning <EM>tabs</EM> in each line of the verbatim text, so you
can indent this text.  The shell will evaluate shell variables, backtick
expansion and (bash) arithmetic expressions in the verbatim text.  To
suppress this evaluation, put single or double quotes around
END_DELIMITER, as shown and each line of the here document will be
treated as if it had been quoted that way.

<p>Here is a more realistic example, where we generate an HTML header to
the file <FONT face="monospace" color="#000099">$out</FONT>.

<pre>
shell_function() {
  htmldoc=...
  cat &gt;&gt; $out &lt;&lt;-EOS
        &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
	&lt;HTML&gt;&lt;HEAD&gt;
	&lt;TITLE&gt;The HMTL doc: $htmldoc on `date`&lt;/TITLE&gt;
        &lt;/HEAD&gt;
EOS
  ...
}  
</pre>
<p>
<a name="LtohTOCentry-40"></a>
<hr><H2><FONT color=black>Process management</FONT></H2>

<p>The shell can manage several processes (jobs/tasks).  The current or
<EM>selected</EM> job (which must be suspended or running the
background) is marked with a <FONT face="monospace" color="#000099">+</FONT> when you type <FONT face="monospace" color="#000099">jobs</FONT>.  A
foreground process is one that is currently running and has control of
the terminal.  E.g. your keyboard input goes to the foreground process.

<p><table border>
<TR> <TD align=left>   Command </TD> <TD align=left> What </TD></TR>
<TR> <TD align=left>   jobs </TD> <TD align=left> list the jobs running on this shell </TD></TR>
<TR> <TD align=left>   bg [Proc] </TD> <TD align=left> run selected job in the background </TD></TR>
<TR> <TD align=left>   fg [Proc] </TD> <TD align=left> run selected job in the foreground </TD></TR>
<TR> <TD align=left>   CTL-Z </TD> <TD align=left> suspend the current job </TD></TR>
</table>

<p>For example, I had three netscape's and some other processes running and
typed jobs and got:

<pre>
hostest 972 ~/bin$ netscape &     # this was the fifth job/task 
hostest 973 ~/bin$ fg 6           # resume running less
CTL-Z                             # suspend less
hostest 974 ~/bin$ jobs
[1]   Running                 ( cd ~; netscape-v304 ) &  (wd: ~)
[3]   Running                 oclock &  (wd: ~)
[4]   Running                 netscape -geometry =720x700 &  (wd: ~/ftp)
[5]-  Running                 netscape -geometry =720x700 &  (wd: ~/ftp)
[6]+  Stopped                 less -c -s -M ../summary-01-21-01.out  (wd: /tmp/tmp/tmp)
hostest 974 ~/bin$ fg 
</pre>
<p>
In a shell script, the <FONT face="monospace" color="#000099">wait</FONT> command will wait for all
background jobs to finish before proceeding.

<p><FONT color=navy><PRE>
  ...
  commandOne -a -x -b &amp;
  commandTwo -vv file1 file2 &amp;
  wait    # waits for the two previous commands to finish
  ...
</PRE></FONT>

<p><a name="LtohTOCentry-41"></a>
<hr><H2><FONT color=black>Useful commands</FONT></H2>

<p>When writing scripts, I found the following commands particularly
useful.  See the respective man page for all the options.

<p><table border>
<TR> <TD align=left>   uname </TD> <TD align=left> get system info </TD></TR>
<TR> <TD align=left>   basename </TD> <TD align=left> strip off dir component </TD></TR>
<TR> <TD align=left>   dirname </TD> <TD align=left> strip off file component </TD></TR>
<TR> <TD align=left>   date </TD> <TD align=left> get date in arbitrary format </TD></TR>
<TR> <TD align=left>   sed  </TD> <TD align=left> stream editor; use for regex support </TD></TR>
<TR> <TD align=left>   ... </TD> <TD align=left> more to be added </TD></TR>
</table>

<p><a name="LtohTOCentry-42"></a>
<hr><H2><FONT color=black>Reading input</FONT></H2>

<p><a name="LtohTOCentry-43"></a>
<hr><H2><FONT color=black>Some useful functions</FONT></H2>

<p><a name="LtohTOCentry-44"></a>
<hr><H2><FONT color=black>Tips for writing scripts</FONT></H2>

<p>To discard output, send it to <FONT face="monospace" color="#000099">/dev/null</FONT> in Unix.

<p><a name="LtohTOCentry-45"></a>
<hr><H2><FONT color=black>Tips, tricks and examples</FONT></H2>

<p>To process a listing of files <FONT face="monospace" color="#000099">*</FONT> here are three way from worst
to best.

<p><FONT color=navy><PRE>
  # yech
filelist=<b><font color=#000099>`</font></b>ls *<b><font color=#000099>`</font></b>
for ff in $filelist; do ... ; done

<p>  # poor
filelist=<b><font color=#000099>`</font></b>echo *<b><font color=#000099>`</font></b>
for ff in $filelist; do ... ; done

<p>  # best
for ff in *; do ... ; done
</PRE></FONT>

<p><a name="LtohTOCentry-46"></a>
<H3><FONT color=teal>Seeing variables</FONT></H3>

<p>Here is a handy ba/k/sh function that prints out the values of variables
given their <EM>names</EM>.  I list it first since I use it often.

<pre>
   # showVals varname [ varname(s) ]
showVals () {
  for i in $*; do
    eval echo "\ \ \#\#  $i=\(\$$i\)"
  done
}
...
showVals USER HOME PS1 outFile nflag
</pre>
<p>
<a name="LtohTOCentry-47"></a>
<H3><FONT color=teal>Doing glob matching</FONT></H3>

<p>In bash and sh you must use <FONT face="monospace" color="#000099">case</FONT>.  Here is a handy function,
<FONT face="monospace" color="#000099">globmatch</FONT>, that lets you glob match anywhere.

<pre>
  # Ex:  matches [ -q ] string globpattern
  # Does $1 match the glob expr $2 ?
  #     -q flag = set return status to 0 (true) or 1 (false)
  #  no -q flag = echo "1" (true) or "0" (false)
  # Unfortunately, the return status is opposite from the echo'ed string
globmatches () {
  if [ $1 = "-q" ]; then
    shift
    case "$1" in
      $2 ) true ;;
      * ) false ;;
    esac
  else
    case "$1" in
      $2 ) echo 1 ; true ;;
      * ) echo 0 ; false ;;
    esac
  fi
}  

if globmatches -q $file "*.tar" ; then
  echo "Found a tar file"
elif globmatches -q $file "*zip" ; then
  echo "Found a zip file"
if 
</pre>
<p>
<a name="LtohTOCentry-48"></a>
<H3><FONT color=teal>Extracting data</FONT></H3>

<p>You will often get data with multiple fields or <EM>words</EM>.  To
extract and print the K-th word, where the first word is K=1, use either
of

<pre>
  set  - ... | echo $K        # purely shell based solution
  ... | awk '{ print $K; }'   # requires awk or nawk or gawk
  ... | cut -f K -s ' '       # least preferred method
</pre>
<p>
For simple tasks, using the shell built in <FONT face="monospace" color="#000099">set</FONT> is easiest.  It
is better to use awk (or gawk or nawk) because awk handles words
separate by spaces and tabs correctly.  The <FONT face="monospace" color="#000099">cut</FONT> program (as of
2001) is quite stupid and assumes precisely one space between words.

<p>To extract the K-th, M-th and P-th words, use either of

<pre>
  awk '{ print $K, $M, $P; }'
  cut -f K,M,P -s ' '
</pre>

<p><a name="LtohTOCentry-49"></a>
<H3><FONT color=teal>Precede debugging/verbose messages with common prefix</FONT></H3>

<p>I personally like '#' because this is the comment character for both
scripts and perl.  Sometimes, one shell script generates a second
script, in which case I must precede optional messages with a comment
character.

<p><FONT color=navy><PRE>
  echo "# Do not modify this script.  Auto-generated by master script $0"
  ...
  echo "# FYI, variable color=$color"
</PRE></FONT>

<p><a name="LtohTOCentry-50"></a>
<H3><FONT color=teal>No full paths</FONT></H3>
Do not put full paths in your script, because if the path is wrong, say
on a different OS/platform, you have to change all the paths in your
script.  Instead augment the PATH as necessary.  E.g. if your script
need to run <FONT face="monospace" color="#000099">/usr/ucb/whoami</FONT>, then put the following in your
script.  On a different platform, you only have to augment the PATH
differently.

<p><FONT color=navy><PRE>
PATH=/usr/ucb:$PATH
...
... whoami ...
</PRE></FONT>

<p><a name="LtohTOCentry-51"></a>
<H3><FONT color=teal>Finding executables in a script</FONT></H3>

<p>To run an executable <FONT face="monospace" color="#000099">exe</FONT>, set the PATH and then verify
you can find <FONT face="monospace" color="#000099">exe</FONT>.

<p><FONT color=navy><PRE>
PATH=...places-you-expect-to-find-exe...:<i>PATH

<p>if ! type -p </i>exe 2&gt; /dev/null; then
  echo "Unable to find <i>exe.   Bye." ; exit
fi
</PRE></FONT>

<p><a name="LtohTOCentry-52"></a>
<H3><FONT color=teal>Guarenteed Cleanup</FONT></H3>

<p>Using the <FONT face="monospace" color="#000099">trap</FONT> builtin, you can run an any command whenever the
shell gets a specific signal.  So what?  The most common use of trap is
do gauranteed cleanup when a shell script exits in any way (control C,
normal exit, error in the middle).  Here's an example

<p><FONT color=navy><PRE>
logfile=/tmp/file-</i><i>.log

<p>cleanup() 
  echo "running cleanup ..."
  rm </i>logfile


<p>trap cleanup EXIT

<p>... rest of script ...
</PRE></FONT>

<p><a name="LtohTOCentry-53"></a>
<H3><FONT color=teal>Simple regular expression substitution</FONT></H3>

<p>To change or <EM>substitute</EM> the text FROMX to TOX, use
<FONT face="monospace" color="#000099">sed</FONT>.  You can specify regular expressions for FROMX.
A 
<FONT color=navy><PRE>
  sed -e "s/FROMX/TOX/"		# subst first occurrence
  sed -e "s/FROMX/TOX/g"        # subst all occurrences
    # strip off domain name (remove .in20pages.com) 
  echo "speedster.in20pages.com" | sed -e "s/[.].*$//"
    # keep domain name (remove speedster.)
  echo "speedster.in20pages.com" | sed -e "s/&#094;[&#094;.]*[.]//"
</PRE></FONT>

<p><a name="LtohTOCentry-54"></a>
<H3><FONT color=teal>Floating point math and base calculations</FONT></H3>

<p>Use <FONT face="monospace" color="#000099">dc</FONT>, the postfix or RPN calculator, or <FONT face="monospace" color="#000099">bc</FONT> which
takes human familiar infix notation.  I strongly prefer <FONT face="monospace" color="#000099">dc</FONT>.  In
the following examples, I store the results in variables <FONT face="monospace" color="#000099">rx</FONT>,
<FONT face="monospace" color="#000099">rhex</FONT> and <FONT face="monospace" color="#000099">wacko</FONT>.  In <FONT face="monospace" color="#000099">dc</FONT>, the commands
<FONT face="monospace" color="#000099">i</FONT>, <FONT face="monospace" color="#000099">o</FONT>, <FONT face="monospace" color="#000099">k</FONT> mean set the input base, output base,
calculation precision, respectively.  In <FONT face="monospace" color="#000099">dc</FONT>, <FONT face="monospace" color="#000099">p</FONT> means
print the top of the stack.

<p><FONT color=navy><PRE>
    # calculate (2.718 + 1.414) / (3.141 - 2)  to 5 decimal places
  rx=<b><font color=#000099>`</font></b>echo 5 k  2.718 1.414 + 3.141 2 - / p | dc<b><font color=#000099>`</font></b>
    # convert 12345 to hex (base 16)
  rhex=<b><font color=#000099>`</font></b>echo 16 o  12345 p | dc<b><font color=#000099>`</font></b>
    # convert 12345 base 7 to octal (base 8) [All your base are belong to us]
  wacky=<b><font color=#000099>`</font></b>echo 7 i 8 o  12345 p | dc<b><font color=#000099>`</font></b>
</PRE></FONT>

<p><a name="LtohTOCentry-55"></a>
<H3><FONT color=teal>One liners</FONT></H3>

<p><UL>
  <li><strong></strong> Use <FONT face="monospace" color="#000099">pushd</FONT> and <FONT face="monospace" color="#000099">popd</FONT> to change and restore the
current directory.  I usually redirect output to <TT><FONT color=#660000>/dev/null</FONT></TT>.
  <li><strong></strong> Use <FONT face="monospace" color="#000099">mkdir -p</FONT> to create directories.
  <li><strong></strong> Use <FONT face="monospace" color="#000099">case</FONT> to do glob matching.
</UL>

<p><a name="LtohTOCentry-56"></a>
<H3><FONT color=teal>Sending the output of multiple commands</FONT></H3>

<p>You can redirect the output of shell functions and control-flow
constructs just like simple commands.

<p>Ex.  You want "less" the all output of grep'ing for the patterns in
PATTS over files in the list FLIST all in one.  Here are two ways.

<p><FONT color=navy><PRE>
PATTS="cat dog m.*e"
FLIST="*pets*.txt"

<p># Method 1
greputil () 
  for p in <i>PATTS ; do
    grep </i>p <i>FILES
  done

greputil | less

<p># Method 2
for p in </i>PATTS ; do
  grep <i>p </i>FILES
done | less
</PRE></FONT>

<p><a name="LtohTOCentry-57"></a>
<hr><H2><FONT color=black>Final thoughts</FONT></H2>

<p>Note that bash version 3 was first released in 2004 with at least one
major update (v 3.1) since then.

<p>For more scripting information, search for "advanced bash" in any search
engine (e.g.  \rqhttpxhttp://www.google.com/search?q=advanced+bash

<p>
<HR>
<font size=+0> <EM>[LaTeX -> HTML by <a href="http://www.quong.com/ltoh/">ltoh</a>]</EM></font><br>
<ADDRESS>
<font size=+0><A href="http://www.quong.com/">Russell W. Quong</A>
(<A href="mailto:ltoh@quong.REMOVE-THIS.SPAM.FILTER.PART-com."><SAMP>ltoh@quong.REMOVE-THIS.SPAM.FILTER.PART-com.</SAMP></A>)
<br>Last modified: <font color=maroon><samp>Oct  3 2008</samp></font>
</font></ADDRESS>
</BODY>
</HTML>
